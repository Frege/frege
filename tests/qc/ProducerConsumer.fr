--- This is an undocumented module
module tests.qc.ProducerConsumer where

import Control.pipe.Producer
import Control.pipe.Consumer
import Control.pipe.Pipe

import Control.monad.trans.MonadTrans (lift)

import Test.QuickCheck

-- separate producer test

-- a producer of the numbers that allows consumption in the context Monad "m", ending with a String
produce12 :: (Num n, Monad m) => Producer n m String
produce12 = do
  produce 1             -- produce a number
  produce 2
  endWith "the end"

-- for the test case, we use Maybe as the context monad, in real usages this is often IO
producerTestRun = once (  runProducer produce12 == Just ( [1, 2], "the end") )

-- separate consumer test

-- we consume values of type (Maybe n) - since production might fail - as needed for pipe
consumeTwiceAndAdd :: (Num n) => Consumer (Maybe n) Maybe n
consumeTwiceAndAdd = do
        a <- consume
        b <- consume
        -- lift $ Just ( unJust a + unJust b) -- using unJust is not nice, better sequence and map
        lift $ fmap (foldr1 (+)) (sequence [a,b]) -- note that we must lift the result into the context monad

consumerTestRun = once (  runConsumer [Just 1, Just 2] consumeTwiceAndAdd ==  Just 3)

-- pipe test in combination

pipeTestRun = once ( pipe produce12 consumeTwiceAndAdd == Just ("the end", 3) )


-- more complex pipe test with stateful consumer

produceInts :: Monad m => Int -> Int -> Producer Int m ()
produceInts start end | start == end = do endWith ()
                      | otherwise    = do
                                          produce start
                                          produceInts (start + 1) end

consumeStatefully :: Mutable s (Ref Int) -> Consumer (Maybe a) (ST s) (ST s Int)
consumeStatefully countRef = do
  mayInt <- consume
  case mayInt of
    Just num -> do
                lift $ countRef.modify (+1)
                consumeStatefully countRef
    Nothing  -> pure countRef.get

pipeAction num = do
    startRef <- Ref.new 0
    (producerResult, consumerResult) <- pipe (produceInts 0 num) (consumeStatefully startRef)
    consumerResult

-- this discards to many numbers, todo: use a better generator
-- pipeWithStateTest = property $ \num -> num >= 0 && num < 100000 ==> (pipeAction num).run == num

pipeWithStateTest0   = once $ (pipeAction   0).run ==   0
pipeWithStateTest1   = once $ (pipeAction   1).run ==   1
pipeWithStateTest100 = once $ (pipeAction 100).run == 100
