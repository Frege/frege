--- This is an undocumented module
module tests.qc.ProducerConsumer where

import Control.pipe.Producer
import Control.pipe.Consumer
import Control.pipe.Pipe

import Control.monad.trans.MonadTrans (lift)

import Test.QuickCheck

-- separate producer test

-- a producer of the numbers that allows consumption in the context Monad "m", ending with a String
produce12 :: (Num n, Monad m) => Producer n m String
produce12 = do
  produce 1             -- produce a number
  produce 2
  endWith "the end"

-- for the test case, we use Maybe as the context monad, in real usages this is often IO
producerTestRun = once (  runProducer produce12 == Just ( [1, 2], "the end") )

-- separate consumer test

-- we consume values of type (Maybe n) - since production might fail - as needed for pipe2
consumeTwiceAndAdd :: (Num n) => Consumer (Maybe n) Maybe n
consumeTwiceAndAdd = do
        a <- consume
        b <- consume
        -- lift $ Just ( unJust a + unJust b) -- using unJust is not nice, better sequence and map
        lift $ fmap (foldr1 (+)) (sequence [a,b]) -- note that we must lift the result into the context monad

consumerTestRun = once (  runConsumer [Just 1, Just 2] consumeTwiceAndAdd ==  Just 3)

-- pipe test in combination

pipeTestRun = once ( pipe2 produce12 consumeTwiceAndAdd == Just ("the end", 3) )

