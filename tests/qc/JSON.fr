--- Test properties of the 'Json' module
module tests.qc.JSON where

import frege.Prelude hiding(Object)

import Data.JSON as Json(Value, runParser, parseValue, lexer, parseJSON, toJSON, fromJSON)
import Test.QuickCheck as Q public

instance Arbitrary Value where
    arbitrary = frequency [
                        (5,  return Null),
                        (6,  Bool   <$> arbitrary),
                        (42, String <$> arbitrary),
                        (6,  Number . Double.show  <$> arbitrary),
                        (6,  Number . Float.show   <$> arbitrary),
                        (6,  Number . Integer.show <$> arbitrary),
                        (6,  Number . Int.show     <$> arbitrary),
                        (6,  Number . Long.show    <$> arbitrary),
                        (6,  Number . Short.show   <$> arbitrary),
                        -- doesn't work because @show (byte 0) == "0x00"@
                        -- (5,  Number . Byte.show    <$> arbitrary),
                        (1,  Array  <$> arbitrary),
                        (1,  Struct <$> arbitrary),
                    ]


--- parsing the 'String' representation of any 'Value' yields the same 'Value'
p_value = property $ \(a::Value) -> let 
            json = show a
            len  = length json `quot` 100
            coll = "json text length %d00..%d00".format len (len+1) :: String
        in collect coll (runParser parseValue (lexer json) == Right a)

--- JSON round trip
fromTo âˆ· (Json.ToJSON ğ–‡,Json.FromJSON ğ–‡) â‡’ ğ–‡ â†’ Either String ğ–‡
fromTo = fromJSON . toJSON

--- parsing the JSON representation of some value yields the same value
checkFromTo âˆ· (Json.ToJSON ğ–†,Json.FromJSON ğ–†,Eq ğ–†) â‡’ ğ–† â†’ Bool
checkFromTo x = fromTo x == Right x

p_roundUnit     = once      (checkFromTo âˆ· ()               â†’ Bool)
p_roundBool     = property  (checkFromTo âˆ· Bool             â†’ Bool)
p_roundChar     = property  (checkFromTo âˆ· Char             â†’ Bool)
p_roundInt      = property  (checkFromTo âˆ· Int              â†’ Bool)
p_roundLong     = property  (checkFromTo âˆ· Long             â†’ Bool)
p_roundInteger  = property  (checkFromTo âˆ· Integer          â†’ Bool)
p_roundFloat    = property  (checkFromTo âˆ· Float            â†’ Bool)
p_roundDouble   = property  (checkFromTo âˆ· Double           â†’ Bool)
p_roundString   = property  (checkFromTo âˆ· String           â†’ Bool)
p_roundList     = property  (checkFromTo âˆ· [String]         â†’ Bool)
p_roundMaybe    = property  (checkFromTo âˆ· Maybe [Char]     â†’ Bool)
p_roundTuple    = property  (checkFromTo âˆ· (String, Double) â†’ Bool)


main [s] = println $ do
    runParser parseValue (lexer s)
main _ = return ()