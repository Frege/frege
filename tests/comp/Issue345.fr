--- https://github.com/Frege/frege/issues/345 Issue 345
module tests.comp.Issue345 where

--- fine
leer ∷ ListEmpty α ⇒ α β
leer = empty

--- fails
ganzLeer ∷ ListEmpty a ⇒ a b
ganzLeer = empty

foo :: (ListEmpty m) => m a
foo = empty

class MyEmpty m where
  myEmpty :: m a

bar :: (MyEmpty m) => m a
bar = myEmpty

data Foo = Foo (Maybe Int)

-- the following doesn't compile

polymorphic :: (ListEmpty m) => m a
polymorphic = empty

concrete1 :: [a]
concrete1 = empty

concrete2 :: String
concrete2 = empty

concrete2a :: String
concrete2a = (empty :: String)

concrete2b :: String
concrete2b = empty ++ (empty :: String) -- same if operands are flipped

concrete2c :: String
concrete2c = "" ++ (empty :: String)  -- same if operands are flipped

foo1 :: Foo
foo1 = Foo (empty :: Maybe Int)

-- the following does compile

concrete2d :: String
concrete2d = "" ++ empty  -- same if operands are flipped

concrete2e :: String
concrete2e = empty ++ empty

foo2 :: Foo
foo2 = Foo empty

-- other special typeclasses

lsemi :: (ListSemigroup m) => m a -> m a -> m a
lsemi as bs = as ++ bs

lsrc :: (ListSource m) => m a -> [a]
lsrc a = toList a

lsrc' :: (ListSource m) => m a -> [a]
lsrc' = toList

lmono :: (ListMonoid m) => [m a] -> m a
lmono as = concat as

lview :: (ListView m) => m a -> a
lview xs =
  -- try as many member functions as possible
  case uncons . tail . take 1 . drop 1 $ xs of
    Just (a, e) -> const a (length e)
    Nothing -> head xs

-- combined with non-special typeclasses

fooM :: (Monad m, ListEmpty m) => m Int
fooM = empty >>= \_ -> return 1

fooMy :: (Monad m, MyEmpty m, ListEmpty m) => m Int
fooMy = empty >>= \_ -> myEmpty >>= \_ -> return 1
