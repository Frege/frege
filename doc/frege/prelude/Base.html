<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<META http-equiv="Content-Type" content="text/html;charset=utf-8">
<TITLE>frege.prelude.Base - frege documentation</TITLE>
<style TYPE="text/css">
body { font-family: helvetica, arial, sans-serif }
pre { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
h3  { font-weight: lighter }
dt.func { background: rgb(95%, 95%, 80%) }
dt.clas { background: rgb(80%, 95%, 95%) }
dt.inst { background: rgb(95%, 90%, 95%) }
dt.data { background: rgb(95%, 95%, 95%) }
span.code { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
span.unknown { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: red }
a.fref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(30%, 30%, 0%) }
a.tref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(40%, 0%,  40%) }
</style>
<BODY>
<H1>
<A name="package">Package <SPAN CLASS="code">frege.prelude.Base</SPAN></A></H1>
<P>
Compiled: Thu Oct 20 00:54:19 CEST 2011 from source file: <SPAN CLASS="code">frege/prelude/Base.fr</SPAN></P>
<H3>
Package Documentation</H3>
<P>
Copyright © 2011, Ingo Wechsung</P>
<P>
All rights reserved.</P>
<P>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</P>
<UL>
<LI>
   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</LI>
<LI>
   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</LI>
</UL>
<P>
<B>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</B></P>
<P>
This package provides basic definitions for the Frege language.</P>
<P>
The <I>Prelude</I> is imported explicitely or implicetely during compilation of any other package. It defines basic data structures, classes and functions.</P>
<P>
The types and constructors for lists, unit type and tuple types are not defined here: They are provided programmaticaly by the compiler when it compiles a package with the name <SPAN CLASS="code">frege.prelude.Base</SPAN>. Nevertheless, they are considered part of the <I>Prelude</I>, thus qualified names like <SPAN CLASS="code">Prelude.(,)</SPAN> are okay.</P>
<P>
The package is <I>implementation specific</I> insofar as the compiler may assume that certain items are defined here in a certain way. Changes may thus lead to compiler crashes or java code that will be rejected by the java compiler.</P>
<P>
Overview of the type class hierarchy</P>
<PRE>
   Eq                         equality, provides relational operators '==' and '!='
       Ord                    ordering, provides relational operators '&lt;' '&lt;=' '&gt;' '&gt;=' and '&lt;=&gt;'
           Enum               enumarations (succ, pred, etc.)
           Num                numbers
               Real           real numbers
               Integral       integral numbers
   Show                       string representation of values
   Length                     data types that have a length
   Empty                      data types that have an empty value
   AbstractList               data types that behave like lists</PRE>
<H3>
Table of Content</H3>
<UL>
<LI>
<DIV>
<A HREF="#type">Type Aliases</A></DIV>
<DIV>
<A class="tref" href="#Array">Array</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Exception">Exception</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Frozen">Frozen</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#IO">IO</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#IORef">IORef</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#IntArr">IntArr</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Mutable">Mutable</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#StringArr">StringArr</A></DIV>
</LI>
<LI>
<DIV>
<A HREF="#class">Classes</A></DIV>
<DIV>
<A class="tref" href="#AbstractList">AbstractList</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Bounded">Bounded</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Cloneable">Cloneable</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Empty">Empty</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Enum">Enum</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq">Eq</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Freezable">Freezable</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Functor">Functor</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#IntegerConvertable">IntegerConvertable</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Integral">Integral</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Length">Length</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#ListSource">ListSource</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Monad">Monad</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Num">Num</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ord">Ord</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Real">Real</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Serializable">Serializable</A></DIV>
</LI>
<LI>
<DIV>
<A HREF="#instance">Instances</A></DIV>
<DIV>
<A class="tref" href="#AbstractList_String">AbstractList_String</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#AbstractList__lbrack_rbrack">AbstractList_[]</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Bounded_Bool">Bounded_Bool</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Bounded_Char">Bounded_Char</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Bounded_Int">Bounded_Int</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Bounded_Long">Bounded_Long</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Cloneable_IntArray">Cloneable_IntArray</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Cloneable_STArray">Cloneable_STArray</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Cloneable_StringArray">Cloneable_StringArray</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Empty_String">Empty_String</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Empty__lbrack_rbrack">Empty_[]</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Enum_Bool">Enum_Bool</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Enum_Char">Enum_Char</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Enum_Int">Enum_Int</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Enum_Integer">Enum_Integer</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Enum_Long">Enum_Long</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq__lpar_rpar">Eq_()</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq_Bool">Eq_Bool</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq_Char">Eq_Char</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq_Double">Eq_Double</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq_Float">Eq_Float</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq_Int">Eq_Int</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq_Long">Eq_Long</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq_String">Eq_String</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Eq__lbrack_rbrack">Eq_[]</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Functor_Either">Functor_Either</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Functor_Maybe">Functor_Maybe</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#IntegerConvertable_Int">IntegerConvertable_Int</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#IntegerConvertable_Long">IntegerConvertable_Long</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Integral_Int">Integral_Int</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Integral_Integer">Integral_Integer</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Integral_Long">Integral_Long</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Length_String">Length_String</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Length__lbrack_rbrack">Length_[]</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#ListSource_Either">ListSource_Either</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#ListSource_Maybe">ListSource_Maybe</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Monad_Either">Monad_Either</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Monad_Maybe">Monad_Maybe</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Monad_ST">Monad_ST</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Monad_State">Monad_State</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Num_Int">Num_Int</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Num_Long">Num_Long</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ord_Bool">Ord_Bool</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ord_Char">Ord_Char</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ord_Double">Ord_Double</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ord_Float">Ord_Float</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ord_Int">Ord_Int</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ord_Integer">Ord_Integer</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ord_Long">Ord_Long</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ord_String">Ord_String</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Real_Double">Real_Double</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Real_Float">Real_Float</A></DIV>
</LI>
<LI>
<DIV>
<A HREF="#data">Data Types</A></DIV>
<DIV>
<A class="tref" href="#Unit">()</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple2">(,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple3">(,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple4">(,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple5">(,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple6">(,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple7">(,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple8">(,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple9">(,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple10">(,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple11">(,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple12">(,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple13">(,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple14">(,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple15">(,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple16">(,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple17">(,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple18">(,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple19">(,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple20">(,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple21">(,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple22">(,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple23">(,,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple24">(,,,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple25">(,,,,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Tuple26">(,,,,,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Function">-&gt;</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Char">Char</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Class">Class</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Either">Either</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Immutable">Immutable</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#IntArray">IntArray</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#JBoolean">JBoolean</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#JByte">JByte</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#JChar">JChar</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#JDouble">JDouble</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#JException">JException</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#JFloat">JFloat</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#JInteger">JInteger</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#JLong">JLong</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#JShort">JShort</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Matcher">Matcher</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Maybe">Maybe</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Ordering">Ordering</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#RealWorld">RealWorld</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Regex">Regex</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#ST">ST</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#STArray">STArray</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#STRef">STRef</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#State">State</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#StringArray">StringArray</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Undefined">Undefined</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#Void">Void</A>&nbsp;&nbsp;&nbsp; <A class="tref" href="#List">[]</A></DIV>
</LI>
<LI>
<DIV>
<A HREF="#let">Functions and Values (alphabetically)</A></DIV>
<DIV>
<A class="fref" href="#_excl">!</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_excl_eq_eq">!==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_excl_tilde">!~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_dollar">$</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#$_excl">$!</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_amp_amp">&amp;&amp;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_div_tilde">/~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_lt_tilde">&lt;~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_eq_eq_eq">===</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_eq_tilde">=~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_qm_tilde">?~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_at">@</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#all">all</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#and">and</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#any">any</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ascending">ascending</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#atoi">atoi</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#chr">chr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#comparing">comparing</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#concat">concat</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_const">const</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#constructor">constructor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#cstos">cstos</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ctos">ctos</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#curry">curry</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#cycle">cycle</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#descending">descending</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#drop">drop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#dropUntil">dropUntil</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#dropWhile">dropWhile</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#either">either</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#elem">elem</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#elemBy">elemBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#error">error</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#filter">filter</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#flip">flip</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fold">fold</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldM">foldM</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldM_">foldM_</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldl">foldl</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldl_tick">foldl'</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldl1">foldl1</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldr">foldr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldrs">foldrs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#forM">forM</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#forM_">forM_</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fromJust">fromJust</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fromMaybe">fromMaybe</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fst">fst</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#group">group</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#groupBy">groupBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#head">head</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#id">id</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#init">init</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#intersperse">intersperse</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#isJust">isJust</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#isNothing">isNothing</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#iterate">iterate</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#last">last</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#lazyif">lazyif</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#liftM">liftM</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#liftM2">liftM2</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#liftM3">liftM3</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#liftM4">liftM4</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#map">map</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#mapM">mapM</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#mapM_">mapM_</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#maybe">maybe</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#not">not</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#notElem">notElem</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#or">or</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#otherwise">otherwise</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#packed">packed</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#partition">partition</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#printStr">printStr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#printStrLn">printStrLn</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#regcomp">regcomp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#repeat">repeat</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#reverse">reverse</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanl">scanl</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanl1">scanl1</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#seq">seq</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#sequence">sequence</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#sequence_">sequence_</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#snd">snd</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#sort">sort</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#sortBy">sortBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#span">span</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#stocs">stocs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strhead">strhead</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple10">strictTuple10</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple11">strictTuple11</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple12">strictTuple12</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple13">strictTuple13</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple14">strictTuple14</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple15">strictTuple15</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple16">strictTuple16</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple17">strictTuple17</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple18">strictTuple18</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple19">strictTuple19</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple2">strictTuple2</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple20">strictTuple20</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple21">strictTuple21</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple22">strictTuple22</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple23">strictTuple23</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple24">strictTuple24</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple25">strictTuple25</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple26">strictTuple26</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple3">strictTuple3</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple4">strictTuple4</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple5">strictTuple5</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple6">strictTuple6</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple7">strictTuple7</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple8">strictTuple8</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple9">strictTuple9</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strtail">strtail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#substr">substr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#take">take</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#takeUntil">takeUntil</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#takeWhile">takeWhile</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_throw">throw</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#trace">trace</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#traceLn">traceLn</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#traceStr">traceStr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_try">try</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unJust">unJust</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#uncurry">uncurry</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#undefined">undefined</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#uniq">uniq</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#uniqBy">uniqBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unique">unique</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#uniqueBy">uniqueBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unless">unless</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unpacked">unpacked</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unzip">unzip</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#using">using</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_void">void</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#when">when</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#xor">xor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#zip">zip</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#zipWith">zipWith</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_bar_bar">||</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_tilde">~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_tilde_gt">~&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_tilde_tilde">~~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_tilde_tilde_tilde">~~~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_bullet">•</A></DIV>
</LI>
<LI>
<DIV>
<A HREF="#case">Functions and Values (by type)</A></DIV>
<DIV>
<A class="fref" href="#_excl">!</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_excl_eq_eq">!==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_excl_tilde">!~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_dollar">$</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#$_excl">$!</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_amp_amp">&amp;&amp;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_div_tilde">/~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_lt_tilde">&lt;~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_eq_eq_eq">===</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_eq_tilde">=~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_qm_tilde">?~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_at">@</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#all">all</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#and">and</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#any">any</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ascending">ascending</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#atoi">atoi</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#chr">chr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#comparing">comparing</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#concat">concat</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_const">const</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#constructor">constructor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#cstos">cstos</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ctos">ctos</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#curry">curry</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#cycle">cycle</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#descending">descending</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#drop">drop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#dropUntil">dropUntil</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#dropWhile">dropWhile</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#either">either</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#elem">elem</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#elemBy">elemBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#error">error</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#filter">filter</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#flip">flip</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fold">fold</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldM">foldM</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldM_">foldM_</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldl">foldl</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldl_tick">foldl'</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldl1">foldl1</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldr">foldr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#foldrs">foldrs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#forM">forM</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#forM_">forM_</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fromJust">fromJust</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fromMaybe">fromMaybe</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fst">fst</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#group">group</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#groupBy">groupBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#head">head</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#id">id</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#init">init</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#intersperse">intersperse</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#isJust">isJust</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#isNothing">isNothing</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#iterate">iterate</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#last">last</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#lazyif">lazyif</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#liftM">liftM</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#liftM2">liftM2</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#liftM3">liftM3</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#liftM4">liftM4</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#map">map</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#mapM">mapM</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#mapM_">mapM_</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#maybe">maybe</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#not">not</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#notElem">notElem</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#or">or</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#otherwise">otherwise</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#packed">packed</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#partition">partition</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#printStr">printStr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#printStrLn">printStrLn</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#regcomp">regcomp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#repeat">repeat</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#reverse">reverse</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanl">scanl</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanl1">scanl1</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#seq">seq</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#sequence">sequence</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#sequence_">sequence_</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#snd">snd</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#sort">sort</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#sortBy">sortBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#span">span</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#stocs">stocs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strhead">strhead</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple10">strictTuple10</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple11">strictTuple11</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple12">strictTuple12</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple13">strictTuple13</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple14">strictTuple14</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple15">strictTuple15</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple16">strictTuple16</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple17">strictTuple17</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple18">strictTuple18</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple19">strictTuple19</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple2">strictTuple2</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple20">strictTuple20</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple21">strictTuple21</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple22">strictTuple22</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple23">strictTuple23</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple24">strictTuple24</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple25">strictTuple25</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple26">strictTuple26</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple3">strictTuple3</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple4">strictTuple4</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple5">strictTuple5</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple6">strictTuple6</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple7">strictTuple7</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple8">strictTuple8</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strictTuple9">strictTuple9</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strtail">strtail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#substr">substr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#take">take</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#takeUntil">takeUntil</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#takeWhile">takeWhile</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_throw">throw</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#trace">trace</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#traceLn">traceLn</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#traceStr">traceStr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_try">try</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unJust">unJust</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#uncurry">uncurry</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#undefined">undefined</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#uniq">uniq</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#uniqBy">uniqBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unique">unique</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#uniqueBy">uniqueBy</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unless">unless</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unpacked">unpacked</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#unzip">unzip</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#using">using</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_void">void</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#when">when</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#xor">xor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#zip">zip</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#zipWith">zipWith</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_bar_bar">||</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_tilde">~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_tilde_gt">~&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_tilde_tilde">~~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_tilde_tilde_tilde">~~~</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#_bullet">•</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#AbstractList:tail">AbstractList.tail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#AbstractList:_plus_plus">AbstractList.++</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded:minBound">Bounded.minBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded:maxBound">Bounded.maxBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable:freeze">Cloneable.freeze</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable:clone">Cloneable.clone</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable:thaw">Cloneable.thaw</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Empty:_null">Empty.null</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Empty:empty">Empty.empty</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum:ord">Enum.ord</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum:_lt_eq_gt">Enum.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum:_dot_dot">Enum...</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum:from">Enum.from</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum:succ">Enum.succ</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum:pred">Enum.pred</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq:_div_eq">Eq./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq:_excl_eq">Eq.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq:_eq_eq">Eq.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Freezable:our">Freezable.our</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Freezable:freeze">Freezable.freeze</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Freezable:withFrozen">Freezable.withFrozen</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Freezable:thaw">Freezable.thaw</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Functor:fmap">Functor.fmap</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntegerConvertable:big">IntegerConvertable.big</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral:bshr">Integral.bshr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral:bor">Integral.bor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral:band">Integral.band</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral:bshl">Integral.bshl</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral:div">Integral.div</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral:bxor">Integral.bxor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral:mod">Integral.mod</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral:rem">Integral.rem</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Length:length">Length.length</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ListSource:toList">ListSource.toList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad:_gt_gt_eq">Monad.&gt;&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad:_gt_gt">Monad.&gt;&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad:fail">Monad.fail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad:_return">Monad.return</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:isNaN">Num.isNaN</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:_minus">Num.-</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:_plus">Num.+</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:_star">Num.*</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:fromInt">Num.fromInt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:abs">Num.abs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:isInfinite">Num.isInfinite</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:sign">Num.sign</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:negate">Num.negate</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:isNumber">Num.isNumber</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:one">Num.one</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:subtract">Num.subtract</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num:zero">Num.zero</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:_lt_eq">Ord.&lt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:_lt">Ord.&lt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:_excl_eq">Ord.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:_gt_eq">Ord.&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:_eq_eq">Ord.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:_lt_eq_gt">Ord.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:_gt">Ord.&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:max">Ord.max</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:compare">Ord.compare</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord:min">Ord.min</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real:_div">Real./</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Serializable:freeze">Serializable.freeze</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Serializable:copySerializable">Serializable.copySerializable</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Serializable:thaw">Serializable.thaw</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#AbstractList_String:tail">AbstractList_String.tail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#AbstractList_String:_plus_plus">AbstractList_String.++</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#AbstractList__lbrack_rbrack:tail">AbstractList_[].tail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#AbstractList__lbrack_rbrack:_plus_plus">AbstractList_[].++</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded_Bool:minBound">Bounded_Bool.minBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded_Bool:maxBound">Bounded_Bool.maxBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded_Char:minBound">Bounded_Char.minBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded_Char:maxBound">Bounded_Char.maxBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded_Int:minBound">Bounded_Int.minBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded_Int:maxBound">Bounded_Int.maxBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded_Long:minBound">Bounded_Long.minBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Bounded_Long:maxBound">Bounded_Long.maxBound</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_IntArray:freeze">Cloneable_IntArray.freeze</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_IntArray:clone">Cloneable_IntArray.clone</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_IntArray:thaw">Cloneable_IntArray.thaw</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_IntArray:our">Cloneable_IntArray.our</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_IntArray:withFrozen">Cloneable_IntArray.withFrozen</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_STArray:freeze">Cloneable_STArray.freeze</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_STArray:clone">Cloneable_STArray.clone</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_STArray:thaw">Cloneable_STArray.thaw</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_STArray:our">Cloneable_STArray.our</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_STArray:withFrozen">Cloneable_STArray.withFrozen</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_StringArray:freeze">Cloneable_StringArray.freeze</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_StringArray:clone">Cloneable_StringArray.clone</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_StringArray:thaw">Cloneable_StringArray.thaw</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_StringArray:our">Cloneable_StringArray.our</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Cloneable_StringArray:withFrozen">Cloneable_StringArray.withFrozen</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Empty_String:_null">Empty_String.null</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Empty_String:empty">Empty_String.empty</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Empty__lbrack_rbrack:_null">Empty_[].null</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Empty__lbrack_rbrack:empty">Empty_[].empty</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Bool:from">Enum_Bool.from</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Bool:_dot_dot">Enum_Bool...</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Bool:pred">Enum_Bool.pred</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Bool:ord">Enum_Bool.ord</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Bool:succ">Enum_Bool.succ</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Char:from">Enum_Char.from</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Char:_dot_dot">Enum_Char...</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Char:pred">Enum_Char.pred</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Char:ord">Enum_Char.ord</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Char:succ">Enum_Char.succ</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Int:from">Enum_Int.from</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Int:_dot_dot">Enum_Int...</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Int:pred">Enum_Int.pred</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Int:ord">Enum_Int.ord</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Int:succ">Enum_Int.succ</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Integer:from">Enum_Integer.from</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Integer:_dot_dot">Enum_Integer...</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Integer:pred">Enum_Integer.pred</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Integer:ord">Enum_Integer.ord</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Integer:succ">Enum_Integer.succ</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Long:from">Enum_Long.from</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Long:_dot_dot">Enum_Long...</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Long:pred">Enum_Long.pred</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Long:ord">Enum_Long.ord</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Enum_Long:succ">Enum_Long.succ</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq__lpar_rpar:_div_eq">Eq_()./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq__lpar_rpar:_excl_eq">Eq_().!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq__lpar_rpar:_eq_eq">Eq_().==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Bool:_div_eq">Eq_Bool./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Bool:_excl_eq">Eq_Bool.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Bool:_eq_eq">Eq_Bool.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Char:_div_eq">Eq_Char./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Char:_excl_eq">Eq_Char.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Char:_eq_eq">Eq_Char.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Double:_div_eq">Eq_Double./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Double:_excl_eq">Eq_Double.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Double:_eq_eq">Eq_Double.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Float:_div_eq">Eq_Float./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Float:_excl_eq">Eq_Float.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Float:_eq_eq">Eq_Float.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Int:_div_eq">Eq_Int./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Int:_excl_eq">Eq_Int.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Int:_eq_eq">Eq_Int.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Long:_div_eq">Eq_Long./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Long:_excl_eq">Eq_Long.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_Long:_eq_eq">Eq_Long.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_String:_div_eq">Eq_String./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_String:_excl_eq">Eq_String.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq_String:_eq_eq">Eq_String.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq__lbrack_rbrack:_div_eq">Eq_[]./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq__lbrack_rbrack:_excl_eq">Eq_[].!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Eq__lbrack_rbrack:_eq_eq">Eq_[].==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Functor_Either:fmap">Functor_Either.fmap</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Functor_Maybe:fmap">Functor_Maybe.fmap</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntegerConvertable_Int:big">IntegerConvertable_Int.big</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntegerConvertable_Long:big">IntegerConvertable_Long.big</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Int:bshr">Integral_Int.bshr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Int:bor">Integral_Int.bor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Int:band">Integral_Int.band</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Int:bshl">Integral_Int.bshl</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Int:div">Integral_Int.div</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Int:bxor">Integral_Int.bxor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Int:rem">Integral_Int.rem</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Int:mod">Integral_Int.mod</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:bshl">Integral_Integer.bshl</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:_minus">Integral_Integer.-</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:_plus">Integral_Integer.+</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:_star">Integral_Integer.*</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:band">Integral_Integer.band</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:abs">Integral_Integer.abs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:bor">Integral_Integer.bor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:mod">Integral_Integer.mod</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:fromInt">Integral_Integer.fromInt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:bxor">Integral_Integer.bxor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:bshr">Integral_Integer.bshr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:div">Integral_Integer.div</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:isNaN">Integral_Integer.isNaN</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:isInfinite">Integral_Integer.isInfinite</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:isNumber">Integral_Integer.isNumber</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:sign">Integral_Integer.sign</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:one">Integral_Integer.one</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:negate">Integral_Integer.negate</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:rem">Integral_Integer.rem</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:subtract">Integral_Integer.subtract</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Integer:zero">Integral_Integer.zero</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Long:bshr">Integral_Long.bshr</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Long:bor">Integral_Long.bor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Long:band">Integral_Long.band</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Long:bshl">Integral_Long.bshl</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Long:div">Integral_Long.div</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Long:bxor">Integral_Long.bxor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Long:rem">Integral_Long.rem</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integral_Long:mod">Integral_Long.mod</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Length_String:length">Length_String.length</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Length__lbrack_rbrack:length">Length_[].length</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ListSource_Either:toList">ListSource_Either.toList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ListSource_Maybe:toList">ListSource_Maybe.toList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_Either:_gt_gt_eq">Monad_Either.&gt;&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_Either:_gt_gt">Monad_Either.&gt;&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_Either:_return">Monad_Either.return</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_Either:fail">Monad_Either.fail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_Maybe:_gt_gt_eq">Monad_Maybe.&gt;&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_Maybe:_gt_gt">Monad_Maybe.&gt;&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_Maybe:fail">Monad_Maybe.fail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_Maybe:_return">Monad_Maybe.return</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_ST:_gt_gt_eq">Monad_ST.&gt;&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_ST:_gt_gt">Monad_ST.&gt;&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_ST:fail">Monad_ST.fail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_ST:_return">Monad_ST.return</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_State:_gt_gt_eq">Monad_State.&gt;&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_State:_gt_gt">Monad_State.&gt;&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_State:fail">Monad_State.fail</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Monad_State:_return">Monad_State.return</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:isNaN">Num_Int.isNaN</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:_minus">Num_Int.-</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:_plus">Num_Int.+</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:_star">Num_Int.*</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:fromInt">Num_Int.fromInt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:abs">Num_Int.abs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:isInfinite">Num_Int.isInfinite</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:sign">Num_Int.sign</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:negate">Num_Int.negate</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:isNumber">Num_Int.isNumber</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:one">Num_Int.one</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:zero">Num_Int.zero</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Int:subtract">Num_Int.subtract</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:isNaN">Num_Long.isNaN</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:_minus">Num_Long.-</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:_plus">Num_Long.+</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:_star">Num_Long.*</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:fromInt">Num_Long.fromInt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:abs">Num_Long.abs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:isInfinite">Num_Long.isInfinite</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:sign">Num_Long.sign</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:negate">Num_Long.negate</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:isNumber">Num_Long.isNumber</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:one">Num_Long.one</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:zero">Num_Long.zero</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Num_Long:subtract">Num_Long.subtract</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Bool:_gt">Ord_Bool.&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Bool:_lt_eq">Ord_Bool.&lt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Bool:_lt">Ord_Bool.&lt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Bool:_lt_eq_gt">Ord_Bool.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Bool:compare">Ord_Bool.compare</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Bool:_gt_eq">Ord_Bool.&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Bool:max">Ord_Bool.max</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Bool:min">Ord_Bool.min</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Char:_gt">Ord_Char.&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Char:_lt_eq">Ord_Char.&lt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Char:_lt">Ord_Char.&lt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Char:_lt_eq_gt">Ord_Char.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Char:compare">Ord_Char.compare</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Char:_gt_eq">Ord_Char.&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Char:max">Ord_Char.max</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Char:min">Ord_Char.min</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Double:_gt">Ord_Double.&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Double:_lt_eq">Ord_Double.&lt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Double:_lt">Ord_Double.&lt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Double:_lt_eq_gt">Ord_Double.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Double:compare">Ord_Double.compare</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Double:_gt_eq">Ord_Double.&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Double:max">Ord_Double.max</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Double:min">Ord_Double.min</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Float:_gt">Ord_Float.&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Float:_lt_eq">Ord_Float.&lt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Float:_lt">Ord_Float.&lt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Float:_lt_eq_gt">Ord_Float.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Float:compare">Ord_Float.compare</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Float:_gt_eq">Ord_Float.&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Float:max">Ord_Float.max</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Float:min">Ord_Float.min</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Int:_gt">Ord_Int.&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Int:_lt_eq">Ord_Int.&lt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Int:_lt">Ord_Int.&lt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Int:_lt_eq_gt">Ord_Int.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Int:compare">Ord_Int.compare</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Int:_gt_eq">Ord_Int.&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Int:max">Ord_Int.max</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Int:min">Ord_Int.min</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:_gt">Ord_Integer.&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:_lt">Ord_Integer.&lt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:_excl_eq">Ord_Integer.!=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:_div_eq">Ord_Integer./=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:_lt_eq_gt">Ord_Integer.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:_lt_eq">Ord_Integer.&lt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:_eq_eq">Ord_Integer.==</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:compare">Ord_Integer.compare</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:_gt_eq">Ord_Integer.&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:max">Ord_Integer.max</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Integer:min">Ord_Integer.min</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Long:_gt">Ord_Long.&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Long:_lt_eq">Ord_Long.&lt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Long:_lt">Ord_Long.&lt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Long:_lt_eq_gt">Ord_Long.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Long:compare">Ord_Long.compare</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Long:_gt_eq">Ord_Long.&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Long:max">Ord_Long.max</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_Long:min">Ord_Long.min</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_String:_gt">Ord_String.&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_String:_lt_eq">Ord_String.&lt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_String:_lt">Ord_String.&lt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_String:_lt_eq_gt">Ord_String.&lt;=&gt;</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_String:compare">Ord_String.compare</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_String:_gt_eq">Ord_String.&gt;=</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_String:max">Ord_String.max</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ord_String:min">Ord_String.min</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:isNaN">Real_Double.isNaN</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:_div">Real_Double./</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:_plus">Real_Double.+</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:_star">Real_Double.*</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:_minus">Real_Double.-</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:fromInt">Real_Double.fromInt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:abs">Real_Double.abs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:isInfinite">Real_Double.isInfinite</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:sign">Real_Double.sign</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:negate">Real_Double.negate</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:isNumber">Real_Double.isNumber</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:one">Real_Double.one</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:zero">Real_Double.zero</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Double:subtract">Real_Double.subtract</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:isNaN">Real_Float.isNaN</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:_div">Real_Float./</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:_plus">Real_Float.+</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:_star">Real_Float.*</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:_minus">Real_Float.-</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:fromInt">Real_Float.fromInt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:abs">Real_Float.abs</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:isInfinite">Real_Float.isInfinite</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:sign">Real_Float.sign</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:negate">Real_Float.negate</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:isNumber">Real_Float.isNumber</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:one">Real_Float.one</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:zero">Real_Float.zero</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Real_Float:subtract">Real_Float.subtract</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Unit:Unit">().()</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple2:Tuple2">(,).(,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple3:Tuple3">(,,).(,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple4:Tuple4">(,,,).(,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple5:Tuple5">(,,,,).(,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple6:Tuple6">(,,,,,).(,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple7:Tuple7">(,,,,,,).(,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple8:Tuple8">(,,,,,,,).(,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple9:Tuple9">(,,,,,,,,).(,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple10:Tuple10">(,,,,,,,,,).(,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple11:Tuple11">(,,,,,,,,,,).(,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple12:Tuple12">(,,,,,,,,,,,).(,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple13:Tuple13">(,,,,,,,,,,,,).(,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple14:Tuple14">(,,,,,,,,,,,,,).(,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple15:Tuple15">(,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple16:Tuple16">(,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple17:Tuple17">(,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple18:Tuple18">(,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple19:Tuple19">(,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple20:Tuple20">(,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple21:Tuple21">(,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple22:Tuple22">(,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple23:Tuple23">(,,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple24:Tuple24">(,,,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple25:Tuple25">(,,,,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Tuple26:Tuple26">(,,,,,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,,,,,)</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Char:isUpperCase">Char.isUpperCase</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Char:isLowerCase">Char.isLowerCase</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Char:isWhitespace">Char.isWhitespace</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Class:getName">Class.getName</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Class:forName">Class.forName</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Double:floor">Double.floor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Double:_float">Double.float</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Double:_long">Double.long</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Either:Left">Either.Left</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Either:Right">Either.Right</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Float:_double">Float.double</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Float:_int">Float.int</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Float:floor">Float.floor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Immutable:Immutable">Immutable.Immutable</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Int:_double">Int.double</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Int:_char">Int.char</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Int:_long">Int.long</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Int:_float">Int.float</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Int:toHexString">Int.toHexString</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:getAt">IntArray.getAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:fromList">IntArray.fromList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:fromInxList">IntArray.fromInxList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:elemAt">IntArray.elemAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:fromInxListST">IntArray.fromInxListST</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:frozenGetAt">IntArray.frozenGetAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:fromListST">IntArray.fromListST</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:setAt">IntArray.setAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:_new">IntArray.new</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:length">IntArray.length</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#IntArray:toList">IntArray.toList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integer:compareTo">Integer.compareTo</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integer:bitLength">Integer.bitLength</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integer:_long">Integer.long</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integer:_int">Integer.int</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integer:nMod">Integer.nMod</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integer:ten">Integer.ten</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integer:valueOf">Integer.valueOf</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Integer:toString">Integer.toString</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#JException:getClass">JException.getClass</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#JException:catched">JException.catched</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#JException:getLocalizedMessage">JException.getLocalizedMessage</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#JException:getMessage">JException.getMessage</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Long:_float">Long.float</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Long:_double">Long.double</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Long:_int">Long.int</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:replaceAll">Matcher.replaceAll</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:find">Matcher.find</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:clone">Matcher.clone</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:end">Matcher.end</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:match">Matcher.match</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:group">Matcher.group</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:matches">Matcher.matches</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:useAnchoringBounds">Matcher.useAnchoringBounds</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:start">Matcher.start</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:replaceFirst">Matcher.replaceFirst</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:toString">Matcher.toString</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:usePattern">Matcher.usePattern</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Matcher:usePatternAndFind">Matcher.usePatternAndFind</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Maybe:Just">Maybe.Just</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Maybe:Nothing">Maybe.Nothing</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ordering:Gt">Ordering.Gt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ordering:Eq">Ordering.Eq</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Ordering:Lt">Ordering.Lt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#RealWorld:RealWorld">RealWorld.RealWorld</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Regex:pattern">Regex.pattern</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Regex:matcher">Regex.matcher</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Regex:split">Regex.split</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Regex:splitted">Regex.splitted</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ST:bind">ST.bind</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ST:ST">ST.ST</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ST:performUnsafe">ST.performUnsafe</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ST:run">ST.run</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:getAt">STArray.getAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:fromList">STArray.fromList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:fromInxList">STArray.fromInxList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:elemAt">STArray.elemAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:fromInxListST">STArray.fromInxListST</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:frozenElemAt">STArray.frozenElemAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:fromListST">STArray.fromListST</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:frozenGetAt">STArray.frozenGetAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:setAtMB">STArray.setAtMB</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:_new">STArray.new</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:length">STArray.length</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:setAt">STArray.setAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:toInxList">STArray.toInxList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STArray:toList">STArray.toList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STRef:_new">STRef.new</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STRef:get">STRef.get</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#STRef:put">STRef.put</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#State:get">State.get</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#State:bind">State.bind</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#State:State">State.State</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#State:change">State.change</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#State:put">State.put</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#State:run">State.run</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:compareTo">String.compareTo</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:atod">String.atod</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:aton">String.aton</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:atoi">String.atoi</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:atof">String.atof</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:atol">String.atol</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:charAt">String.charAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:integer">String.integer</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:_float">String.float</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:_double">String.double</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:compile">String.compile</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:elemAt">String.elemAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:hashCode">String.hashCode</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:frozenGetAt">String.frozenGetAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:_int">String.int</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:quote">String.quote</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:_long">String.long</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:toLowerCase">String.toLowerCase</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:quoteReplacement">String.quoteReplacement</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#String:toUpperCase">String.toUpperCase</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#StringArray:frozenGetAt">StringArray.frozenGetAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#StringArray:fromList">StringArray.fromList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#StringArray:elemAt">StringArray.elemAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#StringArray:fromListST">StringArray.fromListST</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#StringArray:_new">StringArray.new</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#StringArray:getAt">StringArray.getAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#StringArray:length">StringArray.length</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#StringArray:setAt">StringArray.setAt</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#StringArray:toList">StringArray.toList</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Undefined:_new">Undefined.new</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Undefined:die">Undefined.die</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Undefined:newX">Undefined.newX</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Undefined:newSX">Undefined.newSX</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#Undefined:toException">Undefined.toException</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#List:Cons">[].:</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#List:List">[].[]</A></DIV>
</LI>
</UL>
<H3>
Imports</H3>
<UL>
</UL>
<H2>
<A name="type">Type Aliases</A></H2>
<DL class="clas">
<DT class="clas">
<SPAN CLASS="code"><B>type </B><A name="Array">Array</A> elem = <A class="tref" href="#STArray">STArray</A> elem <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="clas">
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>type </B><A name="Exception">Exception</A> a = <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> a</SPAN></DT>
<DD class="clas">
<P>
This is the principal return type for java methods that are expected to throw exceptions.</P>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>type </B><A name="Frozen">Frozen</A> n = n <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="clas">
<P>
<SPAN CLASS="code">Frozen MyType</SPAN> is an abbrevation for <SPAN CLASS="code">MyType Immutable</SPAN></P>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>type </B><A name="IO">IO</A>  = <A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A></SPAN></DT>
<DD class="clas">
<P>
<SPAN CLASS="code">IO a</SPAN> is an abbrevation for <A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A> <SPAN CLASS="code">a</SPAN></P>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>type </B><A name="IORef">IORef</A> a = <A class="tref" href="#STRef">STRef</A> a <A class="tref" href="#RealWorld">RealWorld</A></SPAN></DT>
<DD class="clas">
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>type </B><A name="IntArr">IntArr</A>  = <A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="clas">
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>type </B><A name="Mutable">Mutable</A> n s = <A class="tref" href="#ST">ST</A> s (n s)</SPAN></DT>
<DD class="clas">
<P>
<SPAN CLASS="code">Mutable MyType s</SPAN> is an abbrevation for <A class="tref" href="#ST">ST</A> <SPAN CLASS="code">s (MyType s)</SPAN></P>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>type </B><A name="StringArr">StringArr</A>  = <A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="clas">
</DD>
</DL>
<H2>
<A name="class">Classes</A></H2>
<DL class="clas">
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="AbstractList">AbstractList</A> (<A class="tref" href="#Empty">Empty</A> this, <A class="tref" href="#Length">Length</A> this) =&gt;  this</SPAN></DT>
<DD class="clas">
<P>
A class for data types that behave like lists.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#AbstractList_String">String</A>, <A class="tref" href="#AbstractList__lbrack_rbrack">[]</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="AbstractList:_plus_plus">++</A> :: <B>forall</B> this.<A class="tref" href="#AbstractList">AbstractList</A> this =&gt; this -&gt; this -&gt; this</SPAN></DT>
<DD class="func">
<P>
concatenate two lists, strings or whatever</P>
<PRE>
 empty ++ x == x &amp;&amp; x ++ empty == x</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="AbstractList:tail">tail</A> :: <B>forall</B> this.<A class="tref" href="#AbstractList">AbstractList</A> this =&gt; this -&gt; this</SPAN></DT>
<DD class="func">
<P>
Get the tail elements. This is <A class="fref" href="#undefined">undefined</A> if the list is empty.</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Bounded">Bounded</A>  b</SPAN></DT>
<DD class="clas">
<P>
A class for data types that have a lower and an upper bound.</P>
<P>
Instances of <A class="tref" href="#Bounded">Bounded</A> can be derived automatically for enumeration types.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Bounded_Long">Long</A>, <A class="tref" href="#Bounded_Char">Char</A>, <A class="tref" href="#Bounded_Bool">Bool</A>, <A class="tref" href="#Bounded_Int">Int</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Bounded:maxBound">maxBound</A> :: <B>forall</B> b.<A class="tref" href="#Bounded">Bounded</A> b =&gt; b</SPAN></DT>
<DD class="func">
<P>
the upper bound</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Bounded:minBound">minBound</A> :: <B>forall</B> b.<A class="tref" href="#Bounded">Bounded</A> b =&gt; b</SPAN></DT>
<DD class="func">
<P>
the lower bound</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Cloneable">Cloneable</A> <A class="tref" href="#Freezable">Freezable</A> f =&gt;  f</SPAN></DT>
<DD class="clas">
<P>
For a data type declared like</P>
<PRE>
 data D s = native Javatype</PRE>
<P>
where <SPAN CLASS="code">Javatype</SPAN> implements the <SPAN CLASS="code">java.lang.Cloneable</SPAN> interface, one can get implementations for <A class="fref" href="#Freezable:freeze">Freezable.freeze</A> and <A class="fref" href="#Freezable:thaw">Freezable.thaw</A> by just stating</P>
<PRE>
 instance Cloneable D</PRE>
<P>
The <A class="fref" href="#Freezable:freeze">Freezable.freeze</A> and <A class="fref" href="#Freezable:thaw">Freezable.thaw</A> operations are implemented in terms of <A class="fref" href="#Cloneable:clone">Cloneable.clone</A>.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Cloneable_StringArray">StringArray</A>, <A class="tref" href="#Cloneable_IntArray">IntArray</A>, <A class="tref" href="#Cloneable_STArray">STArray</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable:clone">clone</A> :: <B>forall</B> b a f.<A class="tref" href="#Cloneable">Cloneable</A> f =&gt; <B>f a</B> -&gt; f b&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>clone</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">clone v</SPAN> must be a native method that works like <SPAN CLASS="code">java.lang.Object#clone</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable:freeze">freeze</A> :: <B>forall</B> f s.<A class="tref" href="#Cloneable">Cloneable</A> f =&gt; <B>f s</B> -&gt; <A class="tref" href="#ST">ST</A> s (f <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable:thaw">thaw</A> :: <B>forall</B> f s.<A class="tref" href="#Cloneable">Cloneable</A> f =&gt; <B>f <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#ST">ST</A> s (f s)</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Empty">Empty</A>  this</SPAN></DT>
<DD class="clas">
<P>
A class for data types that have a notion of emptieness.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Empty_String">String</A>, <A class="tref" href="#Empty__lbrack_rbrack">[]</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Empty:empty">empty</A> :: <B>forall</B> this.<A class="tref" href="#Empty">Empty</A> this =&gt; this</SPAN></DT>
<DD class="func">
<P>
create an empty thing</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Empty:_null">null</A> :: <B>forall</B> this.<A class="tref" href="#Empty">Empty</A> this =&gt; this -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
check for empty thing</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Enum">Enum</A> (<A class="tref" href="#Eq">Eq</A> e, <A class="tref" href="#Ord">Ord</A> e) =&gt;  e</SPAN></DT>
<DD class="clas">
<P>
Class <A class="tref" href="#Enum">Enum</A> defines operations on sequentially ordered types.</P>
<P>
A type that is an instance of <A class="tref" href="#Enum">Enum</A> is also an instance of <A class="tref" href="#Ord">Ord</A> (and, in turn, of <A class="tref" href="#Eq">Eq</A>).</P>
<P>
Instances of <A class="tref" href="#Enum">Enum</A> may be derived for any enumeration type *(types whose constructors have no fields).</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Enum_Long">Long</A>, <A class="tref" href="#Enum_Integer">Integer</A>, <A class="tref" href="#Enum_Char">Char</A>, <A class="tref" href="#Enum_Bool">Bool</A>, <A class="tref" href="#Enum_Int">Int</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Enum:_dot_dot">..</A> :: <B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; e -&gt; e -&gt; [e]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">a .. b</SPAN> is the list <SPAN CLASS="code">[a, succ a, succ (succ a), ..., b ]</SPAN> if <SPAN CLASS="code">a &lt; b</SPAN>, or [a] if <SPAN CLASS="code">a == b</SPAN> or the empty list if <SPAN CLASS="code">a &gt; b</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum:_lt_eq_gt">&lt;=&gt;</A> :: <B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; e -&gt; e -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
This is the default implementation of the compare operator, that makes each <A class="tref" href="#Enum">Enum</A> type an <A class="tref" href="#Ord">Ord</A> type automatically.</P>
<PRE>
 a &lt;=&gt; b  =  ord a  Int.&lt;=&gt;  ord b</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum:from">from</A> :: <B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; <A class="tref" href="#Int">Int</A> -&gt; e</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">T.from i</SPAN> maps the <A class="tref" href="#Int">Int</A> value <SPAN CLASS="code">i</SPAN> to a value of <SPAN CLASS="code">T</SPAN>, such that</P>
<PRE>
   ord (T.from i) == i</PRE>
<P>
unless there is no value <SPAN CLASS="code">e</SPAN> of <SPAN CLASS="code">T</SPAN> so that <SPAN CLASS="code">ord e == i</SPAN>. In the latter case, the result is <A class="fref" href="#undefined">undefined</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum:ord">ord</A> :: <B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; e -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">ord e</SPAN> returns the ordinal number associated with the value <SPAN CLASS="code">e</SPAN>. For enumeration types, <A class="fref" href="#Enum:ord">Enum.ord</A> is the same as <A class="fref" href="#constructor">constructor</A>, for <A class="tref" href="#Int">Int</A>, it is the identity function. Some types, like <A class="tref" href="#Long">Long</A>, cannot map all their values to <A class="tref" href="#Int">Int</A>, in such cases the result of applying <A class="fref" href="#Enum:ord">Enum.ord</A> may be meaningless.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum:pred">pred</A> :: <B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; e -&gt; e</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">pred e</SPAN> is the predecessor of <SPAN CLASS="code">e</SPAN> or <A class="fref" href="#undefined">undefined</A> if there is no predecessor.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum:succ">succ</A> :: <B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; e -&gt; e</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">succ e</SPAN> is the successor of <SPAN CLASS="code">e</SPAN> or <A class="fref" href="#undefined">undefined</A> if there is no such successor.</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Eq">Eq</A>  eq</SPAN></DT>
<DD class="clas">
<UL>
<LI>
---------------------------------------------------------------------------- </LI>
<LI>
---------------------------------------------------------------------------- </LI>
</UL>
<P>
The class <A class="tref" href="#Eq">Eq</A> provides operators <A class="fref" href="#Eq:_eq_eq">Eq.==</A> and <A class="fref" href="#Eq:_excl_eq">Eq.!=</A>. All types whose values can be compared for equality should be instances of this class. For algebraic data types instances can be automatically derived if all components are themselves instances of <A class="tref" href="#Eq">Eq</A>.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Ord_Integer">Integer</A>, <A class="tref" href="#Eq_String">String</A>, <A class="tref" href="#Eq__lbrack_rbrack">[]</A>, <A class="tref" href="#Eq_Int">Int</A>, <A class="tref" href="#Eq_Double">Double</A>, <A class="tref" href="#Eq_Float">Float</A>, <A class="tref" href="#Eq__lpar_rpar">()</A>, <A class="tref" href="#Eq_Bool">Bool</A>, <A class="tref" href="#Eq_Char">Char</A>, <A class="tref" href="#Eq_Long">Long</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq:_excl_eq">!=</A> :: <B>forall</B> eq.<A class="tref" href="#Eq">Eq</A> eq =&gt; eq -&gt; eq -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Check for inequality. The default implementation obeys the laws</P>
<PRE>
 !(a != a)</PRE>
<PRE>
 (a != b) == !(a == b)</PRE>
<PRE>
 (a == b) != (a != b)</PRE>
<P>
These laws shall also be obeyed in all implementations.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq:_div_eq">/=</A> :: <B>forall</B> eq.<A class="tref" href="#Eq">Eq</A> eq =&gt; eq -&gt; eq -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
provided for Haskell compatibility as an alias for <A class="fref" href="#Eq:_excl_eq">Eq.!=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq:_eq_eq">==</A> :: <B>forall</B> eq.<A class="tref" href="#Eq">Eq</A> eq =&gt; eq -&gt; eq -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Check for equality. This function is required in all instances.</P>
<P>
Ayn Rand's favorite law</P>
<PRE>
 a == a</PRE>
<P>
shall be obeyed by all implementations.</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Freezable">Freezable</A>  f</SPAN></DT>
<DD class="clas">
<P>
Type class for native values that may be used in a functional way. The <A class="fref" href="#Freezable:freeze">Freezable.freeze</A> operation is a <A class="tref" href="#ST">ST</A> action, but yields a result that can be returned from a ST thread.</P>
<P>
To be implemented with care.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Cloneable_StringArray">StringArray</A>, <A class="tref" href="#Cloneable_IntArray">IntArray</A>, <A class="tref" href="#Cloneable_STArray">STArray</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Freezable:freeze">freeze</A> :: <B>forall</B> f s.<A class="tref" href="#Freezable">Freezable</A> f =&gt; f s -&gt; <A class="tref" href="#ST">ST</A> s (f <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
"Freeze" a mutable native value. The result is supposed to be immutable or at least not reachable from other parts of the code, especially from java code.</P>
<P>
The most prominent way to freeze a value is by <A class="fref" href="#Cloneable:clone">Cloneable.clone</A>-ing it, if that is supported.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Freezable:our">our</A> :: <B>forall</B> f s.<A class="tref" href="#Freezable">Freezable</A> f =&gt; f s -&gt; <A class="tref" href="#ST">ST</A> s (f <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<DL>
<DT>
Usage</DT>
<DD>
<DIV>
 <SPAN CLASS="code">our v</SPAN> as last action in a <B>do</B> block that created mutable native value <SPAN CLASS="code">v</SPAN> </DIV>
</DD>
<DT>
Purpose</DT>
<DD>
<DIV>
 Make a value that is identical to <SPAN CLASS="code">v</SPAN> but has <A class="tref" href="#Immutable">Immutable</A> as phantom type. This allows escape of mutable native values from <A class="tref" href="#ST">ST</A> actions. Yet, because these values are tagged <A class="tref" href="#Immutable">Immutable</A>, unsafe operations are impossible outside the <A class="tref" href="#ST">ST</A> monad as long as all impure native functions are correctly defined. One can pass the value to another <A class="tref" href="#ST">ST</A> action, which may <A class="fref" href="#Freezable:thaw">Freezable.thaw</A> it and apply impure native functions again.</DIV>
</DD>
<DT>
Returns</DT>
<DD>
<DIV>
 a copy of <SPAN CLASS="code">v</SPAN> tagged as <A class="tref" href="#Immutable">Immutable</A> in the <A class="tref" href="#ST">ST</A> monad </DIV>
</DD>
</DL>
<P>
This is intended for cases where we want to keep the native value and we know that there are no references to the native value other than the ones maintained in the current <A class="tref" href="#ST">ST</A> action. In those not so rare cases, it would be overkill to obtain a copy of a value by cloning it or serializing/deserializing it. Hence, an implementation of <A class="fref" href="#Freezable:our">Freezable.our</A> is allowed to cheat a bit and return just <SPAN CLASS="code">this</SPAN>.</P>
<P>
The safety of <A class="tref" href="#Freezable">Freezable</A> operations is something the compiler cannot infer. It lies entirely in the responsibility of the programmer to ensure safety. Remember that violation of the informal contract of <A class="tref" href="#Freezable">Freezable</A> (see below) will be rewarded with exceptions thrown at runtime or with inexplicable, perhaps nondeterministic behaviour of the program.</P>
<P>
An example where <A class="fref" href="#Freezable:our">Freezable.our</A> is employed is creation and initialization of arrays, as in <A class="fref" href="#IntArray:fromList">IntArray.fromList</A>. When the array is completely initialized, it is safe to let it escape as a read only value because no further write accesses are possible (unless one manages to pass the array to an impure function.)</P>
<P>
This is the informal contract of <A class="tref" href="#Freezable">Freezable</A> and its operations. It is designed so that the type system will detect unsafe usage of mutable native values. The programmer should understand that such type errors are a strong signal to go back and rethink the code. Inventing "clever" workarounds in the form of creatively typed native functions or so is like loading a shotgun that points to ones foot.</P>
<UL>
<LI>
 All mutable native data types have a frege type with a phantom type as its last type argument. (i.e. <SPAN CLASS="code">data Date s = native java.util.Date</SPAN>)</LI>
<LI>
 All impure functions have the same type variable (say <SPAN CLASS="code">s</SPAN>) for the phantom type of mutable types that appear in their type and have a result of <A class="tref" href="#ST">ST</A> <SPAN CLASS="code">s</SPAN> <I>a</I>.</LI>
<LI>
 All object creation functions have a return type of <SPAN CLASS="code">ST s (M s)</SPAN> or <SPAN CLASS="code">Mutable M s</SPAN> where <SPAN CLASS="code">M</SPAN> is the type constructor of the native values frege type.</LI>
<LI>
 If the function relies on global state, alters global state or performs input or output, the return type must be <A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A> <I>a</I>. Consequently, all mutable types that appear in the type signature must have <A class="tref" href="#RealWorld">RealWorld</A> as phantom type.</LI>
<LI>
 In pure functions, the mutable data types <B>must</B> appear as <SPAN CLASS="code">M Immutable</SPAN>. The return type is an ordinary type (no <A class="tref" href="#ST">ST</A> type).</LI>
<LI>
 If the type is an instance of <A class="tref" href="#Freezable">Freezable</A>, then the implmentations of <A class="fref" href="#Freezable:freeze">Freezable.freeze</A> and  <A class="fref" href="#Freezable:thaw">Freezable.thaw</A> create fresh objects. This is true for instances of <A class="tref" href="#Cloneable">Cloneable</A> and <A class="tref" href="#Serializable">Serializable</A> that use the default type class methods (i.e., do not supply own implementations).</LI>
<LI>
 <A class="fref" href="#Freezable:our">Freezable.our</A> is used only when there are no alien references to the value <B>or</B> if a fresh object is created.</LI>
</UL>
<P>
The default implementation does the same as <A class="fref" href="#Freezable:freeze">Freezable.freeze</A>. A generic native method to implement a low cost <A class="fref" href="#Freezable:our">Freezable.our</A> is provided in the runtime as <SPAN CLASS="code">frege.RT.our</SPAN>. It just returns its argument.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Freezable:thaw">thaw</A> :: <B>forall</B> f s.<A class="tref" href="#Freezable">Freezable</A> f =&gt; f <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#ST">ST</A> s (f s)</SPAN></DT>
<DD class="func">
<P>
The inverse of <A class="fref" href="#Freezable:freeze">Freezable.freeze</A> creates a value (an object) which can be passed to impure functions without compromising the frozen object passed as argument.</P>
<P>
One possibility to thaw an object properly is by cloning it.</P>
<P>
If <A class="fref" href="#Freezable:thaw">Freezable.thaw</A> is not implemented correctly, bad things may happen.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Freezable:withFrozen">withFrozen</A> :: <B>forall</B> f s a.<A class="tref" href="#Freezable">Freezable</A> f =&gt; f s -&gt; (f <A class="tref" href="#Immutable">Immutable</A>-&gt;a) -&gt; <A class="tref" href="#ST">ST</A> s a</SPAN></DT>
<DD class="func">
<DL>
<DT>
Usage</DT>
<DD>
<DIV>
 <SPAN CLASS="code">withFrozen v f</SPAN> where <SPAN CLASS="code">v</SPAN> is a mutable native value. </DIV>
</DD>
<DT>
Purpose</DT>
<DD>
<DIV>
 Temporarily freeze <SPAN CLASS="code">v</SPAN> and pass it to a pure function <SPAN CLASS="code">f</SPAN>. </DIV>
</DD>
<DT>
Return</DT>
<DD>
<DIV>
 the result of <SPAN CLASS="code">f v</SPAN> in the <A class="tref" href="#ST">ST</A> monad. </DIV>
</DD>
<DT>
Requirements</DT>
<DD>
<DIV>
 <SPAN CLASS="code">f</SPAN> must not fork parallel computations that could access <SPAN CLASS="code">v</SPAN> after <SPAN CLASS="code">f</SPAN> has returned.</DIV>
</DD>
</DL>
<P>
This function is needed to synchronize pure computations on a native value with manipulations of that same value inside <A class="tref" href="#ST">ST</A> actions. Consider the following code:</P>
<PRE>
 do
    arr &lt;- IntArray.new 100
    arr.[42 &lt;- 1]
    let result = arr.elemAt 42   // actually a type error
    arr.[42 &lt;- 2]
    return result</PRE>
<P>
The placement of the <SPAN CLASS="code">let</SPAN> does not guarantee that <SPAN CLASS="code">result</SPAN> will be evaluated between the assignments to cell 42 of the array. To the contrary, the read access to the array will most probably not occur before the result of the state action is evaluated. Therefore, such constructs are forbidden through the type of <A class="fref" href="#IntArray:elemAt">IntArray.elemAt</A> which requires a frozen array.</P>
<P>
The <SPAN CLASS="code">let</SPAN> must be replaced by</P>
<PRE>
    result &lt;- withFrozen arr (flip IntArray.elemAt 42)</PRE>
<P>
to sequence evaluation before the next write access to the array.</P>
<P>
Because <A class="fref" href="#Freezable:withFrozen">Freezable.withFrozen</A> employs <A class="fref" href="#Freezable:our">Freezable.our</A> it can be as easily misused. In fact <SPAN CLASS="code">withFrozen v id</SPAN> is identical to <SPAN CLASS="code">our v</SPAN>.</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Functor">Functor</A>  f</SPAN></DT>
<DD class="clas">
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Functor_Either">Either</A>, <A class="tref" href="#Functor_Maybe">Maybe</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Functor:fmap">fmap</A> :: <B>forall</B> b a f.<A class="tref" href="#Functor">Functor</A> f =&gt; (a-&gt;b) -&gt; f a -&gt; f b</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="IntegerConvertable">IntegerConvertable</A>  this</SPAN></DT>
<DD class="clas">
<P>
Types that can be converted to <A class="tref" href="#Integer">Integer</A></P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#IntegerConvertable_Long">Long</A>, <A class="tref" href="#IntegerConvertable_Int">Int</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="IntegerConvertable:big">big</A> :: <B>forall</B> this.<A class="tref" href="#IntegerConvertable">IntegerConvertable</A> this =&gt; this -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
returns an <A class="tref" href="#Integer">Integer</A> with the same value as the argument</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Integral">Integral</A> (<A class="tref" href="#Eq">Eq</A> integ, <A class="tref" href="#Ord">Ord</A> integ, <A class="tref" href="#Num">Num</A> integ) =&gt;  integ</SPAN></DT>
<DD class="clas">
<P>
Class <A class="tref" href="#Integral">Integral</A> provides bit arithmetic, division and remainder operations for integral numbers.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Integral_Long">Long</A>, <A class="tref" href="#Integral_Int">Int</A>, <A class="tref" href="#Integral_Integer">Integer</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Integral:band">band</A> :: <B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; integ -&gt; integ</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral:bor">bor</A> :: <B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; integ -&gt; integ</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral:bshl">bshl</A> :: <B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; <A class="tref" href="#Int">Int</A> -&gt; integ</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral:bshr">bshr</A> :: <B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; <A class="tref" href="#Int">Int</A> -&gt; integ</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral:bxor">bxor</A> :: <B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; integ -&gt; integ</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral:div">div</A> :: <B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; integ -&gt; integ</SPAN></DT>
<DD class="func">
<P>
integer division</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral:mod">mod</A> :: <B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; integ -&gt; integ</SPAN></DT>
<DD class="func">
<P>
This modulo operator works like <SPAN CLASS="code">java.math.BigInteger.mod</SPAN></P>
<PRE>
 (-5) `mod` 3 == 1</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral:rem">rem</A> :: <B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; integ -&gt; integ</SPAN></DT>
<DD class="func">
<P>
The remainder á la Java operator <SPAN CLASS="code">%</SPAN> - <SPAN CLASS="code">a `rem` b</SPAN> has same sign as <SPAN CLASS="code">a</SPAN></P>
<P>
Property: <SPAN CLASS="code">(a `div` b) * b + (a `rem` b) = a</SPAN></P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Length">Length</A>  this</SPAN></DT>
<DD class="clas">
<P>
A class for data types that have a notion of length.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Length__lbrack_rbrack">[]</A>, <A class="tref" href="#Length_String">String</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Length:length">length</A> :: <B>forall</B> this.<A class="tref" href="#Length">Length</A> this =&gt; this -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
computes the length of a value in a type dependend way</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="ListSource">ListSource</A>  t</SPAN></DT>
<DD class="clas">
<P>
A class for things we can make a list from</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#ListSource_Either">Either</A>, <A class="tref" href="#ListSource_Maybe">Maybe</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="ListSource:toList">toList</A> :: <B>forall</B> t e.<A class="tref" href="#ListSource">ListSource</A> t =&gt; t e -&gt; [e]</SPAN></DT>
<DD class="func">
<P>
converts the value to a list</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Monad">Monad</A>  m</SPAN></DT>
<DD class="clas">
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Monad_ST">ST</A>, <A class="tref" href="#Monad_State">State</A>, <A class="tref" href="#Monad_Either">Either</A>, <A class="tref" href="#Monad_Maybe">Maybe</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Monad:_gt_gt">&gt;&gt;</A> :: <B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; m a -&gt; m b -&gt; m b</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad:_gt_gt_eq">&gt;&gt;=</A> :: <B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; m a -&gt; (a-&gt;m b) -&gt; m b</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad:fail">fail</A> :: <B>forall</B> m a.<A class="tref" href="#Monad">Monad</A> m =&gt; <B><A class="tref" href="#String">String</A></B> -&gt; m a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad:_return">return</A> :: <B>forall</B> m a.<A class="tref" href="#Monad">Monad</A> m =&gt; a -&gt; m a</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Num">Num</A> (<A class="tref" href="#Eq">Eq</A> n, <A class="tref" href="#Ord">Ord</A> n) =&gt;  n</SPAN></DT>
<DD class="clas">
<P>
The <A class="tref" href="#Num">Num</A> class provides the operators (<A class="fref" href="#Num:_plus">Num.+</A>), (<A class="fref" href="#Num:_minus">Num.-</A>) and (<A class="fref" href="#Num:_star">Num.*</A>) as well as some functions that are common for all numeric types.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Integral_Integer">Integer</A>, <A class="tref" href="#Real_Double">Double</A>, <A class="tref" href="#Real_Float">Float</A>, <A class="tref" href="#Num_Long">Long</A>, <A class="tref" href="#Num_Int">Int</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Num:_star">*</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; n -&gt; n</SPAN></DT>
<DD class="func">
<P>
Computes the product of two numbers</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:_plus">+</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; n -&gt; n</SPAN></DT>
<DD class="func">
<P>
Computes the sum of two numbers</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:_minus">-</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; n -&gt; n</SPAN></DT>
<DD class="func">
<P>
Computes the difference of two numbers</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:abs">abs</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; n</SPAN></DT>
<DD class="func">
<P>
Computes the absolute value</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:fromInt">fromInt</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; <A class="tref" href="#Int">Int</A> -&gt; n</SPAN></DT>
<DD class="func">
<P>
converts an <A class="tref" href="#Int">Int</A> value to the instantiated type</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:isInfinite">isInfinite</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Floating point number types may have special values for <I>infinity</I> and <I>negative infinity</I>. <SPAN CLASS="code">isFinite n</SPAN> yields <SPAN CLASS="code">true</SPAN> if <SPAN CLASS="code">n</SPAN> is an infinite value and <SPAN CLASS="code">false</SPAN> in all other cases.</P>
<P>
The default implementation always returns <SPAN CLASS="code">false</SPAN> so that implementors of instances for types without special values for infinity need not care.</P>
<P>
See also <A class="fref" href="#Num:isNumber">Num.isNumber</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:isNaN">isNaN</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Floating point number types may have a special values for <I>not a number</I> (NaN). For example, <SPAN CLASS="code">0d / 0d</SPAN> is NaN. <SPAN CLASS="code">isNaN n</SPAN> yields <SPAN CLASS="code">true</SPAN> if <SPAN CLASS="code">n</SPAN> is the special value that indicates that <SPAN CLASS="code">n</SPAN> is not a number and <SPAN CLASS="code">false</SPAN> in all other cases.</P>
<P>
The default implementation always returns <SPAN CLASS="code">false</SPAN> so that implementors of instances for types without such a special values need not care.</P>
<P>
See also <A class="fref" href="#Num:isNumber">Num.isNumber</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:isNumber">isNumber</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Returns <SPAN CLASS="code">true</SPAN> if <SPAN CLASS="code">n</SPAN> is neither infinite (see <A class="fref" href="#Num:isInfinite">Num.isInfinite</A>) nor NaN (see <A class="fref" href="#Num:isNaN">Num.isNaN</A>).</P>
<P>
Note that certain properties for funtions on numbers are true only under the assumption that the argument values are numbers.</P>
<P>
The default implementation is</P>
<PRE>
 isNumber n = !(isInfinite n) &amp;&amp; !(isNaN n)</PRE>
<P>
so that the function should always compute the right answer as long as <A class="fref" href="#Num:isInfinite">Num.isInfinite</A> and <A class="fref" href="#Num:isNaN">Num.isNaN</A> do.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:negate">negate</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; n</SPAN></DT>
<DD class="func">
<P>
Negates a number n such that if n is a number</P>
<PRE>
 n + negate n == 0</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:one">one</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n</SPAN></DT>
<DD class="func">
<P>
the number 1 in the instantiated type</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:sign">sign</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">sign n</SPAN> is -1 if n&lt;0, 1 if n&gt;0 and 0 otherwise</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:subtract">subtract</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; n -&gt; n</SPAN></DT>
<DD class="func">
<P>
use <SPAN CLASS="code">(subtract a)</SPAN> instead of <SPAN CLASS="code">\\b -&gt; b-a</SPAN> in sections</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num:zero">zero</A> :: <B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n</SPAN></DT>
<DD class="func">
<P>
the number 0 in the instantiated type</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Ord">Ord</A> <A class="tref" href="#Eq">Eq</A> ord =&gt;  ord</SPAN></DT>
<DD class="clas">
<P>
The <A class="tref" href="#Ord">Ord</A> class provides relational operators as well as the functions <A class="fref" href="#Ord:max">Ord.max</A> and <A class="fref" href="#Ord:min">Ord.min</A>. The default implementation defines them all in terms of the <I>compare</I> operator <A class="fref" href="#Ord:_lt_eq_gt">Ord.&lt;=&gt;</A>.</P>
<P>
Making some type an instance of <A class="tref" href="#Ord">Ord</A> makes it automatically an instance of <A class="tref" href="#Eq">Eq</A> if it is not one already. The operators <A class="fref" href="#Eq:_eq_eq">Eq.==</A> and <A class="fref" href="#Eq:_excl_eq">Eq.!=</A> will be defined in terms of <A class="fref" href="#Ord:_lt_eq_gt">Ord.&lt;=&gt;</A> too.</P>
<P>
Instances of <A class="tref" href="#Ord">Ord</A> can be derived automatically for algebraic data types when all elements of the type are themselves instances of <A class="tref" href="#Ord">Ord</A>.</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Ord_String">String</A>, <A class="tref" href="#Ord_Long">Long</A>, <A class="tref" href="#Ord_Int">Int</A>, <A class="tref" href="#Ord_Double">Double</A>, <A class="tref" href="#Ord_Float">Float</A>, <A class="tref" href="#Ord_Bool">Bool</A>, <A class="tref" href="#Ord_Char">Char</A>, <A class="tref" href="#Ord_Integer">Integer</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Ord:_excl_eq">!=</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
This implementation for the (<A class="fref" href="#Eq:_excl_eq">Eq.!=</A>) operator is being used in instances of <A class="tref" href="#Ord">Ord</A> when the instantiated type is not already an instance of <A class="tref" href="#Eq">Eq</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord:_lt">&lt;</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Relational <SPAN CLASS="code">&lt;</SPAN> operator. Obeys the following laws:</P>
<PRE>
 if a &lt; b &amp;&amp; b &lt; c then a &lt; c
 a &lt; b == b &gt; a</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord:_lt_eq">&lt;=</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Relational <SPAN CLASS="code">&lt;=</SPAN> operator. Obeys the following laws:</P>
<PRE>
 if a &lt;= b &amp;&amp; b &lt;= c then a &lt;= c
 a &lt;= b == b &gt;= a
 a &lt;= b == !(a &gt; b)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord:_lt_eq_gt">&lt;=&gt;</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
This operator must be defined in all instances. It compares its operands and returns <A class="fref" href="#Ordering:Lt">Ordering.Lt</A> if the first is lower than the second, <A class="fref" href="#Ordering:Gt">Ordering.Gt</A> if the first is greater than the second and <A class="fref" href="#Ordering:Eq">Ordering.Eq</A> otherwise.</P>
<P>
The following shall be invariantly true:</P>
<PRE>
 case a &lt;=&gt; b of { Eq -&gt; a == b; _ -&gt; a != b }</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord:_eq_eq">==</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
This implementation for the (<A class="fref" href="#Eq:_eq_eq">Eq.==</A>) operator is being used in instances of <A class="tref" href="#Ord">Ord</A> when the instantiated type is not already an instance of <A class="tref" href="#Eq">Eq</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord:_gt">&gt;</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Relational <SPAN CLASS="code">&gt;</SPAN> operator. Obeys the following laws:</P>
<PRE>
 if a &gt; b &amp;&amp; b &gt; c then a &gt; c
 a &gt; b == b &lt; a</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord:_gt_eq">&gt;=</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Relational <SPAN CLASS="code">&gt;=</SPAN> operator. Obeys the following laws:</P>
<PRE>
 if a &gt;= b &amp;&amp; b &gt;= c then a &gt;= c
 a &gt;= b == b &lt;= a
 a &gt;= b == !(a &lt; b)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord:compare">compare</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord:max">max</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; ord</SPAN></DT>
<DD class="func">
<PRE>
 max a b = if a &gt; b then a else b</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord:min">min</A> :: <B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; ord</SPAN></DT>
<DD class="func">
<PRE>
 min a b = if a &lt; b then a else b</PRE>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Real">Real</A> (<A class="tref" href="#Eq">Eq</A> r, <A class="tref" href="#Ord">Ord</A> r, <A class="tref" href="#Num">Num</A> r) =&gt;  r</SPAN></DT>
<DD class="clas">
<P>
The <A class="tref" href="#Real">Real</A> class provides the division operator (<A class="fref" href="#Real:_div">Real./</A>).</P>
<H3>
Known Instances</H3>
<P>
<A class="tref" href="#Real_Double">Double</A>, <A class="tref" href="#Real_Float">Float</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Real:_div">/</A> :: <B>forall</B> r.<A class="tref" href="#Real">Real</A> r =&gt; r -&gt; r -&gt; r</SPAN></DT>
<DD class="func">
<P>
the division operator</P>
</DD>
</DL>
</DD>
<DT class="clas">
<SPAN CLASS="code"><B>class </B><A name="Serializable">Serializable</A> <A class="tref" href="#Freezable">Freezable</A> f =&gt;  f</SPAN></DT>
<DD class="clas">
<P>
For a data type declared like</P>
<PRE>
 data D s = native Javatype</PRE>
<P>
where <SPAN CLASS="code">Javatype</SPAN> implements the <SPAN CLASS="code">java.io.Serializable</SPAN> interface, one can get implementations for <A class="fref" href="#Freezable:freeze">Freezable.freeze</A> and <A class="fref" href="#Freezable:thaw">Freezable.thaw</A> by just stating</P>
<PRE>
 instance Serializable D</PRE>
<P>
The <A class="fref" href="#Freezable:freeze">Freezable.freeze</A> and <A class="fref" href="#Freezable:thaw">Freezable.thaw</A> operations are implemented in terms of <SPAN CLASS="code">copySerializable</SPAN>, which serializes its argument to a byte array and creates a new copy by deserializing it from the byte array.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Serializable:copySerializable">copySerializable</A> :: <B>forall</B> b a f.<A class="tref" href="#Serializable">Serializable</A> f =&gt; <B>f a</B> -&gt; f b&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.copySerializable</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">copySerializable v</SPAN> is supposed to be a native function that is implemented by <SPAN CLASS="code">frege.RT.copySerializable</SPAN> at the instantiated type.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Serializable:freeze">freeze</A> :: <B>forall</B> f s.<A class="tref" href="#Serializable">Serializable</A> f =&gt; <B>f s</B> -&gt; <A class="tref" href="#ST">ST</A> s (f <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Serializable:thaw">thaw</A> :: <B>forall</B> f s.<A class="tref" href="#Serializable">Serializable</A> f =&gt; <B>f <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#ST">ST</A> s (f s)</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
</DL>
<H2>
<A name="instance">Instances</A></H2>
<DL class="inst">
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="AbstractList_String"> </A> <A class="tref" href="#AbstractList">AbstractList</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="AbstractList_String:_plus_plus">++</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>+</SPAN></DT>
<DD class="func">
<P>
Concatenate two strings, uses Java's <SPAN CLASS="code">+</SPAN> operator</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="AbstractList_String:tail">tail</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="AbstractList__lbrack_rbrack"> </A> <A class="tref" href="#AbstractList">AbstractList</A> [a]</SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="AbstractList__lbrack_rbrack:_plus_plus">++</A> :: <B>forall</B> a.<B>[a]</B> -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="AbstractList__lbrack_rbrack:tail">tail</A> :: <B>forall</B> a.<B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Bounded_Bool"> </A> <A class="tref" href="#Bounded">Bounded</A> <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Bounded_Bool:maxBound">maxBound</A> :: <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Bounded_Bool:minBound">minBound</A> :: <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Bounded_Char"> </A> <A class="tref" href="#Bounded">Bounded</A> <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Bounded_Char:maxBound">maxBound</A> :: <A class="tref" href="#Char">Char</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Character.MAX_VALUE</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Bounded_Char:minBound">minBound</A> :: <A class="tref" href="#Char">Char</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Character.MIN_VALUE</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Bounded_Int"> </A> <A class="tref" href="#Bounded">Bounded</A> <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Bounded_Int:maxBound">maxBound</A> :: <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
the largest <A class="tref" href="#Int">Int</A> value  2147483647 (or (2**31)-1)</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Bounded_Int:minBound">minBound</A> :: <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
the smallest <A class="tref" href="#Int">Int</A> value  -2147483648 (or -(2**31))</P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Bounded_Long"> </A> <A class="tref" href="#Bounded">Bounded</A> <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Bounded_Long:maxBound">maxBound</A> :: <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
the largest <A class="tref" href="#Long">Long</A> value  9223372036854775807 (or (2**63)-1)</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Bounded_Long:minBound">minBound</A> :: <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
the smallest <A class="tref" href="#Long">Long</A> value  -9223372036854775808 (or -(2**63))</P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Cloneable_IntArray"> </A> <A class="tref" href="#Cloneable">Cloneable</A> <A class="tref" href="#IntArray">IntArray</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_IntArray:clone">clone</A> :: <B>forall</B> a b.<B><A class="tref" href="#IntArray">IntArray</A> a</B> -&gt; <A class="tref" href="#IntArray">IntArray</A> b&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>clone</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Cloneable:clone">Cloneable.clone</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_IntArray:freeze">freeze</A> :: <B>forall</B> a.<B><A class="tref" href="#IntArray">IntArray</A> a</B> -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Cloneable:freeze">Cloneable.freeze</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_IntArray:our">our</A> :: <B>forall</B> s.<B><A class="tref" href="#IntArray">IntArray</A> s</B> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A>)&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>frege.RT.our</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_IntArray:thaw">thaw</A> :: <B>forall</B> a.<B><A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#IntArray">IntArray</A> a)</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Cloneable:thaw">Cloneable.thaw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_IntArray:withFrozen">withFrozen</A> :: <B>forall</B> a b.<A class="tref" href="#IntArray">IntArray</A> a -&gt; (<A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A>-&gt;b) -&gt; <A class="tref" href="#ST">ST</A> a b</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Freezable:withFrozen">Freezable.withFrozen</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Cloneable_STArray"> </A> <A class="tref" href="#Cloneable">Cloneable</A> <A class="tref" href="#STArray">STArray</A> elem</SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_STArray:clone">clone</A> :: <B>forall</B> a b c.<B><A class="tref" href="#STArray">STArray</A> b c</B> -&gt; <A class="tref" href="#STArray">STArray</A> b a&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>clone</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Cloneable:clone">Cloneable.clone</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_STArray:freeze">freeze</A> :: <B>forall</B> a b.<B><A class="tref" href="#STArray">STArray</A> a b</B> -&gt; <A class="tref" href="#ST">ST</A> b (<A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Cloneable:freeze">Cloneable.freeze</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_STArray:our">our</A> :: <B>forall</B> s elem.<B><A class="tref" href="#STArray">STArray</A> elem s</B> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#STArray">STArray</A> elem <A class="tref" href="#Immutable">Immutable</A>)&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>frege.RT.our</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_STArray:thaw">thaw</A> :: <B>forall</B> a b.<B><A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#ST">ST</A> b (<A class="tref" href="#STArray">STArray</A> a b)</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Cloneable:thaw">Cloneable.thaw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_STArray:withFrozen">withFrozen</A> :: <B>forall</B> a b c.<A class="tref" href="#STArray">STArray</A> b a -&gt; (<A class="tref" href="#STArray">STArray</A> b <A class="tref" href="#Immutable">Immutable</A>-&gt;c) -&gt; <A class="tref" href="#ST">ST</A> a c</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Freezable:withFrozen">Freezable.withFrozen</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Cloneable_StringArray"> </A> <A class="tref" href="#Cloneable">Cloneable</A> <A class="tref" href="#StringArray">StringArray</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_StringArray:clone">clone</A> :: <B>forall</B> a b.<B><A class="tref" href="#StringArray">StringArray</A> a</B> -&gt; <A class="tref" href="#StringArray">StringArray</A> b&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>clone</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Cloneable:clone">Cloneable.clone</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_StringArray:freeze">freeze</A> :: <B>forall</B> a.<B><A class="tref" href="#StringArray">StringArray</A> a</B> -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Cloneable:freeze">Cloneable.freeze</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_StringArray:our">our</A> :: <B>forall</B> s.<B><A class="tref" href="#StringArray">StringArray</A> s</B> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A>)&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>frege.RT.our</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_StringArray:thaw">thaw</A> :: <B>forall</B> a.<B><A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#StringArray">StringArray</A> a)</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Cloneable:thaw">Cloneable.thaw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Cloneable_StringArray:withFrozen">withFrozen</A> :: <B>forall</B> a b.<A class="tref" href="#StringArray">StringArray</A> a -&gt; (<A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A>-&gt;b) -&gt; <A class="tref" href="#ST">ST</A> a b</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Freezable:withFrozen">Freezable.withFrozen</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Empty_String"> </A> <A class="tref" href="#Empty">Empty</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Empty_String:empty">empty</A> :: <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Empty_String:_null">null</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Empty__lbrack_rbrack"> </A> <A class="tref" href="#Empty">Empty</A> [a]</SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Empty__lbrack_rbrack:empty">empty</A> :: <B>forall</B> a.[a]</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Empty__lbrack_rbrack:_null">null</A> :: <B>forall</B> a.<B>[a]</B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Enum_Bool"> </A> <A class="tref" href="#Enum">Enum</A> <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Bool:_dot_dot">..</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; [<A class="tref" href="#Bool">Bool</A>]</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Enum:_dot_dot">Enum...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Bool:from">from</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Bool:ord">ord</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Bool:pred">pred</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Bool:succ">succ</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Enum_Char"> </A> <A class="tref" href="#Enum">Enum</A> <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Char:_dot_dot">..</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; [<A class="tref" href="#Char">Char</A>]</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Enum:_dot_dot">Enum...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Char:from">from</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Char">Char</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>(char)</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Char:ord">ord</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>(int)</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">c.ord</SPAN> is the ordinal (integer) value of the character <SPAN CLASS="code">c</SPAN>. It holds: <SPAN CLASS="code">c.ord.char</SPAN> == <SPAN CLASS="code">c</SPAN>, see <A class="fref" href="#Int:_char">Int.char</A>. (But note that <SPAN CLASS="code">i.char.ord</SPAN> is not necessarily <SPAN CLASS="code">i</SPAN>)</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Char:pred">pred</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Char:succ">succ</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Enum_Int"> </A> <A class="tref" href="#Enum">Enum</A> <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Int:_dot_dot">..</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; [<A class="tref" href="#Int">Int</A>]</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Enum:_dot_dot">Enum...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Int:from">from</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<PRE>
 from i = i</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Int:ord">ord</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<PRE>
 ord i = i</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Int:pred">pred</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">pred i</SPAN> is the same as <SPAN CLASS="code">i-1</SPAN> except for <SPAN CLASS="code">pred Int.minBound</SPAN>, which is <A class="fref" href="#undefined">undefined</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Int:succ">succ</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">succ i</SPAN> is the same as <SPAN CLASS="code">i+1</SPAN> except for <SPAN CLASS="code">succ Int.maxBound</SPAN>, which is <A class="fref" href="#undefined">undefined</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Enum_Integer"> </A> <A class="tref" href="#Enum">Enum</A> <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="inst">
<P>
<A class="tref" href="#Integer">Integer</A> is an instance of <A class="tref" href="#Enum">Enum</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Integer:_dot_dot">..</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; [<A class="tref" href="#Integer">Integer</A>]</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Enum:_dot_dot">Enum...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Integer:from">from</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">Integer.from i</SPAN> is the same as <SPAN CLASS="code">Int.big i</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Integer:ord">ord</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">ord b</SPAN> is only defined if the value of b is in the range <A class="fref" href="#Bounded_Int:minBound">Bounded_Int.minBound</A> .. <A class="fref" href="#Bounded_Int:maxBound">Bounded_Int.maxBound</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Integer:pred">pred</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">succ b</SPAN>  is the same as <SPAN CLASS="code">b + 1.big</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Integer:succ">succ</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">succ b</SPAN>  is the same as <SPAN CLASS="code">b + 1.big</SPAN></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Enum_Long"> </A> <A class="tref" href="#Enum">Enum</A> <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Long:_dot_dot">..</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; [<A class="tref" href="#Long">Long</A>]</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Enum:_dot_dot">Enum...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Long:from">from</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">Long.from i</SPAN> returns a <A class="tref" href="#Long">Long</A> with the same numeric value as <SPAN CLASS="code">i</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Long:ord">ord</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">ord l</SPAN> is only valid if <SPAN CLASS="code">Int.minBound.long &lt;= l &amp;&amp; l &lt;= Int.maxBound</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Long:pred">pred</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">pred a</SPAN> is the same as <SPAN CLASS="code">a-1L</SPAN> except for <SPAN CLASS="code">pred Long.minBound</SPAN>, which is <A class="fref" href="#undefined">undefined</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Enum_Long:succ">succ</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">succ a</SPAN> is the same as <SPAN CLASS="code">a+1L</SPAN> except for <SPAN CLASS="code">succ Long.maxBound</SPAN>, which is <A class="fref" href="#undefined">undefined</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Eq__lpar_rpar"> </A> <A class="tref" href="#Eq">Eq</A> <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq__lpar_rpar:_excl_eq">!=</A> :: <A class="tref" href="#Unit">()</A> -&gt; <A class="tref" href="#Unit">()</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq__lpar_rpar:_div_eq">/=</A> :: <A class="tref" href="#Unit">()</A> -&gt; <A class="tref" href="#Unit">()</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq__lpar_rpar:_eq_eq">==</A> :: <A class="tref" href="#Unit">()</A> -&gt; <A class="tref" href="#Unit">()</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Eq_Bool"> </A> <A class="tref" href="#Eq">Eq</A> <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Bool:_excl_eq">!=</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>!=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Bool:_div_eq">/=</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Bool:_eq_eq">==</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>==</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Eq_Char"> </A> <A class="tref" href="#Eq">Eq</A> <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Char:_excl_eq">!=</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>!=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Char:_div_eq">/=</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Char:_eq_eq">==</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>==</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Eq_Double"> </A> <A class="tref" href="#Eq">Eq</A> <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Double:_excl_eq">!=</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>!=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Double:_div_eq">/=</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Double:_eq_eq">==</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>==</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Eq_Float"> </A> <A class="tref" href="#Eq">Eq</A> <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Float:_excl_eq">!=</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>!=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Float:_div_eq">/=</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Float:_eq_eq">==</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>==</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Eq_Int"> </A> <A class="tref" href="#Eq">Eq</A> <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Int:_excl_eq">!=</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>!=</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">!=</SPAN> operator for comparision of <A class="tref" href="#Int">Int</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Int:_div_eq">/=</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Int:_eq_eq">==</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>==</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">==</SPAN> operator for comparision of <A class="tref" href="#Int">Int</A> values.</P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Eq_Long"> </A> <A class="tref" href="#Eq">Eq</A> <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Long:_excl_eq">!=</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>!=</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">!=</SPAN> operator for comparision of <A class="tref" href="#Long">Long</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Long:_div_eq">/=</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_Long:_eq_eq">==</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>==</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">==</SPAN> operator for comparision of <A class="tref" href="#Long">Long</A> values.</P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Eq_String"> </A> <A class="tref" href="#Eq">Eq</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq_String:_excl_eq">!=</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_String:_div_eq">/=</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq_String:_eq_eq">==</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>equals</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Eq__lbrack_rbrack"> </A> <A class="tref" href="#Eq">Eq</A> <A class="tref" href="#Eq">Eq</A> a =&gt; [a]</SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq__lbrack_rbrack:_excl_eq">!=</A> :: <B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; <B>[a]</B> -&gt; [a] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_excl_eq">Eq.!=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq__lbrack_rbrack:_div_eq">/=</A> :: <B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; [a] -&gt; [a] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Eq__lbrack_rbrack:_eq_eq">==</A> :: <B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; <B>[a]</B> -&gt; [a] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
two lists are equal if their heads and tails are equal or if the lists are empty</P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Functor_Either"> </A> <A class="tref" href="#Functor">Functor</A> <A class="tref" href="#Either">Either</A> a</SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Functor_Either:fmap">fmap</A> :: <B>forall</B> a b c.(c-&gt;a) -&gt; <B><A class="tref" href="#Either">Either</A> b c</B> -&gt; <A class="tref" href="#Either">Either</A> b a</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Functor_Maybe"> </A> <A class="tref" href="#Functor">Functor</A> <A class="tref" href="#Maybe">Maybe</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Functor_Maybe:fmap">fmap</A> :: <B>forall</B> a b.(a-&gt;b) -&gt; <B><A class="tref" href="#Maybe">Maybe</A> a</B> -&gt; <A class="tref" href="#Maybe">Maybe</A> b</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="IntegerConvertable_Int"> </A> <A class="tref" href="#IntegerConvertable">IntegerConvertable</A> <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="IntegerConvertable_Int:big">big</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="IntegerConvertable_Long"> </A> <A class="tref" href="#IntegerConvertable">IntegerConvertable</A> <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="IntegerConvertable_Long:big">big</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Integral_Int"> </A> <A class="tref" href="#Integral">Integral</A> <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Int:band">band</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&amp;</SPAN></DT>
<DD class="func">
<P>
Computes binary <I>and</I> of two integers. Uses the java <SPAN CLASS="code">&amp;</SPAN>-operator.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Int:bor">bor</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>|</SPAN></DT>
<DD class="func">
<P>
Computes binary <I>or</I> of two integers. Uses the java <SPAN CLASS="code">|</SPAN>-operator.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Int:bshl">bshl</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;&lt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Int:bshr">bshr</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;&gt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Int:bxor">bxor</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>^</SPAN></DT>
<DD class="func">
<P>
Computes binary <I>exclusive or</I> of two integers. Uses the java <SPAN CLASS="code">^</SPAN>-operator.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Int:div">div</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>/</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Int:mod">mod</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Integral:mod">Integral.mod</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Int:rem">rem</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>%</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Integral_Integer"> </A> <A class="tref" href="#Integral">Integral</A> <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="inst">
<P>
<A class="tref" href="#Integer">Integer</A> is an instance of <A class="tref" href="#Integral">Integral</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:_star">*</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>multiply</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:_plus">+</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>add</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:_minus">-</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>subtract</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:abs">abs</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>abs</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:band">band</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>and</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:bor">bor</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>or</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:bshl">bshl</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>shiftLeft</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:bshr">bshr</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>shiftRight</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:bxor">bxor</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>xor</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:div">div</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>divide</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:fromInt">fromInt</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:isInfinite">isInfinite</A> :: <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isInfinite">Num.isInfinite</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:isNaN">isNaN</A> :: <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isNaN">Num.isNaN</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:isNumber">isNumber</A> :: <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isNumber">Num.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:mod">mod</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
The native <SPAN CLASS="code">java.math.BigInteger.mod</SPAN> method throws an <SPAN CLASS="code">ArithmeticException</SPAN> when the divisor is  lower than 0 This is incompatible with <A class="fref" href="#Integral:mod">Integral.mod</A> thus we force the divisor to be positive.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:negate">negate</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>negate</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:one">one</A> :: <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.math.BigInteger.ONE</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:rem">rem</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>remainder</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:sign">sign</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>signum</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:subtract">subtract</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:subtract">Num.subtract</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Integer:zero">zero</A> :: <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.math.BigInteger.ZERO</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Integral_Long"> </A> <A class="tref" href="#Integral">Integral</A> <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Long:band">band</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&amp;</SPAN></DT>
<DD class="func">
<P>
Computes binary <I>and</I> of two integers. Uses the java <SPAN CLASS="code">&amp;</SPAN>-operator.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Long:bor">bor</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>|</SPAN></DT>
<DD class="func">
<P>
Computes binary <I>or</I> of two long integers. Uses the java <SPAN CLASS="code">|</SPAN>-operator.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Long:bshl">bshl</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;&lt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Long:bshr">bshr</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;&gt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Long:bxor">bxor</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>^</SPAN></DT>
<DD class="func">
<P>
Computes binary <I>exclusive or</I> of two long integers. Uses the java <SPAN CLASS="code">^</SPAN>-operator.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Long:div">div</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>/</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Long:mod">mod</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Integral:mod">Integral.mod</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integral_Long:rem">rem</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>%</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Length_String"> </A> <A class="tref" href="#Length">Length</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="inst">
<P>
///////////////////////////////////////////////////////////////////</P>
<P>
///////////////////////////////////////////////////////////////////</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Length_String:length">length</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>length</SPAN></DT>
<DD class="func">
<P>
Get the length of a <A class="tref" href="#String">String</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Length__lbrack_rbrack"> </A> <A class="tref" href="#Length">Length</A> [a]</SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Length__lbrack_rbrack:length">length</A> :: <B>forall</B> a.<B>[a]</B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="ListSource_Either"> </A> <A class="tref" href="#ListSource">ListSource</A> <A class="tref" href="#Either">Either</A> l</SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="ListSource_Either:toList">toList</A> :: <B>forall</B> a b.<B><A class="tref" href="#Either">Either</A> a b</B> -&gt; [b]</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="ListSource_Maybe"> </A> <A class="tref" href="#ListSource">ListSource</A> <A class="tref" href="#Maybe">Maybe</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="ListSource_Maybe:toList">toList</A> :: <B>forall</B> a.<B><A class="tref" href="#Maybe">Maybe</A> a</B> -&gt; [a]</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Monad_Either"> </A> <A class="tref" href="#Monad">Monad</A> <A class="tref" href="#Either">Either</A> a</SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Monad_Either:_gt_gt">&gt;&gt;</A> :: <B>forall</B> a b c.<B><A class="tref" href="#Either">Either</A> b c</B> -&gt; <A class="tref" href="#Either">Either</A> b a -&gt; <A class="tref" href="#Either">Either</A> b a</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Monad:_gt_gt">Monad.&gt;&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_Either:_gt_gt_eq">&gt;&gt;=</A> :: <B>forall</B> a b c.<B><A class="tref" href="#Either">Either</A> b c</B> -&gt; (c-&gt;<A class="tref" href="#Either">Either</A> b a) -&gt; <A class="tref" href="#Either">Either</A> b a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_Either:fail">fail</A> :: <B>forall</B> a b.<B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Either">Either</A> a b</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Monad:fail">Monad.fail</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_Either:_return">return</A> :: <B>forall</B> a b.a -&gt; <A class="tref" href="#Either">Either</A> b a</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Monad_Maybe"> </A> <A class="tref" href="#Monad">Monad</A> <A class="tref" href="#Maybe">Maybe</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Monad_Maybe:_gt_gt">&gt;&gt;</A> :: <B>forall</B> a b.<B><A class="tref" href="#Maybe">Maybe</A> a</B> -&gt; <A class="tref" href="#Maybe">Maybe</A> b -&gt; <A class="tref" href="#Maybe">Maybe</A> b</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Monad:_gt_gt">Monad.&gt;&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_Maybe:_gt_gt_eq">&gt;&gt;=</A> :: <B>forall</B> a b.<B><A class="tref" href="#Maybe">Maybe</A> a</B> -&gt; (a-&gt;<A class="tref" href="#Maybe">Maybe</A> b) -&gt; <A class="tref" href="#Maybe">Maybe</A> b</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_Maybe:fail">fail</A> :: <B>forall</B> a.<A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_Maybe:_return">return</A> :: <B>forall</B> a.a -&gt; <A class="tref" href="#Maybe">Maybe</A> a</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Monad_ST"> </A> <A class="tref" href="#Monad">Monad</A> <A class="tref" href="#ST">ST</A> s</SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Monad_ST:_gt_gt">&gt;&gt;</A> :: <B>forall</B> a b c.<A class="tref" href="#ST">ST</A> b c -&gt; <A class="tref" href="#ST">ST</A> b a -&gt; <A class="tref" href="#ST">ST</A> b a</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Monad:_gt_gt">Monad.&gt;&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_ST:_gt_gt_eq">&gt;&gt;=</A> :: <B>forall</B> a b c.<A class="tref" href="#ST">ST</A> b c -&gt; (c-&gt;<A class="tref" href="#ST">ST</A> b a) -&gt; <A class="tref" href="#ST">ST</A> b a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_ST:fail">fail</A> :: <B>forall</B> a b.<B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#ST">ST</A> a b</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_ST:_return">return</A> :: <B>forall</B> a b.<B>a</B> -&gt; <A class="tref" href="#ST">ST</A> b a</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Monad_State"> </A> <A class="tref" href="#Monad">Monad</A> <A class="tref" href="#State">State</A> s</SPAN></DT>
<DD class="inst">
<P>
the monad for construction of stateful computations</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Monad_State:_gt_gt">&gt;&gt;</A> :: <B>forall</B> a b c.<B><A class="tref" href="#State">State</A> b c</B> -&gt; <A class="tref" href="#State">State</A> b a -&gt; <A class="tref" href="#State">State</A> b a</SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Monad:_gt_gt">Monad.&gt;&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_State:_gt_gt_eq">&gt;&gt;=</A> :: <B>forall</B> a b c.<B><A class="tref" href="#State">State</A> b c</B> -&gt; (c-&gt;<A class="tref" href="#State">State</A> b a) -&gt; <A class="tref" href="#State">State</A> b a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_State:fail">fail</A> :: <B>forall</B> a b.<B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#State">State</A> a b</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Monad_State:_return">return</A> :: <B>forall</B> a b.a -&gt; <A class="tref" href="#State">State</A> b a</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Num_Int"> </A> <A class="tref" href="#Num">Num</A> <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:_star">*</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>*</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">*</SPAN> operator to multiply 2 <A class="tref" href="#Int">Int</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:_plus">+</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>+</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">+</SPAN> operator to add 2 <A class="tref" href="#Int">Int</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:_minus">-</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>-</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">-</SPAN> operator to subtract one <A class="tref" href="#Int">Int</A> value from another.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:abs">abs</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
Returns the negated argument if it is negative, otherwise the argument itself.</P>
<P>
This does not work for <A class="fref" href="#Bounded_Int:minBound">Bounded_Int.minBound</A> since there is no corresponding positive value that can be represented as an <A class="tref" href="#Int">Int</A>. Rather</P>
<PRE>
 abs Int.minBound == Int.minBound</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:fromInt">fromInt</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
For <A class="tref" href="#Int">Int</A> values, this is the identity function.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:isInfinite">isInfinite</A> :: <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isInfinite">Num.isInfinite</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:isNaN">isNaN</A> :: <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isNaN">Num.isNaN</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:isNumber">isNumber</A> :: <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isNumber">Num.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:negate">negate</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>-</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">negate i</SPAN> computes <SPAN CLASS="code">0-i</SPAN> using the java negation operator <SPAN CLASS="code">-</SPAN>.</P>
<P>
This does not work for <A class="fref" href="#Bounded_Int:minBound">Bounded_Int.minBound</A> since there is no corresponding positive value that can be represented as an <A class="tref" href="#Int">Int</A>. Rather</P>
<PRE>
 negate Int.minBound == Int.minBound</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:one">one</A> :: <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
the integer constant 1</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:sign">sign</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:sign">Num.sign</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:subtract">subtract</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:subtract">Num.subtract</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Int:zero">zero</A> :: <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
the integer constant 0</P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Num_Long"> </A> <A class="tref" href="#Num">Num</A> <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:_star">*</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>*</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">*</SPAN> operator to multiply two <A class="tref" href="#Long">Long</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:_plus">+</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>+</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">+</SPAN> operator to add two <A class="tref" href="#Long">Long</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:_minus">-</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>-</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">-</SPAN> operator to subtract a <A class="tref" href="#Long">Long</A> value from another.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:abs">abs</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
Returns the negated argument if it is negative, otherwise the argument itself.</P>
<P>
This does not work for <A class="fref" href="#Bounded_Long:minBound">Bounded_Long.minBound</A> since there is no corresponding positive value that can be represented as a <A class="tref" href="#Long">Long</A>. Rather</P>
<PRE>
 abs Long.minBound == Long.minBound</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:fromInt">fromInt</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
applys the widening primitive conversion (JLS §5.1.2) from <SPAN CLASS="code">int</SPAN> to <SPAN CLASS="code">long</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:isInfinite">isInfinite</A> :: <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isInfinite">Num.isInfinite</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:isNaN">isNaN</A> :: <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isNaN">Num.isNaN</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:isNumber">isNumber</A> :: <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isNumber">Num.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:negate">negate</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>-</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">negate a</SPAN> computes <SPAN CLASS="code">0L-a</SPAN> using the java negation operator <SPAN CLASS="code">-</SPAN>.</P>
<P>
This does not work for <A class="fref" href="#Bounded_Long:minBound">Bounded_Long.minBound</A> since there is no corresponding positive value that can be represented as a <A class="tref" href="#Long">Long</A>. Rather</P>
<PRE>
 negate Long.minBound == Long.minBound</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:one">one</A> :: <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
The constant <SPAN CLASS="code">1L</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:sign">sign</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:sign">Num.sign</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:subtract">subtract</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:subtract">Num.subtract</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Num_Long:zero">zero</A> :: <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
The constant <SPAN CLASS="code">0L</SPAN>.</P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Ord_Bool"> </A> <A class="tref" href="#Ord">Ord</A> <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Bool:_lt">&lt;</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Bool:_lt_eq">&lt;=</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Bool:_lt_eq_gt">&lt;=&gt;</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Bool:_gt">&gt;</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Bool:_gt_eq">&gt;=</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Bool:compare">compare</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:compare">Ord.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Bool:max">max</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:max">Ord.max</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Bool:min">min</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:min">Ord.min</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Ord_Char"> </A> <A class="tref" href="#Ord">Ord</A> <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Char:_lt">&lt;</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Char:_lt_eq">&lt;=</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Char:_lt_eq_gt">&lt;=&gt;</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Char:_gt">&gt;</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Char:_gt_eq">&gt;=</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Char:compare">compare</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:compare">Ord.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Char:max">max</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:max">Ord.max</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Char:min">min</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:min">Ord.min</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Ord_Double"> </A> <A class="tref" href="#Ord">Ord</A> <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Double:_lt">&lt;</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Double:_lt_eq">&lt;=</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Double:_lt_eq_gt">&lt;=&gt;</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Double:_gt">&gt;</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Double:_gt_eq">&gt;=</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Double:compare">compare</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:compare">Ord.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Double:max">max</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:max">Ord.max</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Double:min">min</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:min">Ord.min</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Ord_Float"> </A> <A class="tref" href="#Ord">Ord</A> <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Float:_lt">&lt;</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Float:_lt_eq">&lt;=</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Float:_lt_eq_gt">&lt;=&gt;</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Float:_gt">&gt;</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Float:_gt_eq">&gt;=</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;=</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Float:compare">compare</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:compare">Ord.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Float:max">max</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:max">Ord.max</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Float:min">min</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:min">Ord.min</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Ord_Int"> </A> <A class="tref" href="#Ord">Ord</A> <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Int:_lt">&lt;</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">&lt;</SPAN> operator for comparision of <A class="tref" href="#Int">Int</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Int:_lt_eq">&lt;=</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;=</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">&lt;=</SPAN> operator for comparision of <A class="tref" href="#Int">Int</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Int:_lt_eq_gt">&lt;=&gt;</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Int:_gt">&gt;</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">&gt;</SPAN> operator for comparision of <A class="tref" href="#Int">Int</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Int:_gt_eq">&gt;=</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;=</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">&gt;=</SPAN> operator for comparision of <A class="tref" href="#Int">Int</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Int:compare">compare</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:compare">Ord.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Int:max">max</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:max">Ord.max</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Int:min">min</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:min">Ord.min</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Ord_Integer"> </A> <A class="tref" href="#Ord">Ord</A> <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="inst">
<P>
<A class="tref" href="#Integer">Integer</A> is an instance of <A class="tref" href="#Ord">Ord</A></P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:_excl_eq">!=</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:_div_eq">/=</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Eq:_div_eq">Eq./=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:_lt">&lt;</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:_lt_eq">&lt;=</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:_lt_eq_gt">&lt;=&gt;</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:_eq_eq">==</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:_gt">&gt;</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:_gt_eq">&gt;=</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:compare">compare</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:compare">Ord.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:max">max</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>max</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Integer:min">min</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>min</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Ord_Long"> </A> <A class="tref" href="#Ord">Ord</A> <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Long:_lt">&lt;</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">&lt;</SPAN> operator for comparision of <A class="tref" href="#Long">Long</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Long:_lt_eq">&lt;=</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&lt;=</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">&lt;=</SPAN> operator for comparision of <A class="tref" href="#Long">Long</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Long:_lt_eq_gt">&lt;=&gt;</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Long:_gt">&gt;</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">&gt;</SPAN> operator for comparision of <A class="tref" href="#Long">Long</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Long:_gt_eq">&gt;=</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&gt;=</SPAN></DT>
<DD class="func">
<P>
Uses the java <SPAN CLASS="code">&gt;=</SPAN> operator for comparision of <A class="tref" href="#Long">Long</A> values.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Long:compare">compare</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:compare">Ord.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Long:max">max</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:max">Ord.max</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_Long:min">min</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:min">Ord.min</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Ord_String"> </A> <A class="tref" href="#Ord">Ord</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Ord_String:_lt">&lt;</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_String:_lt_eq">&lt;=</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_String:_lt_eq_gt">&lt;=&gt;</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_String:_gt">&gt;</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_String:_gt_eq">&gt;=</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_String:compare">compare</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:compare">Ord.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_String:max">max</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:max">Ord.max</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Ord_String:min">min</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Ord:min">Ord.min</A></P>
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Real_Double"> </A> <A class="tref" href="#Real">Real</A> <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:_star">*</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>*</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:_plus">+</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>+</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:_minus">-</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>-</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:_div">/</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>/</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:abs">abs</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:abs">Num.abs</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:fromInt">fromInt</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:isInfinite">isInfinite</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Double.isInfinite</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:isNaN">isNaN</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Double.isNaN</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:isNumber">isNumber</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isNumber">Num.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:negate">negate</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>-</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:one">one</A> :: <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:sign">sign</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:sign">Num.sign</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:subtract">subtract</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:subtract">Num.subtract</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Double:zero">zero</A> :: <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="inst">
<SPAN CLASS="code"><B>instance </B><A name="Real_Float"> </A> <A class="tref" href="#Real">Real</A> <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="inst">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:_star">*</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>*</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:_plus">+</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>+</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:_minus">-</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>-</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:_div">/</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>/</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:abs">abs</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:abs">Num.abs</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:fromInt">fromInt</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:isInfinite">isInfinite</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Float.isInfinite</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:isNaN">isNaN</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Float.isNaN</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:isNumber">isNumber</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:isNumber">Num.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:negate">negate</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>-</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:one">one</A> :: <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:sign">sign</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:sign">Num.sign</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:subtract">subtract</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
inherited from <A class="fref" href="#Num:subtract">Num.subtract</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Real_Float:zero">zero</A> :: <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
</DL>
<H2>
<A name="data">Data Types</A></H2>
<DL class="data">
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Unit"> </A> <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="data">
<P>
Unit type</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Unit">()</A> </SPAN></DT>
<DD class="func">
<P>
Unit value</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple2"> </A> (a, b)</SPAN></DT>
<DD class="data">
<P>
2-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple2">(,)</A> a&nbsp;&nbsp; b</SPAN></DT>
<DD class="func">
<P>
2-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple3"> </A> (a, b, c)</SPAN></DT>
<DD class="data">
<P>
3-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple3">(,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c</SPAN></DT>
<DD class="func">
<P>
3-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple4"> </A> (a, b, c, d)</SPAN></DT>
<DD class="data">
<P>
4-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple4">(,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d</SPAN></DT>
<DD class="func">
<P>
4-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple5"> </A> (a, b, c, d, e)</SPAN></DT>
<DD class="data">
<P>
5-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple5">(,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e</SPAN></DT>
<DD class="func">
<P>
5-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple6"> </A> (a, b, c, d, e, f)</SPAN></DT>
<DD class="data">
<P>
6-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple6">(,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f</SPAN></DT>
<DD class="func">
<P>
6-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple7"> </A> (a, b, c, d, e, f, g)</SPAN></DT>
<DD class="data">
<P>
7-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple7">(,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g</SPAN></DT>
<DD class="func">
<P>
7-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple8"> </A> (a, b, c, d, e, f, g, h)</SPAN></DT>
<DD class="data">
<P>
8-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple8">(,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h</SPAN></DT>
<DD class="func">
<P>
8-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple9"> </A> (a, b, c, d, e, f, g, h, i)</SPAN></DT>
<DD class="data">
<P>
9-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple9">(,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i</SPAN></DT>
<DD class="func">
<P>
9-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple10"> </A> (a, b, c, d, e, f, g, h, i, j)</SPAN></DT>
<DD class="data">
<P>
10-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple10">(,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j</SPAN></DT>
<DD class="func">
<P>
10-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple11"> </A> (a, b, c, d, e, f, g, h, i, j, k)</SPAN></DT>
<DD class="data">
<P>
11-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple11">(,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k</SPAN></DT>
<DD class="func">
<P>
11-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple12"> </A> (a, b, c, d, e, f, g, h, i, j, k, l)</SPAN></DT>
<DD class="data">
<P>
12-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple12">(,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l</SPAN></DT>
<DD class="func">
<P>
12-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple13"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m)</SPAN></DT>
<DD class="data">
<P>
13-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple13">(,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m</SPAN></DT>
<DD class="func">
<P>
13-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple14"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n)</SPAN></DT>
<DD class="data">
<P>
14-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple14">(,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n</SPAN></DT>
<DD class="func">
<P>
14-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple15"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)</SPAN></DT>
<DD class="data">
<P>
15-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple15">(,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o</SPAN></DT>
<DD class="func">
<P>
15-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple16"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)</SPAN></DT>
<DD class="data">
<P>
16-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple16">(,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p</SPAN></DT>
<DD class="func">
<P>
16-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple17"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)</SPAN></DT>
<DD class="data">
<P>
17-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple17">(,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q</SPAN></DT>
<DD class="func">
<P>
17-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple18"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)</SPAN></DT>
<DD class="data">
<P>
18-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple18">(,,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q&nbsp;&nbsp; r</SPAN></DT>
<DD class="func">
<P>
18-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple19"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)</SPAN></DT>
<DD class="data">
<P>
19-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple19">(,,,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q&nbsp;&nbsp; r&nbsp;&nbsp; s</SPAN></DT>
<DD class="func">
<P>
19-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple20"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)</SPAN></DT>
<DD class="data">
<P>
20-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple20">(,,,,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q&nbsp;&nbsp; r&nbsp;&nbsp; s&nbsp;&nbsp; t</SPAN></DT>
<DD class="func">
<P>
20-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple21"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)</SPAN></DT>
<DD class="data">
<P>
21-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple21">(,,,,,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q&nbsp;&nbsp; r&nbsp;&nbsp; s&nbsp;&nbsp; t&nbsp;&nbsp; u</SPAN></DT>
<DD class="func">
<P>
21-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple22"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)</SPAN></DT>
<DD class="data">
<P>
22-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple22">(,,,,,,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q&nbsp;&nbsp; r&nbsp;&nbsp; s&nbsp;&nbsp; t&nbsp;&nbsp; u&nbsp;&nbsp; v</SPAN></DT>
<DD class="func">
<P>
22-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple23"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)</SPAN></DT>
<DD class="data">
<P>
23-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple23">(,,,,,,,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q&nbsp;&nbsp; r&nbsp;&nbsp; s&nbsp;&nbsp; t&nbsp;&nbsp; u&nbsp;&nbsp; v&nbsp;&nbsp; w</SPAN></DT>
<DD class="func">
<P>
23-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple24"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)</SPAN></DT>
<DD class="data">
<P>
24-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple24">(,,,,,,,,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q&nbsp;&nbsp; r&nbsp;&nbsp; s&nbsp;&nbsp; t&nbsp;&nbsp; u&nbsp;&nbsp; v&nbsp;&nbsp; w&nbsp;&nbsp; x</SPAN></DT>
<DD class="func">
<P>
24-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple25"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)</SPAN></DT>
<DD class="data">
<P>
25-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple25">(,,,,,,,,,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q&nbsp;&nbsp; r&nbsp;&nbsp; s&nbsp;&nbsp; t&nbsp;&nbsp; u&nbsp;&nbsp; v&nbsp;&nbsp; w&nbsp;&nbsp; x&nbsp;&nbsp; y</SPAN></DT>
<DD class="func">
<P>
25-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Tuple26"> </A> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)</SPAN></DT>
<DD class="data">
<P>
26-tuple</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Tuple26">(,,,,,,,,,,,,,,,,,,,,,,,,,)</A> a&nbsp;&nbsp; b&nbsp;&nbsp; c&nbsp;&nbsp; d&nbsp;&nbsp; e&nbsp;&nbsp; f&nbsp;&nbsp; g&nbsp;&nbsp; h&nbsp;&nbsp; i&nbsp;&nbsp; j&nbsp;&nbsp; k&nbsp;&nbsp; l&nbsp;&nbsp; m&nbsp;&nbsp; n&nbsp;&nbsp; o&nbsp;&nbsp; p&nbsp;&nbsp; q&nbsp;&nbsp; r&nbsp;&nbsp; s&nbsp;&nbsp; t&nbsp;&nbsp; u&nbsp;&nbsp; v&nbsp;&nbsp; w&nbsp;&nbsp; x&nbsp;&nbsp; y&nbsp;&nbsp; z</SPAN></DT>
<DD class="func">
<P>
26-tuple constructor</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Function"> </A> a-&gt;b</SPAN></DT>
<DD class="data">
<P>
function</P>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Bool"> </A> <A class="tref" href="#Bool">Bool</A> = <B>native </B>boolean</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#Bool">Bool</A> values are based on Java's primitive <SPAN CLASS="code">boolean</SPAN> values. Note that <SPAN CLASS="code">true</SPAN> and <SPAN CLASS="code">false</SPAN> are literals, not constructors.</P>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Char"> </A> <A class="tref" href="#Char">Char</A> = <B>native </B>char</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#Char">Char</A> values are based on Java's primitive <SPAN CLASS="code">char</SPAN> values.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Char:isLowerCase">isLowerCase</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Character.isLowerCase</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Char:isUpperCase">isUpperCase</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Character.isUpperCase</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Char:isWhitespace">isWhitespace</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Character.isWhitespace</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Class"> </A> <A class="tref" href="#Class">Class</A> = <B>native </B>java.lang.Class</SPAN></DT>
<DD class="data">
<P>
We need to do some reflection from frege code. For example, when we catch an <A class="tref" href="#JException">JException</A> thrown from Java code. we might want to know what it is.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Class:forName">forName</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Class">Class</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Class.forName</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Class:getName">getName</A> :: <B><A class="tref" href="#Class">Class</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>getName</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Double"> </A> <A class="tref" href="#Double">Double</A> = <B>native </B>double</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#Double">Double</A> values are Java's primitive <SPAN CLASS="code">double</SPAN> values.</P>
<P>
According to the Java Language Specification §4.2.3, <SPAN CLASS="code">double</SPAN> values are 64-bit-precision binary floating point values. The values and the operations on it behave as speicified in the IEEE Standard for Binary Floating-Point Arithmetic.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Double:_float">float</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>(float)</SPAN></DT>
<DD class="func">
<P>
Applies the java narrowing primitive conversion from <SPAN CLASS="code">double</SPAN> to <SPAN CLASS="code">float</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Double:floor">floor</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Math.floor</SPAN></DT>
<DD class="func">
<P>
Returns the largest (closest to positive infinity) value that is less than or equal to the argument and is equal to a mathematical integer.</P>
<P>
Special cases:</P>
<UL>
<LI>
 If the argument value is already equal to a mathematical integer, then the result is the same as the argument.</LI>
<LI>
 If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.</LI>
</UL>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Double:_long">long</A> :: <B><A class="tref" href="#Double">Double</A></B> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Math.round</SPAN></DT>
<DD class="func">
<P>
Returns the closest <A class="tref" href="#Long">Long</A> value to the argument. The result is rounded to an integer by adding 1/2, taking the <A class="fref" href="#Double:floor">Double.floor</A> of the result, and casting the result to type <SPAN CLASS="code">long</SPAN>.</P>
<P>
The following property holds:</P>
<PRE>
 (d &lt; Long.maxBound.double &amp;&amp; d &gt; Long.minBound.double) ==&gt;
   (d.long.double == (d + 0.5d).floor)</PRE>
<P>
Special cases:</P>
<UL>
<LI>
 If the argument is NaN, the result is 0. </LI>
<LI>
 If the argument is negative infinity or any value less than or equal to the value of <A class="fref" href="#Bounded_Long:minBound">Bounded_Long.minBound</A>, the result is equal to the value of <A class="fref" href="#Bounded_Long:minBound">Bounded_Long.minBound</A>.</LI>
<LI>
 If the argument is positive infinity or any value greater than or equal to the value of <A class="fref" href="#Bounded_Long:maxBound">Bounded_Long.maxBound</A>, the result is equal to the value of <A class="fref" href="#Bounded_Long:maxBound">Bounded_Long.maxBound</A>.</LI>
</UL>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Either"> </A> <A class="tref" href="#Either">Either</A> a b</SPAN></DT>
<DD class="data">
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Left">Left</A> a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Right">Right</A> b</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Float"> </A> <A class="tref" href="#Float">Float</A> = <B>native </B>float</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#Float">Float</A> values are based on Java's primitive <SPAN CLASS="code">float</SPAN> values.</P>
<P>
According to the Java Language Specification §4.2.3, <SPAN CLASS="code">float</SPAN> values are 32-bit-precision binary floating point values. The values and the operations on it behave as speicified in the IEEE Standard for Binary Floating-Point Arithmetic.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Float:_double">double</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>(double)</SPAN></DT>
<DD class="func">
<P>
Applies the java widening primitive conversion from <SPAN CLASS="code">float</SPAN> to <SPAN CLASS="code">double</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Float:floor">floor</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
Returns the largest (closest to positive infinity) value that is less than or equal to the argument and is equal to a mathematical integer.</P>
<P>
Special cases:</P>
<UL>
<LI>
 If the argument value is already equal to a mathematical integer, then the result is the same as the argument.</LI>
<LI>
 If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.</LI>
</UL>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Float:_int">int</A> :: <B><A class="tref" href="#Float">Float</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Math.round</SPAN></DT>
<DD class="func">
<P>
Returns the closest <A class="tref" href="#Int">Int</A> value to the argument. The result is rounded to an integer by adding 1/2, taking the <A class="fref" href="#Float:floor">Float.floor</A> of the result, and casting the result to type int.</P>
<P>
The following property holds:</P>
<PRE>
 (f &lt; Int.maxBound.float &amp;&amp; f &gt; Int.minBound.float) ==&gt;
   (f.int.float == (f + 0.5f).floor)</PRE>
<P>
Special cases:</P>
<UL>
<LI>
 If the argument is NaN, the result is 0. </LI>
<LI>
 If the argument is negative infinity or any value less than or equal to the value of <A class="fref" href="#Bounded_Int:minBound">Bounded_Int.minBound</A>, the result is equal to the value of <A class="fref" href="#Bounded_Int:minBound">Bounded_Int.minBound</A>.</LI>
<LI>
 If the argument is positive infinity or any value greater than or equal to the value of <A class="fref" href="#Bounded_Int:maxBound">Bounded_Int.maxBound</A>, the result is equal to the value of <A class="fref" href="#Bounded_Int:maxBound">Bounded_Int.maxBound</A>.</LI>
</UL>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Immutable"> </A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="data">
<P>
Some native values can be detached from the stateful realm so as to make it possible to apply them to pure (native) functions, see <A class="tref" href="#Freezable">Freezable</A>.</P>
<P>
Such values will have <A class="tref" href="#Immutable">Immutable</A> as last type argument.</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Immutable">Immutable</A> </SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Int"> </A> <A class="tref" href="#Int">Int</A> = <B>native </B>int</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#Int">Int</A> values are based on Java's primitive <SPAN CLASS="code">int</SPAN> values.</P>
<P>
The existence of this type is assumed in numerous places in the compiler.</P>
<P>
Like with all <SPAN CLASS="code">native</SPAN> Java types, be they primitive or reference types, Frege holds the raw <SPAN CLASS="code">int</SPAN> in boxed form. However, in certain cases the compiler will optimize the boxing away:</P>
<UL>
<LI>
 Strict variables or function arguments work with the unboxed value directly. </LI>
<LI>
 Functions with a <SPAN CLASS="code">native</SPAN> return type generally return the unboxed value. Polymorphic data structures or functions always work with boxed values. Thus, for example, the function</LI>
</UL>
<PRE>
 sum a b c = a + b + c</PRE>
<P>
can compute the sum of 3 <A class="tref" href="#Int">Int</A>s, <A class="tref" href="#Long">Long</A>s, <A class="tref" href="#Double">Double</A>s or any other values of a type that is an instance of type class <A class="tref" href="#Num">Num</A>, but it may be somewhat slower than functions spezialized for a given type.</P>
<P>
According to the Java Language Specification, <SPAN CLASS="code">int</SPAN> values are 32 bit wide signed two's complement integers (§4.2). Java operations on <SPAN CLASS="code">int</SPAN> do not indicate overflow or underflow in any way (§4.2.2). Instead, just the low 32 bits of every result are retained.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Int:_char">char</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Char">Char</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>(char)</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">i.char</SPAN> returns the <A class="tref" href="#Char">Char</A> value whose ordinal number is <SPAN CLASS="code">i</SPAN></P>
<P>
Result is only valid for integers in the range 0..65535</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Int:_double">double</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Double.valueOf</SPAN></DT>
<DD class="func">
<P>
convert an <A class="tref" href="#Int">Int</A> to a <A class="tref" href="#Double">Double</A>, i.e. <SPAN CLASS="code">2.double == 2.0</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Int:_float">float</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Float.valueOf</SPAN></DT>
<DD class="func">
<P>
convert an <A class="tref" href="#Int">Int</A> to a <A class="tref" href="#Float">Float</A>, i.e. <SPAN CLASS="code">2.float == 2.0f</SPAN>.</P>
<P>
For large integers, the result may have been be rounded.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Int:_long">long</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Long.valueOf</SPAN></DT>
<DD class="func">
<P>
Convert an <A class="tref" href="#Int">Int</A> to a <A class="tref" href="#Long">Long</A>, i.e. <SPAN CLASS="code">2.long == 2L</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Int:toHexString">toHexString</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Integer.toHexString</SPAN></DT>
<DD class="func">
<P>
convert to a hexadecimal string</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="IntArray"> </A> <A class="tref" href="#IntArray">IntArray</A> s = <B>native </B>int[]</SPAN></DT>
<DD class="data">
<P>
native array of primitive int</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:elemAt">elemAt</A> :: <B><A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.rt.Boxed.Int.arrayGet</SPAN></DT>
<DD class="func">
<P>
get element at index from an immutable array</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:fromInxList">fromInxList</A> :: [(<A class="tref" href="#Int">Int</A>, <A class="tref" href="#Int">Int</A>)] -&gt; <A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
Create an immutable int array from list of tuples.</P>
<P>
The first component of each tuple gives the index, the second one is the value. Array elements not mentioned in the list will be 0.</P>
<PRE>
 (IntArr.fromList [(7,42)]).toList == [0,0,0,0,0,0,0,42]</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:fromInxListST">fromInxListST</A> :: <B>forall</B> a.[(<A class="tref" href="#Int">Int</A>, <A class="tref" href="#Int">Int</A>)] -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#IntArray">IntArray</A> a)</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:fromList">fromList</A> :: [<A class="tref" href="#Int">Int</A>] -&gt; <A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
create an immutable int array from a list</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:fromListST">fromListST</A> :: <B>forall</B> a.[<A class="tref" href="#Int">Int</A>] -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#IntArray">IntArray</A> a)</SPAN></DT>
<DD class="func">
<P>
create a mutable int array from a list</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:frozenGetAt">frozenGetAt</A> :: <B><A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.rt.Boxed.Int.arrayGet</SPAN></DT>
<DD class="func">
<P>
get element at index from an immutable array</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:getAt">getAt</A> :: <B>forall</B> s.<B><A class="tref" href="#IntArray">IntArray</A> s</B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>frege.rt.Boxed.Int.arrayGet</SPAN></DT>
<DD class="func">
<P>
get element at index from a mutable array</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:length">length</A> :: <B><A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.rt.Boxed.Int.arrayLen</SPAN></DT>
<DD class="func">
<P>
get the length of the array</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:_new">new</A> :: <B>forall</B> s.<B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#IntArray">IntArray</A> s)&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>frege.rt.Boxed.Int.arrayNew</SPAN></DT>
<DD class="func">
<P>
make a new mutable array of given size</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:setAt">setAt</A> :: <B>forall</B> s.<B><A class="tref" href="#IntArray">IntArray</A> s</B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>frege.rt.Boxed.Int.arraySet</SPAN></DT>
<DD class="func">
<P>
set element at index</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="IntArray:toList">toList</A> :: <B><A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; [<A class="tref" href="#Int">Int</A>]</SPAN></DT>
<DD class="func">
<P>
convert immutable array to list</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Integer"> </A> <A class="tref" href="#Integer">Integer</A> = <B>native </B>java.math.BigInteger</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#Integer">Integer</A> is a type for integer numbers of unlimited size, It has instances for <A class="tref" href="#Eq">Eq</A>, <A class="tref" href="#Ord">Ord</A>, <SPAN CLASS="unknown">Show</SPAN> and <A class="tref" href="#Integral">Integral</A>.</P>
<P>
This is derived from <SPAN CLASS="code">java.math.BigInteger</SPAN>.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Integer:bitLength">bitLength</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>bitLength</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integer:compareTo">compareTo</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>compareTo</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integer:_int">int</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>intValue</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integer:_long">long</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>longValue</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integer:nMod">nMod</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>mod</SPAN></DT>
<DD class="func">
<P>
<I>Warning</I>! Throws <SPAN CLASS="code">ArithmeticException</SPAN> when divisor is negative.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integer:ten">ten</A> :: <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.math.BigInteger.TEN</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integer:toString">toString</A> :: <B><A class="tref" href="#Integer">Integer</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>toString</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Integer:valueOf">valueOf</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.math.BigInteger.valueOf</SPAN></DT>
<DD class="func">
<P>
construction from a <A class="tref" href="#Long">Long</A>, see also <A class="fref" href="#String:aton">String.aton</A> and <A class="fref" href="#String:integer">String.integer</A></P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="JBoolean"> </A> <A class="tref" href="#JBoolean">JBoolean</A> = <B>native </B>java.lang.Boolean</SPAN></DT>
<DD class="data">
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="JByte"> </A> <A class="tref" href="#JByte">JByte</A> = <B>native </B>java.lang.Byte</SPAN></DT>
<DD class="data">
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="JChar"> </A> <A class="tref" href="#JChar">JChar</A> = <B>native </B>java.lang.Character</SPAN></DT>
<DD class="data">
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="JDouble"> </A> <A class="tref" href="#JDouble">JDouble</A> = <B>native </B>java.lang.Double</SPAN></DT>
<DD class="data">
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="JException"> </A> <A class="tref" href="#JException">JException</A> = <B>native </B>java.lang.Exception</SPAN></DT>
<DD class="data">
<P>
Frege wrapper for java exceptions.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="JException:catched">catched</A> :: <B><A class="tref" href="#JException">JException</A></B> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
give the name of this exception</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="JException:getClass">getClass</A> :: <B><A class="tref" href="#JException">JException</A></B> -&gt; <A class="tref" href="#Class">Class</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>getClass</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="JException:getLocalizedMessage">getLocalizedMessage</A> :: <B><A class="tref" href="#JException">JException</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>getLocalizedMessage</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="JException:getMessage">getMessage</A> :: <B><A class="tref" href="#JException">JException</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>getMessage</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="JFloat"> </A> <A class="tref" href="#JFloat">JFloat</A> = <B>native </B>java.lang.Float</SPAN></DT>
<DD class="data">
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="JInteger"> </A> <A class="tref" href="#JInteger">JInteger</A> = <B>native </B>java.lang.Integer</SPAN></DT>
<DD class="data">
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="JLong"> </A> <A class="tref" href="#JLong">JLong</A> = <B>native </B>java.lang.Long</SPAN></DT>
<DD class="data">
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="JShort"> </A> <A class="tref" href="#JShort">JShort</A> = <B>native </B>java.lang.Short</SPAN></DT>
<DD class="data">
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Long"> </A> <A class="tref" href="#Long">Long</A> = <B>native </B>long</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#Long">Long</A> values are based on Java's primitive <SPAN CLASS="code">long</SPAN> values.</P>
<P>
According to the Java Language Specification, <SPAN CLASS="code">long</SPAN> values are 64 bit wide signed two's complement integers (§4.2). Java operations on <SPAN CLASS="code">long</SPAN> do not indicate overflow or underflow in any way (§4.2.2). Instead, just the low 64 bits of every result are retained.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Long:_double">double</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Double.valueOf</SPAN></DT>
<DD class="func">
<P>
Convert an <A class="tref" href="#Long">Long</A> to a <A class="tref" href="#Double">Double</A>, i.e. <SPAN CLASS="code">42L.double == 42.0</SPAN>.</P>
<P>
For large numbers, the result may have been be rounded.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Long:_float">float</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Float.valueOf</SPAN></DT>
<DD class="func">
<P>
Convert an <A class="tref" href="#Long">Long</A> to a <A class="tref" href="#Float">Float</A>, i.e. <SPAN CLASS="code">42L.float == 42.0f</SPAN>.</P>
<P>
For large numbers, the result may have been be rounded.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Long:_int">int</A> :: <B><A class="tref" href="#Long">Long</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>(int)</SPAN></DT>
<DD class="func">
<P>
Uses a java cast to convert a <A class="tref" href="#Long">Long</A> to an <A class="tref" href="#Int">Int</A>. This is a <I>narrowing primitive conversion</I> in java parlance.</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Matcher"> </A> <A class="tref" href="#Matcher">Matcher</A> = <B>native </B>java.util.regex.Matcher</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#Matcher">Matcher</A> values are based on Java's <SPAN CLASS="code">java.util.regex.Matcher</SPAN> objects. Code generation relies on the existence of this type and its operations.</P>
<P>
The native <A class="tref" href="#Matcher">Matcher</A> functions that correspond to java methods of the <SPAN CLASS="code">java.util.regex.Matcher</SPAN> class that modify the state of the object they are invoked on (<A class="fref" href="#Matcher:find">Matcher.find</A>, <A class="fref" href="#Matcher:matches">Matcher.matches</A>, <A class="fref" href="#Matcher:replaceFirst">Matcher.replaceFirst</A>, <A class="fref" href="#Matcher:replaceAll">Matcher.replaceAll</A>, <A class="fref" href="#Matcher:usePattern">Matcher.usePattern</A>, <A class="fref" href="#Matcher:useAnchoringBounds">Matcher.useAnchoringBounds</A>) are implemented so that they make a copy of the <A class="tref" href="#Matcher">Matcher</A> and invoke the impure java method on the copy.</P>
<P>
Frege <A class="tref" href="#Matcher">Matcher</A>s can thus be regarded as read-only values and the functions defined here as pure. If you need to pass a <A class="tref" href="#Matcher">Matcher</A> to other native functions, be sure that the function is pure. If it is not because it would modify the matcher, and you do not need the match result, always pass a clone of the Matcher (see <A class="fref" href="#Matcher:clone">Matcher.clone</A>)</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:clone">clone</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Matcher">Matcher</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.clone</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:end">end</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>end</SPAN></DT>
<DD class="func">
<P>
Returns the offset after the last character of the subsequence captured by the given group during the previous match operation where group 0 denotes the entire pattern.</P>
<P>
If the specified capturing group failed to match, the return value will be -1.</P>
<P>
The follwoing property holds:</P>
<PRE>
 (m.group n == Nothing) ==&gt; (m.end n &lt; 0)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:find">find</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#Matcher">Matcher</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.find</SPAN></DT>
<DD class="func">
<P>
Tries a match and if it succeeds, returns <SPAN CLASS="code">Just m</SPAN>, where <SPAN CLASS="code">m</SPAN> is a new <A class="tref" href="#Matcher">Matcher</A> that contains the result. If there is no match, <SPAN CLASS="code">Nothing</SPAN> is returned.</P>
<P>
The following java fragment appends all matched substrings of a string:</P>
<PRE>
 String s = "cats and dogs are not concatenated.";
 Pattern p = Pattern.compile("cat|dog");
 String result = "";
 Matcher m = p.matcher(s);
 while (m.find()) result += m.group(0);  // "catdogcat"</PRE>
<P>
The follwoing frege fragment computes the same result:</P>
<PRE>
 result = loop m "" where
      s = "cats and dogs are not concatenated."
      p = #cat|dog#
      m = p.matcher s
      loop :: Matcher -&gt; String -&gt; String
      loop m1 r | Just m2 &lt;- m1.find = loop m2 (r++m2.match)
                | otherwise = r</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:group">group</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>group</SPAN></DT>
<DD class="func">
<P>
Retrieves the input subsequence captured by the given group during the previous match operation.</P>
<P>
Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression <SPAN CLASS="code">(m.group 0)</SPAN> retrieves that portion of the input string that was matched by the pattern.</P>
<P>
If the match was successful but the group specified failed to match any part of the input sequence, then <A class="fref" href="#Maybe:Nothing">Maybe.Nothing</A> is returned. Note that some groups, for example <SPAN CLASS="code">(a?)</SPAN>, match the empty string. This functon will return <SPAN CLASS="code">Just ""</SPAN> when such a group successfully matches the empty string in the input.</P>
<P>
The folloing property holds for a <A class="tref" href="#Matcher">Matcher</A> <I>m</I> with input sequence <I>s</I> and group index <I>g</I>:</P>
<PRE>
 isJust (m.group g) ==&gt; (m.group g) == Just (s.substr (m.start g) (m.end g))</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:match">match</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>group</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">Matcher.match m</SPAN> returns the input subsequence matched by the previous match. The result is <A class="fref" href="#undefined">undefined</A> if the last match was not successful.</P>
<P>
For a <A class="tref" href="#Matcher">Matcher</A> <SPAN CLASS="code">m</SPAN> with input sequence <SPAN CLASS="code">s</SPAN>, the following holds:</P>
<PRE>
 isJust (m.group 0) ==&gt; unJust (m.group 0) == m.match</PRE>
<P>
Note that some patterns, for example <SPAN CLASS="code">a?</SPAN>, match the empty string. This method will return the empty string when the pattern successfully matches the empty string in the input.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:matches">matches</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#Matcher">Matcher</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.matches</SPAN></DT>
<DD class="func">
<P>
Tries to match the entire string and returns <SPAN CLASS="code">Just m</SPAN> on success and otherwise <SPAN CLASS="code">Nothing</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:replaceAll">replaceAll</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.replaceAll</SPAN></DT>
<DD class="func">
<P>
Like <A class="fref" href="#Matcher:replaceFirst">Matcher.replaceFirst</A>, but replaces all matches.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:replaceFirst">replaceFirst</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.replaceFirst</SPAN></DT>
<DD class="func">
<P>
Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string.</P>
<P>
This method scans the input sequence from the start looking for a match of the pattern. Characters that are not part of the match are appended directly to the result string; the match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences.</P>
<P>
Note that backslashes (\\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.</P>
<P>
Given the regular expression <SPAN CLASS="code">#dog#</SPAN>, the input <SPAN CLASS="code">"zzzdogzzzdogzzz"</SPAN>, and the replacement string <SPAN CLASS="code">"cat"</SPAN>, an invocation of this function on a matcher for that expression would yield the string <SPAN CLASS="code">"zzzcatzzzdogzzz"</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:start">start</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>start</SPAN></DT>
<DD class="func">
<P>
Returns the start index of the subsequence captured by the given group during the previous match operation where group 0 denotes the entire pattern.</P>
<P>
If the specified capturing group failed to match, the return value will be -1.</P>
<P>
The follwoing property holds:</P>
<PRE>
 (m.group n == Nothing) ==&gt; (m.start n &lt; 0)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:toString">toString</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>toString</SPAN></DT>
<DD class="func">
<P>
Returns the string representation of this matcher. The string representation of a <A class="tref" href="#Matcher">Matcher</A> contains information that may be useful for debugging. The exact format is unspecified.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:useAnchoringBounds">useAnchoringBounds</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Matcher">Matcher</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.useAnchoringBounds</SPAN></DT>
<DD class="func">
<P>
Requires or forbids the matcher to acknowledge anchors.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:usePattern">usePattern</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Matcher">Matcher</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.usePattern</SPAN></DT>
<DD class="func">
<P>
Makes a new <A class="tref" href="#Matcher">Matcher</A> and causes it to use a different <A class="tref" href="#Regex">Regex</A> for future matches.</P>
<P>
The original matchers position in the input and its last append position is copied, but information about the last match, if any, is not.</P>
<P>
This is most useful with patterns that start with the <SPAN CLASS="code">\\G</SPAN> anchor.</P>
<P>
Note that, due to a java bug, if the last find operation matched the empty string, the next find will fail. For a workaround see <A class="fref" href="#Matcher:usePatternAndFind">Matcher.usePatternAndFind</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Matcher:usePatternAndFind">usePatternAndFind</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#Matcher">Matcher</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.usePatternAndFind</SPAN></DT>
<DD class="func">
<P>
Makes a new <A class="tref" href="#Matcher">Matcher</A> with a different <A class="tref" href="#Regex">Regex</A> and tries to find a match. If the last find on the original Matcher returned an empty result, it calls <SPAN CLASS="code">mnew.find(morig.end(0))</SPAN> to work around a bug in the java API. Therefore, this function must only be used on a matcher whose last match attempt was successful.</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Maybe"> </A> <A class="tref" href="#Maybe">Maybe</A> a</SPAN></DT>
<DD class="data">
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Just">Just</A> a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Nothing">Nothing</A> </SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Ordering"> </A> <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="data">
<P>
The type of the result of <A class="fref" href="#Ord:_lt_eq_gt">Ord.&lt;=&gt;</A></P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Eq">Eq</A> </SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Gt">Gt</A> </SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Lt">Lt</A> </SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="RealWorld"> </A> <A class="tref" href="#RealWorld">RealWorld</A></SPAN></DT>
<DD class="data">
<P>
This abstract data type identifies the global state (disk, network, you name it). Values of type <A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A> <SPAN CLASS="code">a</SPAN> are likely to perform input/output, manipulate global data and so on.</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="RealWorld">RealWorld</A> </SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Regex"> </A> <A class="tref" href="#Regex">Regex</A> = <B>native </B>java.util.regex.Pattern</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#Regex">Regex</A> values are based on Java's <SPAN CLASS="code">java.util.regex.Pattern</SPAN> objects. All regular expression literals are values of this type.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Regex:matcher">matcher</A> :: <B><A class="tref" href="#Regex">Regex</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Matcher">Matcher</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>matcher</SPAN></DT>
<DD class="func">
<P>
create a <A class="tref" href="#Matcher">Matcher</A> from a regular expression and a <A class="tref" href="#String">String</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Regex:pattern">pattern</A> :: <B><A class="tref" href="#Regex">Regex</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>pattern</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Regex:split">split</A> :: <B><A class="tref" href="#Regex">Regex</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>split</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Regex:splitted">splitted</A> :: <B><A class="tref" href="#Regex">Regex</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; [<A class="tref" href="#String">String</A>]</SPAN></DT>
<DD class="func">
<P>
Split a string around matches of a regular expression and return the result as list of strings.</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="ST"> </A> <A class="tref" href="#ST">ST</A> s a</SPAN></DT>
<DD class="data">
<P>
<SPAN CLASS="code">(ST s a)</SPAN> is an abstract data type and is a computation that encapsulates side effects in state thread <SPAN CLASS="code">s</SPAN> and returns a value of type <SPAN CLASS="code">a</SPAN>.</P>
<P>
The type <SPAN CLASS="code">s</SPAN> can be understood as a compiler generated unique index for state threads. Every state thread is independend of each other and keeps track of mutable variables created in it. For detailed information, read the paper "Lazy Functional State Threads".</P>
<P>
Every mutable native data type will have a phantom type paramter <SPAN CLASS="code">s</SPAN> that tells to what state thread the value belongs. For example, the <SPAN CLASS="code">new</SPAN> method of the java class <SPAN CLASS="code">java.util.Date</SPAN> could be accessed like this:</P>
<PRE>
 data Date s = native java.util.Date where
     native new :: () -&gt; ST s (Date s)</PRE>
<P>
Inside ST actions, Date values can be created and manipulated with impure native methods at will. However, such a value can never escape its ST thread.</P>
<P>
Because <SPAN CLASS="code">ST s</SPAN> is an instance of <A class="tref" href="#Monad">Monad</A>, ST actions can be combined, which ensures sequenced execution. For example, we could add another method to the Date type that converts the date to a string:</P>
<PRE>
     native toString :: Date s -&gt; ST s String</PRE>
<P>
and a computation which yields the current time in string form:</P>
<PRE>
 now = do
    date &lt;- Date.new ()
    return date.toString</PRE>
<P>
This looks almost like java already! <SPAN CLASS="code">now</SPAN> has type <SPAN CLASS="code">ST s String</SPAN> and we can run the computation with <SPAN CLASS="code">now.run</SPAN> (see <A class="fref" href="#ST:run">ST.run</A> below), which gives us a nice, pure, immutable, functional correct <A class="tref" href="#String">String</A> value.</P>
<P>
The <A class="tref" href="#IO">IO</A> type is just an alias for <A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A>, and can be thought of as indexing the global state thread. Values of type <A class="tref" href="#IO">IO</A> <SPAN CLASS="code">a</SPAN> are also called  <I>IO actions</I>.</P>
<P>
Any ST value can also be used in the IO thread.</P>
<P>
This guarantees that</P>
<UL>
<LI>
 any computation with side effect is sequenced through the ST-Monad </LI>
<LI>
 any function whose return type is not <SPAN CLASS="code">IO something</SPAN> does not have side effects, as long as no impure native function or value is deliberately declared to be pure.</LI>
</UL>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="ST">ST</A> (s-&gt;a)</SPAN></DT>
<DD class="func">
</DD>
</DL>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="ST:bind">bind</A> :: <B>forall</B> y x z.(<B>x-&gt;y</B>) -&gt; (<B>y-&gt;<A class="tref" href="#ST">ST</A> x z</B>) -&gt; x -&gt; z</SPAN></DT>
<DD class="func">
<P>
The function that does the real work for <A class="fref" href="#Monad_ST:_gt_gt_eq">Monad_ST.&gt;&gt;=</A></P>
<P>
It is defined public in order to make inlining possible</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="ST:performUnsafe">performUnsafe</A> :: <B>forall</B> a.<B><A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A> a</B> -&gt; a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="ST:run">run</A> :: <B>forall</B> a.(<B><B>forall</B> r.<A class="tref" href="#ST">ST</A> r a</B>) -&gt; a</SPAN></DT>
<DD class="func">
<P>
Run a stateful action with type <SPAN CLASS="code">ST r a</SPAN></P>
<P>
This is possible only if the result type <SPAN CLASS="code">a</SPAN> of the state action does <B>not</B> mention <SPAN CLASS="code">r</SPAN> and if <SPAN CLASS="code">r</SPAN> is a type variable.</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="STArray"> </A> <A class="tref" href="#STArray">STArray</A> elem s = <B>native </B>frege.rt.Array</SPAN></DT>
<DD class="data">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="STArray:elemAt">elemAt</A> :: <B>forall</B> s elem.<B><A class="tref" href="#STArray">STArray</A> elem s</B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s elem&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>getAt</SPAN></DT>
<DD class="func">
<P>
Fetch array element  <B>without</B> checking for <SPAN CLASS="code">null</SPAN> value.</P>
<P>
To be used only when it is sure that there are no <SPAN CLASS="code">null</SPAN> values in the array.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:fromInxList">fromInxList</A> :: <B>forall</B> a.[(<A class="tref" href="#Int">Int</A>, a)] -&gt; <A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
create immutable array using frozen result of <A class="fref" href="#STArray:fromInxListST">STArray.fromInxListST</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:fromInxListST">fromInxListST</A> :: <B>forall</B> s a.[(<A class="tref" href="#Int">Int</A>, a)] -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#STArray">STArray</A> a s)</SPAN></DT>
<DD class="func">
<P>
Create a mutable array from a list of tuples (<A class="tref" href="#Int">Int</A>, a). The size of the array will be so that it can accomodate the greatest index. Elements whose index does not appear in the list reamin unset, i.e. they are initialised with the null value.</P>
<P>
Negative indexes cause java exceptions to be thrown.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:fromList">fromList</A> :: <B>forall</B> a.[a] -&gt; <A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
create an immutable arra from a list</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:fromListST">fromListST</A> :: <B>forall</B> u elem.[elem] -&gt; <A class="tref" href="#ST">ST</A> u (<A class="tref" href="#STArray">STArray</A> elem u)</SPAN></DT>
<DD class="func">
<P>
Create array from (finite) list.</P>
<P>
The resulting Array does not contain null values</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:frozenElemAt">frozenElemAt</A> :: <B>forall</B> elem.<B><A class="tref" href="#STArray">STArray</A> elem <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; elem&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>getAt</SPAN></DT>
<DD class="func">
<P>
Fetch array element from a frozen array <B>without</B> checking for <SPAN CLASS="code">null</SPAN> value.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:frozenGetAt">frozenGetAt</A> :: <B>forall</B> elem.<B><A class="tref" href="#STArray">STArray</A> elem <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> elem&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>getAt</SPAN></DT>
<DD class="func">
<P>
Fetch array element form a frozen array</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:getAt">getAt</A> :: <B>forall</B> s elem.<B><A class="tref" href="#STArray">STArray</A> elem s</B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#Maybe">Maybe</A> elem)&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>getAt</SPAN></DT>
<DD class="func">
<P>
Fetch array element and return <SPAN CLASS="code">Just v</SPAN>, if it is not a null value, otherwise <SPAN CLASS="code">Nothing</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:length">length</A> :: <B>forall</B> elem x.<B><A class="tref" href="#STArray">STArray</A> elem x</B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>length</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:_new">new</A> :: <B>forall</B> elem s.<B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#STArray">STArray</A> elem s)&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>new</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:setAt">setAt</A> :: <B>forall</B> s elem.<B><A class="tref" href="#STArray">STArray</A> elem s</B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; elem -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>setAt</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:setAtMB">setAtMB</A> :: <B>forall</B> s elem.<B><A class="tref" href="#STArray">STArray</A> elem s</B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> elem -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>setAt</SPAN></DT>
<DD class="func">
<P>
set array element to value v when passed <SPAN CLASS="code">(Just v)</SPAN> or null (Nothing)</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:toInxList">toInxList</A> :: <B>forall</B> a.<B><A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A></B> -&gt; [(<A class="tref" href="#Int">Int</A>, a)]</SPAN></DT>
<DD class="func">
<P>
Extract all non null elements from an immutable array, togehther with their indexes. For arrays whose last element is not null, the following holds:</P>
<PRE>
 fromInxList (toInxList arr) == arr</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STArray:toList">toList</A> :: <B>forall</B> a.<B><A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A></B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
Collect non-null elements from an immutable array.</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="STRef"> </A> <A class="tref" href="#STRef">STRef</A> a s = <B>native </B>frege.rt.Ref</SPAN></DT>
<DD class="data">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="STRef:get">get</A> :: <B>forall</B> s a.<B><A class="tref" href="#STRef">STRef</A> a s</B> -&gt; <A class="tref" href="#ST">ST</A> s a&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>get</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STRef:_new">new</A> :: <B>forall</B> a s.<B>a</B> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#STRef">STRef</A> a s)&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>new</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="STRef:put">put</A> :: <B>forall</B> s a.<B><A class="tref" href="#STRef">STRef</A> a s</B> -&gt; a -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>put</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="State"> </A> <A class="tref" href="#State">State</A> s a</SPAN></DT>
<DD class="data">
<P>
<SPAN CLASS="code">State s a</SPAN> is an abstrac data type that resembles a stateful computation with state <I>s</I> and result <I>a</I>, i.e. functions of type <SPAN CLASS="code">s -&gt; (a, s)</SPAN> where the state is immutable</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="State">State</A> (s-&gt;(a, s))</SPAN></DT>
<DD class="func">
</DD>
</DL>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="State:bind">bind</A> :: <B>forall</B> b a s.(<B>s-&gt;(a, s)</B>) -&gt; (<B>a-&gt;<A class="tref" href="#State">State</A> s b</B>) -&gt; s -&gt; (b, s)</SPAN></DT>
<DD class="func">
<P>
The function that does the real work for <A class="fref" href="#Monad_State:_gt_gt_eq">Monad_State.&gt;&gt;=</A></P>
<P>
It is defined public in order to make inlining possible</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="State:change">change</A> :: <B>forall</B> a.(a-&gt;a) -&gt; <A class="tref" href="#State">State</A> a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
change the state</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="State:get">get</A> :: <B>forall</B> a.<A class="tref" href="#State">State</A> a a</SPAN></DT>
<DD class="func">
<P>
get the current state from inside the state monad</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="State:put">put</A> :: <B>forall</B> a.<B>a</B> -&gt; <A class="tref" href="#State">State</A> a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
update the state in the state monad</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="State:run">run</A> :: <B>forall</B> a b.<B><A class="tref" href="#State">State</A> a b</B> -&gt; a -&gt; (b, a)</SPAN></DT>
<DD class="func">
<P>
run a stateful computation</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="String"> </A> <A class="tref" href="#String">String</A> = <B>native </B>java.lang.String</SPAN></DT>
<DD class="data">
<P>
<A class="tref" href="#String">String</A> values are based on Java's <SPAN CLASS="code">java.lang.String</SPAN> objects.</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="String:atod">atod</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Double.parseDouble</SPAN></DT>
<DD class="func">
<P>
Like <A class="fref" href="#String:_double">String.double</A>, but the exception is not checked, thus only good when one <B>knows for sure</B> that the parse will succeed. </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:atof">atof</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Float.parseFloat</SPAN></DT>
<DD class="func">
<P>
Like <A class="fref" href="#String:_float">String.float</A>, but the exception is not checked, thus only good when one <B>knows for sure</B> that the parse will succeed. </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:atoi">atoi</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Integer.parseInt</SPAN></DT>
<DD class="func">
<P>
Like <A class="fref" href="#String:_int">String.int</A>, but the exception is not checked, thus only good when one <B>knows for sure</B> that the parse will succeed. </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:atol">atol</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Long.parseLong</SPAN></DT>
<DD class="func">
<P>
Like <A class="fref" href="#String:_long">String.long</A>, but the exception is not checked, thus only good when one <B>knows for sure</B> that the parse will succeed. </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:aton">aton</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>new</SPAN></DT>
<DD class="func">
<P>
Like <A class="fref" href="#String:integer">String.integer</A>, but the exception is not checked, thus only good when one <B>knows for sure</B> that the parse will succeed. </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:charAt">charAt</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Char">Char</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>charAt</SPAN></DT>
<DD class="func">
<P>
retrieve character at index</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:compareTo">compareTo</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>compareTo</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:compareTo">String.compareTo</A> is used in the <A class="tref" href="#Ord">Ord</A> instance of <A class="tref" href="#String">String</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:compile">compile</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Regex">Regex</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.util.regex.Pattern.compile</SPAN></DT>
<DD class="func">
<P>
interpret this string as regex (unsafe, does not catch exceptions)</P>
<P>
see <A class="fref" href="#regcomp">regcomp</A> for an alternative</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:_double">double</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Double">Double</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Double.parseDouble</SPAN></DT>
<DD class="func">
<P>
Safe way to parse a <A class="tref" href="#Double">Double</A> value from a string. See <A class="fref" href="#String:_int">String.int</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:elemAt">elemAt</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Char">Char</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>charAt</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:_float">float</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Float">Float</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Float.parseFloat</SPAN></DT>
<DD class="func">
<P>
Safe way to parse a <A class="tref" href="#Float">Float</A> value from a string. See <A class="fref" href="#String:_int">String.int</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:frozenGetAt">frozenGetAt</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Char">Char</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>charAt</SPAN></DT>
<DD class="func">
<P>
Get character at index.</P>
<P>
This will allow to use a string like an array, e.g. <SPAN CLASS="code">"xyz".[1]</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:hashCode">hashCode</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>hashCode</SPAN></DT>
<DD class="func">
<P>
get the has code</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:_int">int</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Integer.parseInt</SPAN></DT>
<DD class="func">
<P>
Safe way to parse an integer from a string. <SPAN CLASS="code">java.lang.NumberFormatException</SPAN> will be catched and returned as <A class="fref" href="#Either:Left">Either.Left</A> value. When the parse succeeds, the integer is returned in the <A class="fref" href="#Either:Right">Either.Right</A> value.</P>
<P>
Use like this:</P>
<PRE>
 case s.int of
   Left exc -&gt; ... // s is not well formed
   Right i  -&gt; ... // the parsed value is in i</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:integer">integer</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Integer">Integer</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>new</SPAN></DT>
<DD class="func">
<P>
Safe way to parse a big <A class="tref" href="#Integer">Integer</A> value from a string. See <A class="fref" href="#String:_int">String.int</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:_long">long</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Long">Long</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Long.parseLong</SPAN></DT>
<DD class="func">
<P>
Safe way to parse a long integer from a string. See <A class="fref" href="#String:_int">String.int</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:quote">quote</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.util.regex.Pattern.quote</SPAN></DT>
<DD class="func">
<P>
quote regular expression metacharacters in string</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:quoteReplacement">quoteReplacement</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.util.regex.Matcher.quoteReplacement</SPAN></DT>
<DD class="func">
<P>
quote replacement string metacharacters in string</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:toLowerCase">toLowerCase</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>toLowerCase</SPAN></DT>
<DD class="func">
<P>
convert to lower case</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="String:toUpperCase">toUpperCase</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>toUpperCase</SPAN></DT>
<DD class="func">
<P>
convert to upper case</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="StringArray"> </A> <A class="tref" href="#StringArray">StringArray</A> s = <B>native </B>java.lang.String[]</SPAN></DT>
<DD class="data">
<P>
native array of native strings</P>
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="StringArray:elemAt">elemAt</A> :: <B><A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.rt.Boxed.&lt;java.lang.String&gt;arrayGet</SPAN></DT>
<DD class="func">
<P>
use this only if it is absolutely sure that there are no nulls in the array</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="StringArray:fromList">fromList</A> :: [<A class="tref" href="#String">String</A>] -&gt; <A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="StringArray:fromListST">fromListST</A> :: <B>forall</B> u.[<A class="tref" href="#String">String</A>] -&gt; <A class="tref" href="#ST">ST</A> u (<A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="StringArray:frozenGetAt">frozenGetAt</A> :: <B><A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.rt.Boxed.&lt;java.lang.String&gt;arrayGet</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="StringArray:getAt">getAt</A> :: <B>forall</B> s.<B><A class="tref" href="#StringArray">StringArray</A> s</B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A>)&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>frege.rt.Boxed.&lt;java.lang.String&gt;arrayGet</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="StringArray:length">length</A> :: <B><A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.rt.Boxed.&lt;java.lang.String&gt;arrayLen</SPAN></DT>
<DD class="func">
<P>
the length of the array</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="StringArray:_new">new</A> :: <B>forall</B> s.<B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#StringArray">StringArray</A> s)&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>java.lang.String[]</SPAN></DT>
<DD class="func">
<P>
make a new mutable string array</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="StringArray:setAt">setAt</A> :: <B>forall</B> s.<B><A class="tref" href="#StringArray">StringArray</A> s</B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>frege.rt.Boxed.&lt;java.lang.String&gt;arraySet</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="StringArray:toList">toList</A> :: <B><A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A></B> -&gt; [<A class="tref" href="#String">String</A>]</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Undefined"> </A> <A class="tref" href="#Undefined">Undefined</A> = <B>native </B>frege.RT.Undefined</SPAN></DT>
<DD class="data">
<H3>
Member Functions</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Undefined:die">die</A> :: <B><A class="tref" href="#Undefined">Undefined</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>die</SPAN></DT>
<DD class="func">
<P>
Throw this <A class="tref" href="#Undefined">Undefined</A>, this will abort the computation evaluating it.</P>
<P>
Actually, the return type is not correct, since it never returns.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Undefined:_new">new</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Undefined">Undefined</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>new</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Undefined:newSX">newSX</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#JException">JException</A> -&gt; <A class="tref" href="#Undefined">Undefined</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>new</SPAN></DT>
<DD class="func">
<P>
create an <A class="tref" href="#Undefined">Undefined</A> value from a string and a cause</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Undefined:newX">newX</A> :: <B><A class="tref" href="#JException">JException</A></B> -&gt; <A class="tref" href="#Undefined">Undefined</A></SPAN></DT>
<DD class="func">
<P>
create an <A class="tref" href="#Undefined">Undefined</A> value from a <A class="tref" href="#JException">JException</A>. The message will be taken from the exception.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="Undefined:toException">toException</A> :: <B><A class="tref" href="#Undefined">Undefined</A></B> -&gt; <A class="tref" href="#JException">JException</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>(java.lang.Exception)</SPAN></DT>
<DD class="func">
<P>
convert an <A class="tref" href="#Undefined">Undefined</A> value to a <A class="tref" href="#JException">JException</A></P>
<P>
This is actually a no-op, since <SPAN CLASS="code">frege.RT.Undefined</SPAN> is a subclass of <SPAN CLASS="code">java.lang.Exception</SPAN>. However, the type checker knows nothing about subclasses.</P>
<P>
This function is used in the <SPAN CLASS="code">Monad (Exception a)</SPAN>.</P>
</DD>
</DL>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="Void"> </A> <A class="tref" href="#Void">Void</A> = <B>native </B>Void</SPAN></DT>
<DD class="data">
<P>
This is used in cases of higher order polymorphism to provide a provisonal type. For example:</P>
<PRE>
 f :: (forall a =&gt; [a] -&gt; [a]) -&gt; ([Bool],[Char])</PRE>
<P>
will extend java type</P>
<PRE>
 Fun1&lt;Fun&lt;Void, Void&gt;, Tuple2&lt;List&lt;Bool&gt;,List&lt;Char&gt;&gt;&gt;</PRE>
<P>
Whenever such a function is used, it must be coerced to the correct type.</P>
</DD>
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="List"> </A> [a]</SPAN></DT>
<DD class="data">
<P>
list type</P>
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="Cons">:</A> a&nbsp;&nbsp; [a]</SPAN></DT>
<DD class="func">
<P>
list construction</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="List">[]</A> </SPAN></DT>
<DD class="func">
<P>
empty list</P>
</DD>
</DL>
</DD>
</DL>
<H2>
<A name="let">Functions and Values</A></H2>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="_excl">!</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>!</SPAN></DT>
<DD class="func">
<P>
The Java <SPAN CLASS="code">!</SPAN> operator on booleans</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_excl_eq_eq">!==</A> :: <B>forall</B> a.<B>a</B> -&gt; a -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>!=</SPAN></DT>
<DD class="func">
<P>
This checks for object identity or inequality of primitive values using Java's <SPAN CLASS="code">!=</SPAN> operator. It evaluates its arguments, so undefined values cannot be compared. </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_excl_tilde">!~</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<PRE>
 s !~ p == !(s ~ p)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_dollar">$</A> :: <B>forall</B> a b.(<B>a-&gt;b</B>) -&gt; a -&gt; b</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">a $ b</SPAN> is the same as <SPAN CLASS="code">a b</SPAN>, but because of <A class="fref" href="#_dollar">$</A>'s low precedence one can write <SPAN CLASS="code">f $ x+y</SPAN> instead of <SPAN CLASS="code">f (x+y)</SPAN>. Also, becuase <A class="fref" href="#_dollar">$</A> is right associative, <SPAN CLASS="code">f $ g $ h y</SPAN> is <SPAN CLASS="code">f (g (h y))</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="$_excl">$!</A> :: <B>forall</B> a b.(<B>a-&gt;b</B>) -&gt; <B>a</B> -&gt; b</SPAN></DT>
<DD class="func">
<P>
Same as `$` but argument is strict</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_amp_amp">&amp;&amp;</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>&amp;&amp;</SPAN></DT>
<DD class="func">
<P>
The Java <SPAN CLASS="code">&amp;&amp;</SPAN> operator on booleans. Note that since this is a native function, the second argument appears strict to the frege compiler when in fact it is lazy at the Java level. This can lead to inconsistent results in some cases. For example, the following program correctly prints <SPAN CLASS="code">false</SPAN> in the first line of the output, but then aborts:</P>
<PRE>
 main _ = do
    stdout &lt;&lt; (false &amp;&amp; undefined) &lt;&lt; "\n"
    stdout &lt;&lt; conj false undefined &lt;&lt; "\n"
  where
    conj a b = a &amp;&amp; b</PRE>
<P>
Note that the very same behaviour is seen in the following java program</P>
<PRE>
 public class And {
    static boolean undef() {
        if (true) throw new Error("undefined");
        return false;
    }
    static boolean conj(boolean a, boolean b) { return a&amp;&amp;b; }
    public static void main(String[] args) {
        System.out.println(false &amp;&amp; undef());
        System.out.println(conj(false, undef()));
    }
 }</PRE>
<P>
One could thus say that <A class="fref" href="#_amp_amp">&amp;&amp;</A> behaves exactly like the Java operator including the fact that it cannot be replaced by a function without changing the semantics of a program.</P>
<P>
For an alternative see <A class="fref" href="#and">and</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_div_tilde">/~</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<PRE>
 m /~ p</PRE>
<P>
is like</P>
<PRE>
 m ?~ p</PRE>
<P>
but instead of the matcher it returns the matched string, if any.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_lt_tilde">&lt;~</A> :: <B>forall</B> a b c.(<B>b-&gt;a</B>) -&gt; (c-&gt;b) -&gt; c -&gt; a</SPAN></DT>
<DD class="func">
<P>
Function composition.</P>
<P>
<SPAN CLASS="code">(f &lt;~ g)</SPAN> is a function whose argument is passed to <I>g</I>, and the result to <I>f</I>, yielding the overall result.</P>
<P>
One can imagine that the data flow from right to left through a function pipe.</P>
<PRE>
 (a) &lt;~ (b)  = \x -&gt; a (b x)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_eq_eq_eq">===</A> :: <B>forall</B> a.<B>a</B> -&gt; a -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>==</SPAN></DT>
<DD class="func">
<P>
This checks for object identity or equality of primitive values using Java's <SPAN CLASS="code">==</SPAN> operator. It evaluates its arguments, so undefined values cannot be compared. </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_eq_tilde">=~</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#Matcher">Matcher</A></SPAN></DT>
<DD class="func">
<PRE>
 string =~ regex</PRE>
<P>
tries to match <I>string</I> against <I>regex</I> and returns <SPAN CLASS="code">Just matcher</SPAN> if it succeeds, <SPAN CLASS="code">Nothing</SPAN> otherwise.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_qm_tilde">?~</A> :: <B><A class="tref" href="#Matcher">Matcher</A></B> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#Matcher">Matcher</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">m ?~ p</SPAN> binds pattern <I>p</I> to the matcher <I>m</I> and tries a match. There must have been a successful match on <I>m</I> before.</P>
<P>
Returns <A class="fref" href="#Maybe:Nothing">Maybe.Nothing</A> if match fails, else (<A class="fref" href="#Maybe:Just">Maybe.Just</A> <SPAN CLASS="code">m</SPAN>).</P>
<P>
This function is most usefull in conjunction with patterns that use the G-anchor when one wants to extract multiple differnt adjacent items from a string. This is how the frege scanner is implemented.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_at">@</A> :: <B>forall</B> a b c.(<B>a-&gt;b</B>) -&gt; (c-&gt;a) -&gt; c -&gt; b</SPAN></DT>
<DD class="func">
<P>
In patterns, the @-operator is used to bind a name to a complex pattern</P>
<PRE>
 f (x@a:as) = e</PRE>
<P>
is the same as</P>
<PRE>
 f arg = case arg of { x -&gt; case x of { a:as -&gt; e }}</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="all">all</A> :: <B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">all p xs</SPAN> tells if all elements of <I>xs</I> have property <I>p</I>. This is equivalent to <SPAN CLASS="code">fold (&amp;&amp;) true (map p xs)</SPAN> except that <A class="fref" href="#all">all</A> stops at the first element that hasn't property <I>p</I>.</P>
<P>
Note that, according to the identity above, <SPAN CLASS="code">all p []</SPAN> is always <SPAN CLASS="code">true</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="and">and</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Like <A class="fref" href="#_amp_amp">&amp;&amp;</A>, but second argument is lazy. The <SPAN CLASS="code">`and`</SPAN> operator has the same precedence and arity as <A class="fref" href="#_amp_amp">&amp;&amp;</A>. The definition is</P>
<PRE>
 a `and` b = if a then b     else false</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="any">any</A> :: <B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">any p xs</SPAN> tells if any element of <I>xs</I> has property <I>p</I>. This is equivalent to <SPAN CLASS="code">fold (||) false (map p xs)</SPAN> except that <A class="fref" href="#any">any</A> stops at the first element that has property <I>p</I>.</P>
<P>
Note that, according to the identity above,  <SPAN CLASS="code">any p []</SPAN> is always <SPAN CLASS="code">false</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="ascending">ascending</A> :: <B>forall</B> a b.<A class="tref" href="#Ord">Ord</A> b =&gt; (a-&gt;b) -&gt; a -&gt; a -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
this is just an alias for <A class="fref" href="#comparing">comparing</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="atoi">atoi</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="chr">chr</A> :: <B><A class="tref" href="#Int">Int</A></B> -&gt; <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="comparing">comparing</A> :: <B>forall</B> a b.<A class="tref" href="#Ord">Ord</A> b =&gt; (a-&gt;b) -&gt; a -&gt; a -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">comparing f</SPAN> applies a proejction function on both sides of <A class="fref" href="#Ord:_lt_eq">Ord.&lt;=</A>. Example usage:</P>
<PRE>
 sortBy (comparing snd) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="concat">concat</A> :: <B>forall</B> a.<B>[[a]]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#concat">concat</A> concatenates the sublists of the argument which is a list of list. It is ok if the argument is an infinite list or any of the sublists is infinite. In either case, the result will also be infinite.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_const">const</A> :: <B>forall</B> a b.<B>a</B> -&gt; b -&gt; a</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">const a</SPAN> is a function that returns <I>a</I> regardless of its argument.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="constructor">constructor</A> :: <B>forall</B> a.<B>a</B> -&gt; <A class="tref" href="#Int">Int</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>frege.RT.constructor</SPAN></DT>
<DD class="func">
<P>
///////////////////////////////////////////////////////////////////</P>
<P>
Determines the constructor of a value. This is used like</P>
<PRE>
constructor arg</PRE>
<P>
where <SPAN CLASS="code">arg</SPAN> is any frege value.</P>
<P>
Returns 0 for product types and native types or the <I>constructor number</I> for constructed types. The <I>constructor number</I> is a small integer stored in every constructed value. It indicates by what data constructor a value was constructed.</P>
<P>
The compiler assigns constructor numbers starting from 0 to the constructors defined in a <SPAN CLASS="code">data</SPAN> definition in the order of their appearance.</P>
<P>
Examples</P>
<PRE>
constructor [] == 0
constructor (a:as) == 1
constructor "string"  == 0    // native value</PRE>
<P>
This function is strict in its argument, i.e.</P>
<PRE>
constructor undefined == undefined</PRE>
<P>
<B>Implementation specific:</B> This function is used in derived instances of <A class="tref" href="#Eq">Eq</A> and <A class="tref" href="#Ord">Ord</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="cstos">cstos</A> :: <B>[<A class="tref" href="#Char">Char</A>]</B> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="ctos">ctos</A> :: <B><A class="tref" href="#Char">Char</A></B> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.lang.Character.toString</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="curry">curry</A> :: <B>forall</B> a b c.(<B>b-&gt;a-&gt;c</B>) -&gt; (b, a) -&gt; c</SPAN></DT>
<DD class="func">
<P>
Passes the elements of a 2-tuple as arguments to a function.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="cycle">cycle</A> :: <B>forall</B> a.<B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">cycle xs</SPAN> builds an list that is an infinite repetition of <I>xs</I>, which must not be empty.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="descending">descending</A> :: <B>forall</B> a b.<A class="tref" href="#Ord">Ord</A> b =&gt; (a-&gt;b) -&gt; a -&gt; a -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">descending f</SPAN> applies a projection function on both sides of <A class="fref" href="#Ord:_gt_eq">Ord.&gt;=</A>. Example usage:</P>
<PRE>
 sortBy (descending fst) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="drop">drop</A> :: <B>forall</B> a.<B><A class="tref" href="#Int">Int</A></B> -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">drop n xs</SPAN> returns what remains from <I>xs</I> after the <I>n</I> leading elements have been dropped. If <I>n</I> is greater than the <A class="fref" href="#Length:length">Length.length</A> of <I>xs</I>, the result is the empty list.</P>
<P>
For negative <I>n</I>, the result is undefined.</P>
<P>
The following property holds for all lists <I>xs</I> and non negative <I>n</I>:</P>
<PRE>
 take n xs ++ drop n xs == xs</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="dropUntil">dropUntil</A> :: <B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">dropUntil p xs</SPAN> is the same as <SPAN CLASS="code">dropWhile (not • p) xs</SPAN></P>
<P>
Consequently, for all lists <I>xs</I></P>
<PRE>
 takeUntil p xs ++ dropUntil p xs == xs</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="dropWhile">dropWhile</A> :: <B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">dropWhile p xs</SPAN> drops leading elements from <I>xs</I> that satisfy the predicate <I>p</I>.</P>
<P>
The following holds for all lists <I>xs</I></P>
<PRE>
 takeWhile p xs ++ dropWhile p xs == xs</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="either">either</A> :: <B>forall</B> a b c.(b-&gt;a) -&gt; (c-&gt;a) -&gt; <B><A class="tref" href="#Either">Either</A> b c</B> -&gt; a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="elem">elem</A> :: <B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; a -&gt; [a] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">e `elem` xs</SPAN> is true if and only if at least one of the elements of <I>xs</I> equals <I>e</I>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="elemBy">elemBy</A> :: <B>forall</B> a b.(a-&gt;b-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; a -&gt; [b] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">elemBy f</SPAN> is a more general version of <A class="fref" href="#elem">elem</A> that uses <I>f</I> instead of <A class="fref" href="#Eq:_eq_eq">Eq.==</A>.</P>
<P>
See also: <A class="fref" href="#using">using</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="error">error</A> :: <B>forall</B> u.<B><A class="tref" href="#String">String</A></B> -&gt; u</SPAN></DT>
<DD class="func">
<P>
Construct an undefined value with an informative message.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="filter">filter</A> :: <B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">filter p xs</SPAN> returns the list of elements <I>x</I> from <I>xs</I> where (<I>p</I> <I>x</I>) holds.</P>
<P>
<A class="fref" href="#filter">filter</A> will not stop to evaluate its argument list until the first element with the property asked for is found. For example</P>
<PRE>
 filter (==true) (repeat false)</PRE>
<P>
will loop forever, whereas</P>
<PRE>
 filter iseven (iterate succ 1n) where iseven n = n `band` 1n == 0n</PRE>
<P>
will faithfully deliver the list of positive integers that are divisible by 2, one by one.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="flip">flip</A> :: <B>forall</B> a b c.(<B>b-&gt;a-&gt;c</B>) -&gt; a -&gt; b -&gt; c</SPAN></DT>
<DD class="func">
<P>
Exchange first and second argument of a function, i.e.</P>
<PRE>
 flip f a b = f b a</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="fold">fold</A> :: <B>forall</B> a b.(a-&gt;b-&gt;a) -&gt; <B>a</B> -&gt; [b] -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#fold">fold</A>, applied to a binary operator, a starting value (typically the left identity of the operator), and a list, reduces the list using the binary operator, from left to right:</P>
<PRE>
 fold f z [x1, x2, ..., xn] = (((z `f` x1) `f` x2) `f` ...) `f` xn</PRE>
<P>
<A class="fref" href="#fold">fold</A> runs in constant stack space, but consumes the entire list before returning a result, so it must not be applied to infinite lists.</P>
<P>
This function is known as <SPAN CLASS="unknown">foldl\</SPAN>' in Haskell where there is a bias in favour of using <A class="fref" href="#foldr">foldr</A>.</P>
<P>
In the environment of the JVM stack space is precious, hence one should prefer <A class="fref" href="#fold">fold</A> when one has the choice.</P>
<P>
<A class="fref" href="#fold">fold</A> is strict in the accumulator, hence in every recursion the intermediate result is evaluated, thus preventing build up of possibly huge thunks that result in stack overflows on evaluation.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="foldM">foldM</A> :: <B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; (a-&gt;b-&gt;m a) -&gt; a -&gt; [b] -&gt; m a</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">foldM f a xs</SPAN> folds a monadic function <SPAN CLASS="code">f</SPAN> over the list <SPAN CLASS="code">xs</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="foldM_">foldM_</A> :: <B>forall</B> a b c.<A class="tref" href="#Monad">Monad</A> a =&gt; (b-&gt;c-&gt;a b) -&gt; b -&gt; [c] -&gt; a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">foldM_</SPAN> is the same as <A class="fref" href="#foldM">foldM</A>, but discards the result</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="foldl">foldl</A> :: <B>forall</B> a b.(a-&gt;b-&gt;a) -&gt; a -&gt; [b] -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#foldl">foldl</A>, applied to a binary operator, a starting value (typically the left identity of the operator), and a list, reduces the list using the binary operator, from left to right:</P>
<PRE>
 fold f z [x1, x2, ..., xn] = (((z `f` x1) `f` x2) `f` ...) `f` xn</PRE>
<P>
Because the operator is applied lazily, <A class="fref" href="#foldl">foldl</A> typically builds up large thunks which, when finally evaluated, may overflow the stack space. Therefore, the use of <A class="fref" href="#fold">fold</A> instead of <A class="fref" href="#foldl">foldl</A> is strogly suggested.</P>
<P>
This function exists merely for compatibility with Haskell.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="foldl_tick">foldl'</A> :: <B>forall</B> a b.(a-&gt;b-&gt;a) -&gt; <B>a</B> -&gt; [b] -&gt; a</SPAN></DT>
<DD class="func">
<P>
This is how our <A class="fref" href="#fold">fold</A> is called in Haskell land.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="foldl1">foldl1</A> :: <B>forall</B> a.(a-&gt;a-&gt;a) -&gt; <B>[a]</B> -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#foldl1">foldl1</A> is a variant of <A class="fref" href="#fold">fold</A> that has no starting value argument and thus must be applied to nonempty lists only.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="foldr">foldr</A> :: <B>forall</B> a e.(e-&gt;a-&gt;a) -&gt; a -&gt; [e] -&gt; a</SPAN></DT>
<DD class="func">
<P>
Fold over a list from right to left.</P>
<PRE>
 foldr f a (x1:x2:x3:[])</PRE>
<P>
is the same as</P>
<PRE>
 x1 `f` (x2 `f` (x3 `f` a))</PRE>
<P>
Note that, if <I>f</I> is strict in the second argument, <SPAN CLASS="code">foldr f</SPAN> will need stack space proportional to the length of the list. But if <I>f</I> is lazy in it's second argument, <A class="fref" href="#foldr">foldr</A> works on infinite lists.</P>
<P>
If <I>f</I> is commutative, the list finite and lazyness not an issue, <A class="fref" href="#fold">fold</A> may be the better choice since it runs with constant stack space. Otherwise, if <I>f</I> is not commutative, <A class="fref" href="#foldrs">foldrs</A> will trade time and heap space for stack space by <A class="fref" href="#fold">fold</A>ing the <A class="fref" href="#flip">flip</A>ped <I>f</I> over the <A class="fref" href="#reverse">reverse</A>d list.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="foldrs">foldrs</A> :: <B>forall</B> a b.(a-&gt;b-&gt;b) -&gt; <B>b</B> -&gt; [a] -&gt; b</SPAN></DT>
<DD class="func">
<P>
This function may be used in place of</P>
<PRE>
 foldr f z xs</PRE>
<P>
if <I>f</I> is strict in its right operand and <I>xs</I> is a finite list, when <A class="fref" href="#foldr">foldr</A> exceeds the stack size, which is usually quite limited in the JVM.</P>
<P>
<A class="fref" href="#foldrs">foldrs</A> will need extra CPU cycles and maybe (temporary) heap space for <A class="fref" href="#reverse">reverse</A>-ing its list argument, before <A class="fref" href="#fold">fold</A>ing the <A class="fref" href="#flip">flip</A>ped <I>f</I> over it.</P>
<P>
If <I>f</I> is commutative, you may simply use <A class="fref" href="#fold">fold</A> instead.</P>
<P>
The following property holds for all finite lists <I>xs</I>:</P>
<PRE>
 foldr f z xs == foldrs f z xs</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="forM">forM</A> :: <B>forall</B> a b c.<A class="tref" href="#Monad">Monad</A> b =&gt; [c] -&gt; (c-&gt;b a) -&gt; b [a]</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="forM_">forM_</A> :: <B>forall</B> a b c.<A class="tref" href="#Monad">Monad</A> b =&gt; [c] -&gt; (c-&gt;b a) -&gt; b <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="fromJust">fromJust</A> :: <B>forall</B> a.<B><A class="tref" href="#Maybe">Maybe</A> a</B> -&gt; a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="fromMaybe">fromMaybe</A> :: <B>forall</B> a.a -&gt; <A class="tref" href="#Maybe">Maybe</A> a -&gt; a</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">fromMaybe d (Just a)</SPAN> returns <SPAN CLASS="code">a</SPAN> and <SPAN CLASS="code">fromMaybe d (Just a)</SPAN> returns <SPAN CLASS="code">d</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="fst">fst</A> :: <B>forall</B> a b.<B>(a, b)</B> -&gt; a</SPAN></DT>
<DD class="func">
<P>
return the first element of a 2-tuple</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="group">group</A> :: <B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; <B>[a]</B> -&gt; [[a]]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">group xs</SPAN> returns a list of sub-lists made of adjacent equal elements in <SPAN CLASS="code">xs</SPAN>. All sublist are not empty and theri concatenation yields again <SPAN CLASS="code">xs</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="groupBy">groupBy</A> :: <B>forall</B> a.(a-&gt;a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; [[a]]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">groupBy f xs</SPAN> groups by function <SPAN CLASS="code">f</SPAN> instead of (==) that is used by <SPAN CLASS="code">group</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="head">head</A> :: <B>forall</B> a.<B>[a]</B> -&gt; a</SPAN></DT>
<DD class="func">
<P>
Get the head element of a non empty list. The head of an empty list is <A class="fref" href="#undefined">undefined</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="id">id</A> :: <B>forall</B> a.<B>a</B> -&gt; a</SPAN></DT>
<DD class="func">
<P>
The identity function</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="init">init</A> :: <B>forall</B> a.<B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
Returns all but the last element from a list.</P>
<P>
The following property holds for all non-empty finite lists <I>xs</I>:</P>
<PRE>
 init xs ++ [last xs] == xs</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="intersperse">intersperse</A> :: <B>forall</B> a.a -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">intersperse a xs</SPAN> inserts <I>a</I> between every two elements of <I>xs</I></P>
<PRE>
 intersperse 0 (1..3) == [1,0,2,0,3]</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="isJust">isJust</A> :: <B>forall</B> a.<B><A class="tref" href="#Maybe">Maybe</A> a</B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="isNothing">isNothing</A> :: <B>forall</B> a.<B><A class="tref" href="#Maybe">Maybe</A> a</B> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="iterate">iterate</A> :: <B>forall</B> a.(a-&gt;a) -&gt; a -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">iterate f a</SPAN> builds the infinite list <SPAN CLASS="code">[a, f a, f (f a), ...]</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="last">last</A> :: <B>forall</B> a.[a] -&gt; a</SPAN></DT>
<DD class="func">
<P>
Returns the last element of a list by taking the <A class="fref" href="#head">head</A> of the <A class="fref" href="#reverse">reverse</A>d list.</P>
<P>
See also <A class="fref" href="#init">init</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="lazyif">lazyif</A> :: <B>forall</B> a.<B><A class="tref" href="#Bool">Bool</A></B> -&gt; a -&gt; a -&gt; a</SPAN></DT>
<DD class="func">
<P>
This is used by code generation when a conditional expression appears in a lazy context, i.e.</P>
<PRE>
 (42, if foo then bar else baz)</PRE>
<P>
<SPAN CLASS="code">lazyif a b c</SPAN> evaluates to <SPAN CLASS="code">b</SPAN> if <SPAN CLASS="code">a</SPAN> is <SPAN CLASS="code">true</SPAN>, otherwise to <SPAN CLASS="code">c</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="liftM">liftM</A> :: <B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; (a-&gt;b) -&gt; m a -&gt; m b</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="liftM2">liftM2</A> :: <B>forall</B> a b c d.<A class="tref" href="#Monad">Monad</A> c =&gt; (a-&gt;d-&gt;b) -&gt; c a -&gt; c d -&gt; c b</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="liftM3">liftM3</A> :: <B>forall</B> a b c d e.<A class="tref" href="#Monad">Monad</A> b =&gt; (d-&gt;a-&gt;e-&gt;c) -&gt; b d -&gt; b a -&gt; b e -&gt; b c</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="liftM4">liftM4</A> :: <B>forall</B> a b c d e f.<A class="tref" href="#Monad">Monad</A> b =&gt; (d-&gt;a-&gt;e-&gt;f-&gt;c) -&gt; b d -&gt; b a -&gt; b e -&gt; b f -&gt; b c</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="map">map</A> :: <B>forall</B> a b.(a-&gt;b) -&gt; <B>[a]</B> -&gt; [b]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">map f xs</SPAN> applies <I>f</I> to each element of <I>xs</I> and builds a new list from the results.</P>
<P>
Usage of <A class="fref" href="#map">map</A> is safe on infinite lists, it delivers the result list one by one as it is demanded.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="mapM">mapM</A> :: <B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; (a-&gt;m b) -&gt; [a] -&gt; m [b]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">mapM f</SPAN> is equivalent to <SPAN CLASS="code">sequence • map f</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="mapM_">mapM_</A> :: <B>forall</B> a b c.<A class="tref" href="#Monad">Monad</A> b =&gt; (c-&gt;b a) -&gt; [c] -&gt; b <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="maybe">maybe</A> :: <B>forall</B> a b.a -&gt; (b-&gt;a) -&gt; <A class="tref" href="#Maybe">Maybe</A> b -&gt; a</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="not">not</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>!</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">not b</SPAN> is true if <I>b</I> is false, otherwise true. Uses java's <A class="fref" href="#_excl">!</A> operator</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="notElem">notElem</A> :: <B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; a -&gt; [a] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
opposite of <A class="fref" href="#elem">elem</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="or">or</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
Like <A class="fref" href="#_bar_bar">||</A>, but second argument is lazy. The <SPAN CLASS="code">`or`</SPAN> operator has the same precedence and arity as <A class="fref" href="#_bar_bar">||</A>. The definition is</P>
<PRE>
 a `or`  b = if a then true  else b</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="otherwise">otherwise</A> :: <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
This is a constant with the value <SPAN CLASS="code">true</SPAN>. It is most often used as the last alternative in pattern guards:</P>
<PRE>
 foo n | n &gt;= 0    = ...
       | otherwise = ...</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="packed">packed</A> :: <B>[<A class="tref" href="#Char">Char</A>]</B> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
convert a list of characters to a string</P>
<PRE>
 packed ['a', 'b', 'c' ] == "abc"</PRE>
<P>
Not very efficient, may be replaced by a java function that does it with a string buffer later.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="partition">partition</A> :: <B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; ([a], [a])</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">partition p xs</SPAN> splits <I>xs</I> in 2 lists and returns them as a tuple <SPAN CLASS="code">(xs1, xs2)</SPAN>, such that  <I>xs1</I> contains all elements of <I>xs</I> that satisfy predicate <I>p</I> and <I>xs2</I> contains those that do not.</P>
<P>
The order of the elements of <I>xs</I> is not preserved in the results.</P>
<P>
The follwoing is true for all finite lists xs</P>
<PRE>
 let ps = partition p xs
 in    all p (fst ps)
    &amp;&amp; (not @ any p) (snd ps)
    &amp;&amp; length (fst ps) + length (snd ps) == length xs
    &amp;&amp; all (`elem` xs) (fst ps)
    &amp;&amp; all (`elem` xs) (snd ps)
    &amp;&amp; all (\x -&gt; x `elem` fst ps || x `elem` snd ps) xs</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="printStr">printStr</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A> <A class="tref" href="#Unit">()</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>java.lang.System.out.print</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="printStrLn">printStrLn</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A> <A class="tref" href="#Unit">()</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>java.lang.System.out.println</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="regcomp">regcomp</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Regex">Regex</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>java.util.regex.Pattern.compile</SPAN></DT>
<DD class="func">
<P>
compile a <A class="tref" href="#String">String</A> to a <A class="tref" href="#Regex">Regex</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="repeat">repeat</A> :: <B>forall</B> a.a -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">repeat a</SPAN> builds an infinite list where all elements are <I>a</I>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="reverse">reverse</A> :: <B>forall</B> a.<B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
reverses a list</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanl">scanl</A> :: <B>forall</B> a b.(a-&gt;b-&gt;a) -&gt; <B>a</B> -&gt; [b] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#scanl">scanl</A> is similar to <A class="fref" href="#fold">fold</A> but returns a list of successive reduced values from the left:</P>
<PRE>
 scanl f z [x1, x2, ...] = [z, z `f` x1, (z `f` x1) `f` x2, ... ]</PRE>
<P>
The follwoing property holds for all finite lists <I>xs</I>:</P>
<PRE>
 last (scanl f z xs) == fold f z xs</PRE>
<P>
In contrast to <A class="fref" href="#fold">fold</A>, <A class="fref" href="#scanl">scanl</A> can operate on infinite lists.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanl1">scanl1</A> :: <B>forall</B> a.(a-&gt;a-&gt;a) -&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#scanl1">scanl1</A> is similar to <A class="fref" href="#scanl">scanl</A>, but takes the <A class="fref" href="#head">head</A> of the list as starting element and is thus only applicable to non-empty lists.</P>
<PRE>
 scanl1 f [x1, x2, ...] = [x1, x1 `f` x2, (x1 `f` x2) `f` ...]</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="seq">seq</A> :: <B>forall</B> a b.<B>a</B> -&gt; b -&gt; b</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">a `seq` b</SPAN> evaluates <I>a</I> before it returns <I>b</I></P>
<P>
This is a right associative operator with precedence 15.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="sequence">sequence</A> :: <B>forall</B> m a.<A class="tref" href="#Monad">Monad</A> m =&gt; <B>[m a]</B> -&gt; m [a]</SPAN></DT>
<DD class="func">
<P>
Turn a list of monadic values <SPAN CLASS="code">[m a]</SPAN> into a monadic value with a list <SPAN CLASS="code">m [a]</SPAN></P>
<P>
sequence [Just 1, Just 3, Just 2] = Just [1,2,3] This version of <A class="fref" href="#sequence">sequence</A> runs in constant stack space, but needs heap space proportional to the size of the input list.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="sequence_">sequence_</A> :: <B>forall</B> a b.<A class="tref" href="#Monad">Monad</A> a =&gt; <B>[a b]</B> -&gt; a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
foldr (<A class="fref" href="#Monad:_gt_gt">Monad.&gt;&gt;</A>) over a list of monadic values for side effects </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="snd">snd</A> :: <B>forall</B> a b.<B>(a, b)</B> -&gt; b</SPAN></DT>
<DD class="func">
<P>
return the second element of a 2-tuple</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="sort">sort</A> :: <B>forall</B> a.<A class="tref" href="#Ord">Ord</A> a =&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
Standard sort uses operator <A class="fref" href="#Ord:_lt_eq">Ord.&lt;=</A> and demands that the type of the list elements is an instance of <A class="tref" href="#Ord">Ord</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="sortBy">sortBy</A> :: <B>forall</B> a.(a-&gt;a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">sortBy f xs</SPAN> is a stable sort (merge sort), it uses <I>f</I> to decide the order of elements. If <SPAN CLASS="code">a `f` b</SPAN> is true, then <I>a</I> comes before <I>b</I>, otherwise <I>b</I> comes before <I>a</I>.</P>
<P>
see also <A class="fref" href="#comparing">comparing</A>,  <A class="fref" href="#descending">descending</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="span">span</A> :: <B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; [a] -&gt; ([a], [a])</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">span p xs</SPAN> returns a tuple whose first element is the longest prefix of <SPAN CLASS="code">xs</SPAN> of elements that satisfy <SPAN CLASS="code">p</SPAN> and whose second element is the remainder of the list.</P>
<PRE>
 span p xs == (takeWhile p xs, dropWhile p xs)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="stocs">stocs</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; [<A class="tref" href="#Char">Char</A>]</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strhead">strhead</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple10">strictTuple10</A> :: <B>forall</B> d b a c h f e g i j.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; (a, b, c, d, e, f, g, h, i, j)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple10.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 10-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple11">strictTuple11</A> :: <B>forall</B> d b a c h f e g j i k.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; (a, b, c, d, e, f, g, h, i, j, k)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple11.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 11-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple12">strictTuple12</A> :: <B>forall</B> h d b a c f e g j i k l.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; (a, b, c, d, e, f, g, h, i, j, k, l)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple12.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 12-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple13">strictTuple13</A> :: <B>forall</B> h d b a c f e g j i l k m.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple13.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 13-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple14">strictTuple14</A> :: <B>forall</B> h d b a c f e g l j i k m n.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple14.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 14-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple15">strictTuple15</A> :: <B>forall</B> h d b a c f e g l j i k n m o.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple15.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 15-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple16">strictTuple16</A> :: <B>forall</B> h d b a c f e g l j i k n m o p.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple16.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 16-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple17">strictTuple17</A> :: <B>forall</B> h d b a c f e g l j i k n m p o q.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple17.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 17-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple18">strictTuple18</A> :: <B>forall</B> h d b a c f e g l j i k p n m o q r.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple18.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 18-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple19">strictTuple19</A> :: <B>forall</B> h d b a c f e g l j i k p n m o r q s.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple19.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 19-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple2">strictTuple2</A> :: <B>forall</B> a b.<B>a</B> -&gt; b -&gt; (a, b)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple2.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict tuple. The difference to <A class="tref" href="#Tuple2">(,)</A> is that both argument values will be evaluated before the tuple is constructed. Thus:</P>
<PRE>
fst (42; undefined) == undefined
fst (42, undefined) == 42</PRE>
<P>
<B>Implementation specific:</B> The compiler will rewrite <SPAN CLASS="code">(a;b)</SPAN> as <SPAN CLASS="code">(Base.strictTuple2 a b)</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple20">strictTuple20</A> :: <B>forall</B> h d b a c f e g p l j i k n m o r q s t.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple20.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 20-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple21">strictTuple21</A> :: <B>forall</B> h d b a c f e g p l j i k n m o r q t s u.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple21.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 21-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple22">strictTuple22</A> :: <B>forall</B> h d b a c f e g p l j i k n m o t r q s u v.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple22.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 22-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple23">strictTuple23</A> :: <B>forall</B> h d b a c f e g p l j i k n m o t r q s v u w.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; w -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple23.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 23-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple24">strictTuple24</A> :: <B>forall</B> p h d b a c f e g l j i k n m o t r q s v u w x.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; w -&gt; x -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple24.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 24-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple25">strictTuple25</A> :: <B>forall</B> p h d b a c f e g l j i k n m o t r q s v u x w y.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; w -&gt; x -&gt; y -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple25.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 25-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple26">strictTuple26</A> :: <B>forall</B> p h d b a c f e g l j i k n m o t r q s x v u w y z.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; w -&gt; x -&gt; y -&gt; z -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple26.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 26-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple3">strictTuple3</A> :: <B>forall</B> b a c.<B>a</B> -&gt; b -&gt; c -&gt; (a, b, c)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple3.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 3-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple4">strictTuple4</A> :: <B>forall</B> b a c d.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; (a, b, c, d)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple4.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 4-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple5">strictTuple5</A> :: <B>forall</B> b a d c e.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; (a, b, c, d, e)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple5.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 5-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple6">strictTuple6</A> :: <B>forall</B> d b a c e f.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; (a, b, c, d, e, f)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple6.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 6-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple7">strictTuple7</A> :: <B>forall</B> d b a c f e g.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; (a, b, c, d, e, f, g)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple7.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 7-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple8">strictTuple8</A> :: <B>forall</B> d b a c f e g h.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; (a, b, c, d, e, f, g, h)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple8.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 8-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strictTuple9">strictTuple9</A> :: <B>forall</B> d b a c f e h g i.<B>a</B> -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; (a, b, c, d, e, f, g, h, i)&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base.tTuple9.mk</SPAN></DT>
<DD class="func">
<P>
Constructs a strict 9-tuple. See remarks for <A class="fref" href="#strictTuple2">strictTuple2</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strtail">strtail</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>substring</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">strtail s n</SPAN> returns a new string that is a substring of string <I>s</I>. The substring begins with the character at the specified index and extends to the end of <I>s</I>.</P>
<P>
This uses the native method <SPAN CLASS="code">substring</SPAN> of class <SPAN CLASS="code">java.lang.String</SPAN>. It will throw an <SPAN CLASS="code">IndexOutOfBoundsException</SPAN> if <I>n</I> is negative or larger than the length of <I>s</I>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="substr">substr</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>substring</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">substr s start end</SPAN> returns the sub string of <SPAN CLASS="code">s</SPAN> that starts with the character at position <SPAN CLASS="code">start</SPAN> and extends to the character at position <SPAN CLASS="code">end-1</SPAN>.</P>
<P>
This uses the native method <SPAN CLASS="code">substring</SPAN> of class <SPAN CLASS="code">java.lang.String</SPAN>. It will throw an <SPAN CLASS="code">IndexOutOfBoundsException</SPAN> if <SPAN CLASS="code">start</SPAN> is negative or larger than <SPAN CLASS="code">end</SPAN> or if <SPAN CLASS="code">end</SPAN> is greater than the length of <SPAN CLASS="code">s</SPAN>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="take">take</A> :: <B>forall</B> a.<B><A class="tref" href="#Int">Int</A></B> -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">take n xs</SPAN> returns the starting sequence of <I>xs</I> with at most <I>n</I> elements. If <I>n</I> is greater than the <A class="fref" href="#Length:length">Length.length</A> of <I>xs</I>, the result is <I>xs</I>.</P>
<P>
For negative <I>n</I>, the result is undefined.</P>
<P>
The following property holds for all lists <I>xs</I> and non negative <I>n</I>:</P>
<PRE>
 take n xs ++ drop n xs == xs</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="takeUntil">takeUntil</A> :: <B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">takeUntil p xs</SPAN> is the same as <SPAN CLASS="code">takeWhile (not \</SPAN> p) xs@</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="takeWhile">takeWhile</A> :: <B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">takeWhile p xs</SPAN> takes leading elements from <I>xs</I> while they satisfy the predicate <I>p</I>.</P>
<P>
Example:</P>
<PRE>
 takeWhile (&lt;7) [1,2,3,9,4] == [1,2,3]</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_throw">throw</A> :: <B>forall</B> a.<B><A class="tref" href="#JException">JException</A></B> -&gt; a</SPAN></DT>
<DD class="func">
<P>
Constructs an undefined value from a java exception and throws it.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="trace">trace</A> :: <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="traceLn">traceLn</A> :: <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="traceStr">traceStr</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A> <A class="tref" href="#Unit">()</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>native </B>java.lang.System.err.print</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_try">try</A> :: <B>forall</B> b a.(<B>a-&gt;b</B>) -&gt; <B>a</B> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> b&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>Base._dollar.w</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">(try f x)</SPAN>  is like  <SPAN CLASS="code">(f $ x)</SPAN> but catches all exceptions that are thrown in <SPAN CLASS="code">f</SPAN>. To be used like</P>
<PRE>
 case try f x of
    Left exception -&gt; ...
    Right result   -&gt; ...</PRE>
<P>
Note that <A class="fref" href="#_try">try</A> is strict in both its arguments. The exceptions thrown when the arguments are evaluated will <B>not</B> be catched.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="unJust">unJust</A> :: <B>forall</B> a.<B><A class="tref" href="#Maybe">Maybe</A> a</B> -&gt; a</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">unJust Nothing</SPAN> is <A class="fref" href="#undefined">undefined</A> whereas <SPAN CLASS="code">unJust (Just a)</SPAN> is <SPAN CLASS="code">a</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="uncurry">uncurry</A> :: <B>forall</B> a b c.(<B>(a, c)-&gt;b</B>) -&gt; a -&gt; c -&gt; b</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">uncurry f</SPAN> passes the next two arguments as 2-tuple to <I>f</I></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="undefined">undefined</A> :: <B>forall</B> u.u</SPAN></DT>
<DD class="func">
<P>
This is the standard undefined value.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="uniq">uniq</A> :: <B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#uniq">uniq</A> removes adjacent equal elements from a list</P>
<PRE>
 uniq [1, 2, 2, 3, 2] = [1, 2, 3, 2]</PRE>
<P>
This is most useful on sorted lists to remove duplicates. For unsorted lists use <A class="fref" href="#unique">unique</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="uniqBy">uniqBy</A> :: <B>forall</B> a.(a-&gt;a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">uniqBy f</SPAN> is a variant of <A class="fref" href="#uniq">uniq</A> that uses <I>f</I> instead of <A class="fref" href="#Eq:_eq_eq">Eq.==</A>. In the result, there are no two adjacent elements <I>x</I> and <I>y</I> where the relation <SPAN CLASS="code">y `f` x</SPAN> holds.</P>
<P>
This is most useful on sorted lists with projection functions that compare parts of the value for equality. See also <A class="fref" href="#using">using</A>.</P>
<PRE>
 uniqBy (\a\b -&gt; fst a == fst b) [(1, 1), (2, 2), (2, 3), (3, 4), (2, 5)]
   == [(1, 1), (2, 3), (3, 4), (2, 5)]</PRE>
<P>
The example shows that, if one of two adjacent elements is removed, it will be the one occuring first.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="unique">unique</A> :: <B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#unique">unique</A> removes duplicate elements from an unsorted list, which may or may not be faster than using <SPAN CLASS="code">(uniq • sort)</SPAN></P>
<P>
However, the follwoing holds</P>
<PRE>
 sort (unique xs) == uniq (sort xs)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="uniqueBy">uniqueBy</A> :: <B>forall</B> a.(a-&gt;a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; <B>[a]</B> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">uniqueBy f</SPAN> is a more general form of <A class="fref" href="#unique">unique</A>, but uses (<A class="fref" href="#elemBy">elemBy</A> <SPAN CLASS="code">f</SPAN>) instead of <A class="fref" href="#elem">elem</A> to decide whether equal elements are contained in the list.</P>
<P>
The following holds:</P>
<PRE>
 sortBy (comparing f) (uniqueBy (using f) xs) == uniqBy (using f) (sortBy (comparing f) xs)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="unless">unless</A> :: <B>forall</B> a.<A class="tref" href="#Monad">Monad</A> a =&gt; <B><A class="tref" href="#Bool">Bool</A></B> -&gt; a <A class="tref" href="#Unit">()</A> -&gt; a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
opposite of <A class="fref" href="#when">when</A> </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="unpacked">unpacked</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; [<A class="tref" href="#Char">Char</A>]</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="unzip">unzip</A> :: <B>forall</B> a b.<B>[(a, b)]</B> -&gt; ([a], [b])</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#unzip">unzip</A> turns a list of tuples into a tuple of lists. It is the opposite of <A class="fref" href="#zip">zip</A> and the follwoing holds</P>
<PRE>
 (curry zip @ unzip) xs == xs</PRE>
<P>
But note that</P>
<PRE>
 (unzip @ curry zip) (as, bs) == (as,bs)</PRE>
<P>
will only hold if <SPAN CLASS="code">length as == length bs</SPAN></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="using">using</A> :: <B>forall</B> a b.<A class="tref" href="#Eq">Eq</A> b =&gt; (a-&gt;b) -&gt; a -&gt; a -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">using f</SPAN> applies a projection function <I>f</I> on both sides of <A class="fref" href="#Eq:_eq_eq">Eq.==</A>. The example for <A class="fref" href="#uniqBy">uniqBy</A> could be written easier</P>
<PRE>
 uniqBy (using fst) [(1, 1), (2, 2), (2, 3), (3,4), (2,5)]</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_void">void</A> :: <B>forall</B> a.<A class="tref" href="#ST">ST</A> a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">void</SPAN> is short for <A class="fref" href="#Monad_ST:_return">Monad_ST.return</A> <A class="tref" href="#Unit">()</A> </P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="when">when</A> :: <B>forall</B> a.<A class="tref" href="#Monad">Monad</A> a =&gt; <B><A class="tref" href="#Bool">Bool</A></B> -&gt; a <A class="tref" href="#Unit">()</A> -&gt; a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">when condition monadic</SPAN> returns <I>action</I> of type <SPAN CLASS="code">Monad:m ()</SPAN> if <I>condition</I> is true, otherwise <A class="fref" href="#Monad:_return">Monad.return</A> <A class="tref" href="#Unit">()</A>.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="xor">xor</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">a `xor` b</SPAN> is true if either <I>a</I> or <I>b</I> is true, but not both</P>
<PRE>
 a `xor` b = if a then not b else b</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="zip">zip</A> :: <B>forall</B> a b.<B>[a]</B> -&gt; [b] -&gt; [(a, b)]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">zip as bs</SPAN> builds a list of tuples of corresponding elements of <I>as</I> and <I>bs</I>. Trailing elements of the longer list are ignored.</P>
<PRE>
 zip (1,2,3) ("a", "b") = [(1, "a"), (2, "b")]</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="zipWith">zipWith</A> :: <B>forall</B> a b c.(a-&gt;c-&gt;b) -&gt; <B>[a]</B> -&gt; [c] -&gt; [b]</SPAN></DT>
<DD class="func">
<P>
<SPAN CLASS="code">zipWith f xs ys</SPAN> zips two lists with function <I>f</I> instead of the standard <A class="tref" href="#Tuple2">(,)</A> that is used by <A class="fref" href="#zip">zip</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_bar_bar">||</A> :: <B><A class="tref" href="#Bool">Bool</A></B> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A>&nbsp;&nbsp;&nbsp;&nbsp;<B>pure </B><B>native </B>||</SPAN></DT>
<DD class="func">
<P>
The Java <SPAN CLASS="code">||</SPAN> operator, see notes to <A class="fref" href="#_amp_amp">&amp;&amp;</A> and <A class="fref" href="#or">or</A> for an alternative</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_tilde">~</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<PRE>
string ~ regex</PRE>
<P>
<SPAN CLASS="code">true</SPAN> if <I>string</I> matches <I>regex</I>, <SPAN CLASS="code">false</SPAN> otherwise</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_tilde_gt">~&gt;</A> :: <B>forall</B> a b c.(c-&gt;b) -&gt; (<B>b-&gt;a</B>) -&gt; c -&gt; a</SPAN></DT>
<DD class="func">
<P>
Function composition.</P>
<P>
<SPAN CLASS="code">(f ~&gt; g)</SPAN> is a function whose argument is first passed to <I>f</I>, and the result to <I>g</I>, yielding the overall result.</P>
<P>
One can imagine that the data flows from left to right through a function pipe.</P>
<PRE>
 (a) ~&gt; (b)  = \x -&gt; b (a x)</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_tilde_tilde">~~</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<PRE>
 ("string" ~~ #r??#) == Just "rin"</PRE>
<P>
Tries a match and returns <SPAN CLASS="code">Just x</SPAN> where <I>x</I> is the matched substring or <SPAN CLASS="code">Nothing</SPAN> if there was no match.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_tilde_tilde_tilde">~~~</A> :: <B><A class="tref" href="#String">String</A></B> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<PRE>
 string ~~~ regex</PRE>
<P>
Matches <I>string</I> with <I>regex</I> and returns a function that can be used to extract the matched part of the string and the captured substrings.</P>
<PRE>
   let f = "frege" ~~~ #(..).(..)#
   in [ f i | i &lt;- 0..3 ]</PRE>
<P>
yields</P>
<PRE>
[Just "frege", Just "fr", Just "ge", Nothing]</PRE>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="_bullet">•</A> :: <B>forall</B> a b c.(<B>b-&gt;a</B>) -&gt; (c-&gt;b) -&gt; c -&gt; a</SPAN></DT>
<DD class="func">
<P>
Another operator for function composition, which is identical to <A class="fref" href="#_lt_tilde">&lt;~</A></P>
<P>
Character can be created by holding ALT and typing 0149 on the numeric keypad.</P>
<PRE>
 (f • g) a = f (g a)</PRE>
</DD>
</DL>
<H2>
<A name="case">Functions and Values by Type</A></H2>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:elemAt">IntArray.elemAt</A>, <A class="fref" href="#IntArray:frozenGetAt">IntArray.frozenGetAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A> -&gt; [<A class="tref" href="#Int">Int</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:toList">IntArray.toList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:length">IntArray.length</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#StringArray:frozenGetAt">StringArray.frozenGetAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#StringArray:elemAt">StringArray.elemAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A> -&gt; [<A class="tref" href="#String">String</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#StringArray:toList">StringArray.toList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#StringArray:length">StringArray.length</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[(<A class="tref" href="#Int">Int</A>, <A class="tref" href="#Int">Int</A>)] -&gt; <A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:fromInxList">IntArray.fromInxList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[<A class="tref" href="#Char">Char</A>] -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#cstos">cstos</A>, <A class="fref" href="#packed">packed</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[<A class="tref" href="#Int">Int</A>] -&gt; <A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:fromList">IntArray.fromList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[<A class="tref" href="#String">String</A>] -&gt; <A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#StringArray:fromList">StringArray.fromList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Unit">()</A> -&gt; <A class="tref" href="#Unit">()</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Eq__lpar_rpar:_div_eq">Eq_()./=</A>, <A class="fref" href="#Eq__lpar_rpar:_excl_eq">Eq_().!=</A>, <A class="fref" href="#Eq__lpar_rpar:_eq_eq">Eq_().==</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; [<A class="tref" href="#Bool">Bool</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Bool:_dot_dot">Enum_Bool...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_amp_amp">&amp;&amp;</A>, <A class="fref" href="#and">and</A>, <A class="fref" href="#or">or</A>, <A class="fref" href="#xor">xor</A>, <A class="fref" href="#_bar_bar">||</A>, <A class="fref" href="#Eq_Bool:_div_eq">Eq_Bool./=</A>, <A class="fref" href="#Eq_Bool:_excl_eq">Eq_Bool.!=</A>, <A class="fref" href="#Eq_Bool:_eq_eq">Eq_Bool.==</A>, <A class="fref" href="#Ord_Bool:_gt">Ord_Bool.&gt;</A>, <A class="fref" href="#Ord_Bool:_lt_eq">Ord_Bool.&lt;=</A>, <A class="fref" href="#Ord_Bool:_lt">Ord_Bool.&lt;</A>, <A class="fref" href="#Ord_Bool:_gt_eq">Ord_Bool.&gt;=</A>, <A class="fref" href="#Ord_Bool:max">Ord_Bool.max</A>, <A class="fref" href="#Ord_Bool:min">Ord_Bool.min</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Bool:_lt_eq_gt">Ord_Bool.&lt;=&gt;</A>, <A class="fref" href="#Ord_Bool:compare">Ord_Bool.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_excl">!</A>, <A class="fref" href="#not">not</A>, <A class="fref" href="#Enum_Bool:pred">Enum_Bool.pred</A>, <A class="fref" href="#Enum_Bool:succ">Enum_Bool.succ</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Bool:ord">Enum_Bool.ord</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Char">Char</A> -&gt; [<A class="tref" href="#Char">Char</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Char:_dot_dot">Enum_Char...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Eq_Char:_div_eq">Eq_Char./=</A>, <A class="fref" href="#Eq_Char:_excl_eq">Eq_Char.!=</A>, <A class="fref" href="#Eq_Char:_eq_eq">Eq_Char.==</A>, <A class="fref" href="#Ord_Char:_gt">Ord_Char.&gt;</A>, <A class="fref" href="#Ord_Char:_lt_eq">Ord_Char.&lt;=</A>, <A class="fref" href="#Ord_Char:_lt">Ord_Char.&lt;</A>, <A class="fref" href="#Ord_Char:_gt_eq">Ord_Char.&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Char:max">Ord_Char.max</A>, <A class="fref" href="#Ord_Char:min">Ord_Char.min</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Char:_lt_eq_gt">Ord_Char.&lt;=&gt;</A>, <A class="fref" href="#Ord_Char:compare">Ord_Char.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Char:isUpperCase">Char.isUpperCase</A>, <A class="fref" href="#Char:isLowerCase">Char.isLowerCase</A>, <A class="fref" href="#Char:isWhitespace">Char.isWhitespace</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Char:pred">Enum_Char.pred</A>, <A class="fref" href="#Enum_Char:succ">Enum_Char.succ</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Char:ord">Enum_Char.ord</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Char">Char</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#ctos">ctos</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Class">Class</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Class:getName">Class.getName</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Eq_Double:_div_eq">Eq_Double./=</A>, <A class="fref" href="#Eq_Double:_excl_eq">Eq_Double.!=</A>, <A class="fref" href="#Eq_Double:_eq_eq">Eq_Double.==</A>, <A class="fref" href="#Ord_Double:_gt">Ord_Double.&gt;</A>, <A class="fref" href="#Ord_Double:_lt_eq">Ord_Double.&lt;=</A>, <A class="fref" href="#Ord_Double:_lt">Ord_Double.&lt;</A>, <A class="fref" href="#Ord_Double:_gt_eq">Ord_Double.&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Double:max">Ord_Double.max</A>, <A class="fref" href="#Ord_Double:min">Ord_Double.min</A>, <A class="fref" href="#Real_Double:_div">Real_Double./</A>, <A class="fref" href="#Real_Double:_plus">Real_Double.+</A>, <A class="fref" href="#Real_Double:_star">Real_Double.*</A>, <A class="fref" href="#Real_Double:_minus">Real_Double.-</A>, <A class="fref" href="#Real_Double:subtract">Real_Double.subtract</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Double:_lt_eq_gt">Ord_Double.&lt;=&gt;</A>, <A class="fref" href="#Ord_Double:compare">Ord_Double.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Double:isNaN">Real_Double.isNaN</A>, <A class="fref" href="#Real_Double:isInfinite">Real_Double.isInfinite</A>, <A class="fref" href="#Real_Double:isNumber">Real_Double.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Double:abs">Real_Double.abs</A>, <A class="fref" href="#Real_Double:negate">Real_Double.negate</A>, <A class="fref" href="#Double:floor">Double.floor</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Double:_float">Double.float</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Double:sign">Real_Double.sign</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Double">Double</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Double:_long">Double.long</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Eq_Float:_div_eq">Eq_Float./=</A>, <A class="fref" href="#Eq_Float:_excl_eq">Eq_Float.!=</A>, <A class="fref" href="#Eq_Float:_eq_eq">Eq_Float.==</A>, <A class="fref" href="#Ord_Float:_gt">Ord_Float.&gt;</A>, <A class="fref" href="#Ord_Float:_lt_eq">Ord_Float.&lt;=</A>, <A class="fref" href="#Ord_Float:_lt">Ord_Float.&lt;</A>, <A class="fref" href="#Ord_Float:_gt_eq">Ord_Float.&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Float:max">Ord_Float.max</A>, <A class="fref" href="#Ord_Float:min">Ord_Float.min</A>, <A class="fref" href="#Real_Float:_div">Real_Float./</A>, <A class="fref" href="#Real_Float:_plus">Real_Float.+</A>, <A class="fref" href="#Real_Float:_star">Real_Float.*</A>, <A class="fref" href="#Real_Float:_minus">Real_Float.-</A>, <A class="fref" href="#Real_Float:subtract">Real_Float.subtract</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Float:_lt_eq_gt">Ord_Float.&lt;=&gt;</A>, <A class="fref" href="#Ord_Float:compare">Ord_Float.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Float:isNaN">Real_Float.isNaN</A>, <A class="fref" href="#Real_Float:isInfinite">Real_Float.isInfinite</A>, <A class="fref" href="#Real_Float:isNumber">Real_Float.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Float:_double">Float.double</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Float:abs">Real_Float.abs</A>, <A class="fref" href="#Real_Float:negate">Real_Float.negate</A>, <A class="fref" href="#Float:floor">Float.floor</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Float">Float</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Float:sign">Real_Float.sign</A>, <A class="fref" href="#Float:_int">Float.int</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; [<A class="tref" href="#Int">Int</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Int:_dot_dot">Enum_Int...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Eq_Int:_div_eq">Eq_Int./=</A>, <A class="fref" href="#Eq_Int:_excl_eq">Eq_Int.!=</A>, <A class="fref" href="#Eq_Int:_eq_eq">Eq_Int.==</A>, <A class="fref" href="#Ord_Int:_gt">Ord_Int.&gt;</A>, <A class="fref" href="#Ord_Int:_lt_eq">Ord_Int.&lt;=</A>, <A class="fref" href="#Ord_Int:_lt">Ord_Int.&lt;</A>, <A class="fref" href="#Ord_Int:_gt_eq">Ord_Int.&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integral_Int:bshr">Integral_Int.bshr</A>, <A class="fref" href="#Integral_Int:bor">Integral_Int.bor</A>, <A class="fref" href="#Integral_Int:band">Integral_Int.band</A>, <A class="fref" href="#Integral_Int:bshl">Integral_Int.bshl</A>, <A class="fref" href="#Integral_Int:div">Integral_Int.div</A>, <A class="fref" href="#Integral_Int:bxor">Integral_Int.bxor</A>, <A class="fref" href="#Integral_Int:rem">Integral_Int.rem</A>, <A class="fref" href="#Integral_Int:mod">Integral_Int.mod</A>, <A class="fref" href="#Num_Int:_minus">Num_Int.-</A>, <A class="fref" href="#Num_Int:_plus">Num_Int.+</A>, <A class="fref" href="#Num_Int:_star">Num_Int.*</A>, <A class="fref" href="#Num_Int:subtract">Num_Int.subtract</A>, <A class="fref" href="#Ord_Int:max">Ord_Int.max</A>, <A class="fref" href="#Ord_Int:min">Ord_Int.min</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Int:_lt_eq_gt">Ord_Int.&lt;=&gt;</A>, <A class="fref" href="#Ord_Int:compare">Ord_Int.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Bool:from">Enum_Bool.from</A>, <A class="fref" href="#Num_Int:isNaN">Num_Int.isNaN</A>, <A class="fref" href="#Num_Int:isInfinite">Num_Int.isInfinite</A>, <A class="fref" href="#Num_Int:isNumber">Num_Int.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#chr">chr</A>, <A class="fref" href="#Enum_Char:from">Enum_Char.from</A>, <A class="fref" href="#Int:_char">Int.char</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Double:fromInt">Real_Double.fromInt</A>, <A class="fref" href="#Int:_double">Int.double</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Float:fromInt">Real_Float.fromInt</A>, <A class="fref" href="#Int:_float">Int.float</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Int:from">Enum_Int.from</A>, <A class="fref" href="#Enum_Int:pred">Enum_Int.pred</A>, <A class="fref" href="#Enum_Int:ord">Enum_Int.ord</A>, <A class="fref" href="#Enum_Int:succ">Enum_Int.succ</A>, <A class="fref" href="#Num_Int:fromInt">Num_Int.fromInt</A>, <A class="fref" href="#Num_Int:abs">Num_Int.abs</A>, <A class="fref" href="#Num_Int:sign">Num_Int.sign</A>, <A class="fref" href="#Num_Int:negate">Num_Int.negate</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Integer:from">Enum_Integer.from</A>, <A class="fref" href="#IntegerConvertable_Int:big">IntegerConvertable_Int.big</A>, <A class="fref" href="#Integral_Integer:fromInt">Integral_Integer.fromInt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Long:from">Enum_Long.from</A>, <A class="fref" href="#Num_Long:fromInt">Num_Long.fromInt</A>, <A class="fref" href="#Int:_long">Int.long</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Int:toHexString">Int.toHexString</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integral_Integer:bshl">Integral_Integer.bshl</A>, <A class="fref" href="#Integral_Integer:bshr">Integral_Integer.bshr</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; [<A class="tref" href="#Integer">Integer</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Integer:_dot_dot">Enum_Integer...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Integer:_gt">Ord_Integer.&gt;</A>, <A class="fref" href="#Ord_Integer:_lt">Ord_Integer.&lt;</A>, <A class="fref" href="#Ord_Integer:_excl_eq">Ord_Integer.!=</A>, <A class="fref" href="#Ord_Integer:_div_eq">Ord_Integer./=</A>, <A class="fref" href="#Ord_Integer:_lt_eq">Ord_Integer.&lt;=</A>, <A class="fref" href="#Ord_Integer:_eq_eq">Ord_Integer.==</A>, <A class="fref" href="#Ord_Integer:_gt_eq">Ord_Integer.&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integer:compareTo">Integer.compareTo</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integral_Integer:_minus">Integral_Integer.-</A>, <A class="fref" href="#Integral_Integer:_plus">Integral_Integer.+</A>, <A class="fref" href="#Integral_Integer:_star">Integral_Integer.*</A>, <A class="fref" href="#Integral_Integer:band">Integral_Integer.band</A>, <A class="fref" href="#Integral_Integer:bor">Integral_Integer.bor</A>, <A class="fref" href="#Integral_Integer:mod">Integral_Integer.mod</A>, <A class="fref" href="#Integral_Integer:bxor">Integral_Integer.bxor</A>, <A class="fref" href="#Integral_Integer:div">Integral_Integer.div</A>, <A class="fref" href="#Integral_Integer:rem">Integral_Integer.rem</A>, <A class="fref" href="#Integral_Integer:subtract">Integral_Integer.subtract</A>, <A class="fref" href="#Ord_Integer:max">Ord_Integer.max</A>, <A class="fref" href="#Ord_Integer:min">Ord_Integer.min</A>, <A class="fref" href="#Integer:nMod">Integer.nMod</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Integer:_lt_eq_gt">Ord_Integer.&lt;=&gt;</A>, <A class="fref" href="#Ord_Integer:compare">Ord_Integer.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integral_Integer:isNaN">Integral_Integer.isNaN</A>, <A class="fref" href="#Integral_Integer:isInfinite">Integral_Integer.isInfinite</A>, <A class="fref" href="#Integral_Integer:isNumber">Integral_Integer.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Integer:ord">Enum_Integer.ord</A>, <A class="fref" href="#Integral_Integer:sign">Integral_Integer.sign</A>, <A class="fref" href="#Integer:bitLength">Integer.bitLength</A>, <A class="fref" href="#Integer:_int">Integer.int</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Integer:pred">Enum_Integer.pred</A>, <A class="fref" href="#Enum_Integer:succ">Enum_Integer.succ</A>, <A class="fref" href="#Integral_Integer:abs">Integral_Integer.abs</A>, <A class="fref" href="#Integral_Integer:negate">Integral_Integer.negate</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integer:_long">Integer.long</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integer:toString">Integer.toString</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#JException">JException</A> -&gt; <A class="tref" href="#Class">Class</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#JException:getClass">JException.getClass</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#JException">JException</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#JException:catched">JException.catched</A>, <A class="fref" href="#JException:getLocalizedMessage">JException.getLocalizedMessage</A>, <A class="fref" href="#JException:getMessage">JException.getMessage</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#JException">JException</A> -&gt; <A class="tref" href="#Undefined">Undefined</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Undefined:newX">Undefined.newX</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integral_Long:bshr">Integral_Long.bshr</A>, <A class="fref" href="#Integral_Long:bshl">Integral_Long.bshl</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A> -&gt; [<A class="tref" href="#Long">Long</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Long:_dot_dot">Enum_Long...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Eq_Long:_div_eq">Eq_Long./=</A>, <A class="fref" href="#Eq_Long:_excl_eq">Eq_Long.!=</A>, <A class="fref" href="#Eq_Long:_eq_eq">Eq_Long.==</A>, <A class="fref" href="#Ord_Long:_gt">Ord_Long.&gt;</A>, <A class="fref" href="#Ord_Long:_lt_eq">Ord_Long.&lt;=</A>, <A class="fref" href="#Ord_Long:_lt">Ord_Long.&lt;</A>, <A class="fref" href="#Ord_Long:_gt_eq">Ord_Long.&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integral_Long:bor">Integral_Long.bor</A>, <A class="fref" href="#Integral_Long:band">Integral_Long.band</A>, <A class="fref" href="#Integral_Long:div">Integral_Long.div</A>, <A class="fref" href="#Integral_Long:bxor">Integral_Long.bxor</A>, <A class="fref" href="#Integral_Long:rem">Integral_Long.rem</A>, <A class="fref" href="#Integral_Long:mod">Integral_Long.mod</A>, <A class="fref" href="#Num_Long:_minus">Num_Long.-</A>, <A class="fref" href="#Num_Long:_plus">Num_Long.+</A>, <A class="fref" href="#Num_Long:_star">Num_Long.*</A>, <A class="fref" href="#Num_Long:subtract">Num_Long.subtract</A>, <A class="fref" href="#Ord_Long:max">Ord_Long.max</A>, <A class="fref" href="#Ord_Long:min">Ord_Long.min</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_Long:_lt_eq_gt">Ord_Long.&lt;=&gt;</A>, <A class="fref" href="#Ord_Long:compare">Ord_Long.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Num_Long:isNaN">Num_Long.isNaN</A>, <A class="fref" href="#Num_Long:isInfinite">Num_Long.isInfinite</A>, <A class="fref" href="#Num_Long:isNumber">Num_Long.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Long:_double">Long.double</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Long:_float">Long.float</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Long:ord">Enum_Long.ord</A>, <A class="fref" href="#Num_Long:sign">Num_Long.sign</A>, <A class="fref" href="#Long:_int">Long.int</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntegerConvertable_Long:big">IntegerConvertable_Long.big</A>, <A class="fref" href="#Integer:valueOf">Integer.valueOf</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum_Long:pred">Enum_Long.pred</A>, <A class="fref" href="#Enum_Long:succ">Enum_Long.succ</A>, <A class="fref" href="#Num_Long:abs">Num_Long.abs</A>, <A class="fref" href="#Num_Long:negate">Num_Long.negate</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#Bool">Bool</A> -&gt; <A class="tref" href="#Matcher">Matcher</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Matcher:useAnchoringBounds">Matcher.useAnchoringBounds</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Matcher:group">Matcher.group</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Matcher:end">Matcher.end</A>, <A class="fref" href="#Matcher:start">Matcher.start</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#Matcher">Matcher</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_qm_tilde">?~</A>, <A class="fref" href="#Matcher:usePatternAndFind">Matcher.usePatternAndFind</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_div_tilde">/~</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Matcher">Matcher</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Matcher:usePattern">Matcher.usePattern</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Matcher:replaceAll">Matcher.replaceAll</A>, <A class="fref" href="#Matcher:replaceFirst">Matcher.replaceFirst</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#Matcher">Matcher</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Matcher:find">Matcher.find</A>, <A class="fref" href="#Matcher:matches">Matcher.matches</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#Matcher">Matcher</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Matcher:clone">Matcher.clone</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Matcher">Matcher</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Matcher:match">Matcher.match</A>, <A class="fref" href="#Matcher:toString">Matcher.toString</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Regex:split">Regex.split</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#String">String</A> -&gt; [<A class="tref" href="#String">String</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Regex:splitted">Regex.splitted</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Matcher">Matcher</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Regex:matcher">Regex.matcher</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Regex:pattern">Regex.pattern</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#substr">substr</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:charAt">String.charAt</A>, <A class="fref" href="#String:elemAt">String.elemAt</A>, <A class="fref" href="#String:frozenGetAt">String.frozenGetAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strhead">strhead</A>, <A class="fref" href="#strtail">strtail</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#JException">JException</A> -&gt; <A class="tref" href="#Undefined">Undefined</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Undefined:newSX">Undefined.newSX</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_tilde_tilde_tilde">~~~</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#Matcher">Matcher</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_eq_tilde">=~</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_tilde_tilde">~~</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Regex">Regex</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_excl_tilde">!~</A>, <A class="fref" href="#_tilde">~</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Eq_String:_div_eq">Eq_String./=</A>, <A class="fref" href="#Eq_String:_excl_eq">Eq_String.!=</A>, <A class="fref" href="#Eq_String:_eq_eq">Eq_String.==</A>, <A class="fref" href="#Ord_String:_gt">Ord_String.&gt;</A>, <A class="fref" href="#Ord_String:_lt_eq">Ord_String.&lt;=</A>, <A class="fref" href="#Ord_String:_lt">Ord_String.&lt;</A>, <A class="fref" href="#Ord_String:_gt_eq">Ord_String.&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:compareTo">String.compareTo</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord_String:_lt_eq_gt">Ord_String.&lt;=&gt;</A>, <A class="fref" href="#Ord_String:compare">Ord_String.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#AbstractList_String:_plus_plus">AbstractList_String.++</A>, <A class="fref" href="#Ord_String:max">Ord_String.max</A>, <A class="fref" href="#Ord_String:min">Ord_String.min</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Class">Class</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Class:forName">Class.forName</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:_double">String.double</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:_float">String.float</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:_int">String.int</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:integer">String.integer</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:_long">String.long</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> <A class="tref" href="#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#regcomp">regcomp</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A> <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#printStr">printStr</A>, <A class="fref" href="#printStrLn">printStrLn</A>, <A class="fref" href="#traceStr">traceStr</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; [<A class="tref" href="#Char">Char</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#stocs">stocs</A>, <A class="fref" href="#unpacked">unpacked</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#trace">trace</A>, <A class="fref" href="#traceLn">traceLn</A>, <A class="fref" href="#Empty_String:_null">Empty_String.null</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:atod">String.atod</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:atof">String.atof</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#atoi">atoi</A>, <A class="fref" href="#Length_String:length">Length_String.length</A>, <A class="fref" href="#String:atoi">String.atoi</A>, <A class="fref" href="#String:hashCode">String.hashCode</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:aton">String.aton</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:atol">String.atol</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#String:compile">String.compile</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#AbstractList_String:tail">AbstractList_String.tail</A>, <A class="fref" href="#String:quote">String.quote</A>, <A class="fref" href="#String:toLowerCase">String.toLowerCase</A>, <A class="fref" href="#String:quoteReplacement">String.quoteReplacement</A>, <A class="fref" href="#String:toUpperCase">String.toUpperCase</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Undefined">Undefined</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Undefined:_new">Undefined.new</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Undefined">Undefined</A> -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Undefined:die">Undefined.die</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Undefined">Undefined</A> -&gt; <A class="tref" href="#JException">JException</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Undefined:toException">Undefined.toException</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Unit:Unit">().()</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#otherwise">otherwise</A>, <A class="fref" href="#Bounded_Bool:minBound">Bounded_Bool.minBound</A>, <A class="fref" href="#Bounded_Bool:maxBound">Bounded_Bool.maxBound</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Char">Char</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Bounded_Char:minBound">Bounded_Char.minBound</A>, <A class="fref" href="#Bounded_Char:maxBound">Bounded_Char.maxBound</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Double">Double</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Double:one">Real_Double.one</A>, <A class="fref" href="#Real_Double:zero">Real_Double.zero</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Float">Float</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real_Float:one">Real_Float.one</A>, <A class="fref" href="#Real_Float:zero">Real_Float.zero</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Immutable:Immutable">Immutable.Immutable</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Bounded_Int:minBound">Bounded_Int.minBound</A>, <A class="fref" href="#Bounded_Int:maxBound">Bounded_Int.maxBound</A>, <A class="fref" href="#Num_Int:one">Num_Int.one</A>, <A class="fref" href="#Num_Int:zero">Num_Int.zero</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integral_Integer:one">Integral_Integer.one</A>, <A class="fref" href="#Integral_Integer:zero">Integral_Integer.zero</A>, <A class="fref" href="#Integer:ten">Integer.ten</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Long">Long</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Bounded_Long:minBound">Bounded_Long.minBound</A>, <A class="fref" href="#Bounded_Long:maxBound">Bounded_Long.maxBound</A>, <A class="fref" href="#Num_Long:one">Num_Long.one</A>, <A class="fref" href="#Num_Long:zero">Num_Long.zero</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ordering:Gt">Ordering.Gt</A>, <A class="fref" href="#Ordering:Eq">Ordering.Eq</A>, <A class="fref" href="#Ordering:Lt">Ordering.Lt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#RealWorld">RealWorld</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#RealWorld:RealWorld">RealWorld.RealWorld</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#String">String</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Empty_String:empty">Empty_String.empty</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#ST">ST</A> <A class="tref" href="#RealWorld">RealWorld</A> a -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#ST:performUnsafe">ST.performUnsafe</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A> -&gt; [(<A class="tref" href="#Int">Int</A>, a)]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:toInxList">STArray.toInxList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A> -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:toList">STArray.toList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> elem.<A class="tref" href="#STArray">STArray</A> elem <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> elem</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:frozenGetAt">STArray.frozenGetAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> elem.<A class="tref" href="#STArray">STArray</A> elem <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; elem</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:frozenElemAt">STArray.frozenElemAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#IntArray">IntArray</A> a)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_IntArray:thaw">Cloneable_IntArray.thaw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#IntArray">IntArray</A> a -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_IntArray:freeze">Cloneable_IntArray.freeze</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s.<A class="tref" href="#IntArray">IntArray</A> s -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:setAt">IntArray.setAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s.<A class="tref" href="#IntArray">IntArray</A> s -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:getAt">IntArray.getAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s.<A class="tref" href="#IntArray">IntArray</A> s -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_IntArray:our">Cloneable_IntArray.our</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Maybe">Maybe</A> a -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#ListSource_Maybe:toList">ListSource_Maybe.toList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Maybe">Maybe</A> a -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#isJust">isJust</A>, <A class="fref" href="#isNothing">isNothing</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Maybe">Maybe</A> a -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#fromJust">fromJust</A>, <A class="fref" href="#unJust">unJust</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#StringArray">StringArray</A> a)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_StringArray:thaw">Cloneable_StringArray.thaw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#StringArray">StringArray</A> a -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_StringArray:freeze">Cloneable_StringArray.freeze</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s.<A class="tref" href="#StringArray">StringArray</A> s -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#StringArray:setAt">StringArray.setAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s.<A class="tref" href="#StringArray">StringArray</A> s -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#Maybe">Maybe</A> <A class="tref" href="#String">String</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#StringArray:getAt">StringArray.getAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s.<A class="tref" href="#StringArray">StringArray</A> s -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_StringArray:our">Cloneable_StringArray.our</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[(<A class="tref" href="#Int">Int</A>, <A class="tref" href="#Int">Int</A>)] -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#IntArray">IntArray</A> a)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:fromInxListST">IntArray.fromInxListST</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[(<A class="tref" href="#Int">Int</A>, a)] -&gt; <A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:fromInxList">STArray.fromInxList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[[a]] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#concat">concat</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[<A class="tref" href="#Int">Int</A>] -&gt; <A class="tref" href="#ST">ST</A> a (<A class="tref" href="#IntArray">IntArray</A> a)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:fromListST">IntArray.fromListST</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> u.[<A class="tref" href="#String">String</A>] -&gt; <A class="tref" href="#ST">ST</A> u (<A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#StringArray:fromListST">StringArray.fromListST</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[a] -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#AbstractList__lbrack_rbrack:_plus_plus">AbstractList_[].++</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[a] -&gt; <A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:fromList">STArray.fromList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#cycle">cycle</A>, <A class="fref" href="#init">init</A>, <A class="fref" href="#reverse">reverse</A>, <A class="fref" href="#AbstractList__lbrack_rbrack:tail">AbstractList_[].tail</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[a] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Empty__lbrack_rbrack:_null">Empty_[].null</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[a] -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Length__lbrack_rbrack:length">Length_[].length</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[a] -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#head">head</A>, <A class="fref" href="#last">last</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(a-&gt;a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; [a] -&gt; [[a]]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#groupBy">groupBy</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(a-&gt;a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#sortBy">sortBy</A>, <A class="fref" href="#uniqBy">uniqBy</A>, <A class="fref" href="#uniqueBy">uniqueBy</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(a-&gt;a-&gt;a) -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#scanl1">scanl1</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(a-&gt;a-&gt;a) -&gt; [a] -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#foldl1">foldl1</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; [a] -&gt; ([a], [a])</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#partition">partition</A>, <A class="fref" href="#span">span</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#dropUntil">dropUntil</A>, <A class="fref" href="#dropWhile">dropWhile</A>, <A class="fref" href="#filter">filter</A>, <A class="fref" href="#takeUntil">takeUntil</A>, <A class="fref" href="#takeWhile">takeWhile</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(a-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; [a] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#all">all</A>, <A class="fref" href="#any">any</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(a-&gt;a) -&gt; a -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#iterate">iterate</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(a-&gt;a) -&gt; <A class="tref" href="#State">State</A> a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#State:change">State.change</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Bool">Bool</A> -&gt; a -&gt; a -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#lazyif">lazyif</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Int">Int</A> -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#drop">drop</A>, <A class="fref" href="#take">take</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s.<A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#IntArray">IntArray</A> s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntArray:_new">IntArray.new</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s.<A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#StringArray">StringArray</A> s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#StringArray:_new">StringArray.new</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#JException">JException</A> -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_throw">throw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_Maybe:fail">Monad_Maybe.fail</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> u.<A class="tref" href="#String">String</A> -&gt; u</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#error">error</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.a -&gt; <A class="tref" href="#Maybe">Maybe</A> a -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#fromMaybe">fromMaybe</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.a -&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#intersperse">intersperse</A>, <A class="fref" href="#List:Cons">[].:</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.a -&gt; a -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_excl_eq_eq">!==</A>, <A class="fref" href="#_eq_eq_eq">===</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.a -&gt; <A class="tref" href="#State">State</A> a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#State:put">State.put</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.a -&gt; <A class="tref" href="#Maybe">Maybe</A> a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_Maybe:_return">Monad_Maybe.return</A>, <A class="fref" href="#Maybe:Just">Maybe.Just</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.a -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#repeat">repeat</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.a -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#constructor">constructor</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.a -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#id">id</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.(<B>forall</B> r.<A class="tref" href="#ST">ST</A> r a) -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#ST:run">ST.run</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> this.<A class="tref" href="#AbstractList">AbstractList</A> this =&gt; this -&gt; this -&gt; this</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#AbstractList:_plus_plus">AbstractList.++</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> this.<A class="tref" href="#AbstractList">AbstractList</A> this =&gt; this -&gt; this</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#AbstractList:tail">AbstractList.tail</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> this.<A class="tref" href="#Empty">Empty</A> this =&gt; this -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Empty:_null">Empty.null</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; <A class="tref" href="#Int">Int</A> -&gt; e</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum:from">Enum.from</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; e -&gt; e -&gt; [e]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum:_dot_dot">Enum...</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; e -&gt; e -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum:_lt_eq_gt">Enum.&lt;=&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; e -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum:ord">Enum.ord</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> e.<A class="tref" href="#Enum">Enum</A> e =&gt; e -&gt; e</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Enum:succ">Enum.succ</A>, <A class="fref" href="#Enum:pred">Enum.pred</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; [a] -&gt; [a] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Eq__lbrack_rbrack:_div_eq">Eq_[]./=</A>, <A class="fref" href="#Eq__lbrack_rbrack:_excl_eq">Eq_[].!=</A>, <A class="fref" href="#Eq__lbrack_rbrack:_eq_eq">Eq_[].==</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; [a] -&gt; [[a]]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#group">group</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#uniq">uniq</A>, <A class="fref" href="#unique">unique</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Eq">Eq</A> a =&gt; a -&gt; [a] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#elem">elem</A>, <A class="fref" href="#notElem">notElem</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> eq.<A class="tref" href="#Eq">Eq</A> eq =&gt; eq -&gt; eq -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Eq:_div_eq">Eq./=</A>, <A class="fref" href="#Eq:_excl_eq">Eq.!=</A>, <A class="fref" href="#Eq:_eq_eq">Eq.==</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> this.<A class="tref" href="#IntegerConvertable">IntegerConvertable</A> this =&gt; this -&gt; <A class="tref" href="#Integer">Integer</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#IntegerConvertable:big">IntegerConvertable.big</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; <A class="tref" href="#Int">Int</A> -&gt; integ</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integral:bshr">Integral.bshr</A>, <A class="fref" href="#Integral:bshl">Integral.bshl</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> integ.<A class="tref" href="#Integral">Integral</A> integ =&gt; integ -&gt; integ -&gt; integ</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Integral:bor">Integral.bor</A>, <A class="fref" href="#Integral:band">Integral.band</A>, <A class="fref" href="#Integral:div">Integral.div</A>, <A class="fref" href="#Integral:bxor">Integral.bxor</A>, <A class="fref" href="#Integral:mod">Integral.mod</A>, <A class="fref" href="#Integral:rem">Integral.rem</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> this.<A class="tref" href="#Length">Length</A> this =&gt; this -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Length:length">Length.length</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Monad">Monad</A> a =&gt; <A class="tref" href="#Bool">Bool</A> -&gt; a <A class="tref" href="#Unit">()</A> -&gt; a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#unless">unless</A>, <A class="fref" href="#when">when</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; <A class="tref" href="#Int">Int</A> -&gt; n</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Num:fromInt">Num.fromInt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; n -&gt; n</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Num:_minus">Num.-</A>, <A class="fref" href="#Num:_plus">Num.+</A>, <A class="fref" href="#Num:_star">Num.*</A>, <A class="fref" href="#Num:subtract">Num.subtract</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Num:isNaN">Num.isNaN</A>, <A class="fref" href="#Num:isInfinite">Num.isInfinite</A>, <A class="fref" href="#Num:isNumber">Num.isNumber</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Num:sign">Num.sign</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n -&gt; n</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Num:abs">Num.abs</A>, <A class="fref" href="#Num:negate">Num.negate</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Ord">Ord</A> a =&gt; [a] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#sort">sort</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord:_lt_eq">Ord.&lt;=</A>, <A class="fref" href="#Ord:_lt">Ord.&lt;</A>, <A class="fref" href="#Ord:_excl_eq">Ord.!=</A>, <A class="fref" href="#Ord:_gt_eq">Ord.&gt;=</A>, <A class="fref" href="#Ord:_eq_eq">Ord.==</A>, <A class="fref" href="#Ord:_gt">Ord.&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; <A class="tref" href="#Ordering">Ordering</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord:_lt_eq_gt">Ord.&lt;=&gt;</A>, <A class="fref" href="#Ord:compare">Ord.compare</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> ord.<A class="tref" href="#Ord">Ord</A> ord =&gt; ord -&gt; ord -&gt; ord</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Ord:max">Ord.max</A>, <A class="fref" href="#Ord:min">Ord.min</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> r.<A class="tref" href="#Real">Real</A> r =&gt; r -&gt; r -&gt; r</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Real:_div">Real./</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#ST">ST</A> a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_void">void</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#State">State</A> a a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#State:get">State.get</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="#Maybe">Maybe</A> a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Maybe:Nothing">Maybe.Nothing</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.[a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Empty__lbrack_rbrack:empty">Empty_[].empty</A>, <A class="fref" href="#List:List">[].[]</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> u.u</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#undefined">undefined</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b.<A class="tref" href="#Bounded">Bounded</A> b =&gt; b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Bounded:minBound">Bounded.minBound</A>, <A class="fref" href="#Bounded:maxBound">Bounded.maxBound</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> this.<A class="tref" href="#Empty">Empty</A> this =&gt; this</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Empty:empty">Empty.empty</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> n.<A class="tref" href="#Num">Num</A> n =&gt; n</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Num:one">Num.one</A>, <A class="fref" href="#Num:zero">Num.zero</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.(a, b) -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#fst">fst</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.(a, b) -&gt; b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#snd">snd</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#Either">Either</A> a b -&gt; [b]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#ListSource_Either:toList">ListSource_Either.toList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#ST">ST</A> b (<A class="tref" href="#STArray">STArray</A> a b)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_STArray:thaw">Cloneable_STArray.thaw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#STArray">STArray</A> a b -&gt; <A class="tref" href="#ST">ST</A> b (<A class="tref" href="#STArray">STArray</A> a <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_STArray:freeze">Cloneable_STArray.freeze</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s elem.<A class="tref" href="#STArray">STArray</A> elem s -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#Maybe">Maybe</A> elem -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:setAtMB">STArray.setAtMB</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s elem.<A class="tref" href="#STArray">STArray</A> elem s -&gt; <A class="tref" href="#Int">Int</A> -&gt; elem -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:setAt">STArray.setAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s elem.<A class="tref" href="#STArray">STArray</A> elem s -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#Maybe">Maybe</A> elem)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:getAt">STArray.getAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s elem.<A class="tref" href="#STArray">STArray</A> elem s -&gt; <A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s elem</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:elemAt">STArray.elemAt</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s elem.<A class="tref" href="#STArray">STArray</A> elem s -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#STArray">STArray</A> elem <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_STArray:our">Cloneable_STArray.our</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> elem x.<A class="tref" href="#STArray">STArray</A> elem x -&gt; <A class="tref" href="#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:length">STArray.length</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s a.<A class="tref" href="#STRef">STRef</A> a s -&gt; a -&gt; <A class="tref" href="#ST">ST</A> s <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STRef:put">STRef.put</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s a.<A class="tref" href="#STRef">STRef</A> a s -&gt; <A class="tref" href="#ST">ST</A> s a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STRef:get">STRef.get</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#State">State</A> a b -&gt; a -&gt; (b, a)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#State:run">State.run</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#IntArray">IntArray</A> a -&gt; (<A class="tref" href="#IntArray">IntArray</A> <A class="tref" href="#Immutable">Immutable</A>-&gt;b) -&gt; <A class="tref" href="#ST">ST</A> a b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_IntArray:withFrozen">Cloneable_IntArray.withFrozen</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#IntArray">IntArray</A> a -&gt; <A class="tref" href="#IntArray">IntArray</A> b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_IntArray:clone">Cloneable_IntArray.clone</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#Maybe">Maybe</A> a -&gt; <A class="tref" href="#Maybe">Maybe</A> b -&gt; <A class="tref" href="#Maybe">Maybe</A> b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_Maybe:_gt_gt">Monad_Maybe.&gt;&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#Maybe">Maybe</A> a -&gt; (a-&gt;<A class="tref" href="#Maybe">Maybe</A> b) -&gt; <A class="tref" href="#Maybe">Maybe</A> b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_Maybe:_gt_gt_eq">Monad_Maybe.&gt;&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#StringArray">StringArray</A> a -&gt; (<A class="tref" href="#StringArray">StringArray</A> <A class="tref" href="#Immutable">Immutable</A>-&gt;b) -&gt; <A class="tref" href="#ST">ST</A> a b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_StringArray:withFrozen">Cloneable_StringArray.withFrozen</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#StringArray">StringArray</A> a -&gt; <A class="tref" href="#StringArray">StringArray</A> b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_StringArray:clone">Cloneable_StringArray.clone</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s a.[(<A class="tref" href="#Int">Int</A>, a)] -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#STArray">STArray</A> a s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:fromInxListST">STArray.fromInxListST</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.[(a, b)] -&gt; ([a], [b])</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#unzip">unzip</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.[a] -&gt; [b] -&gt; [(a, b)]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#zip">zip</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> u elem.[elem] -&gt; <A class="tref" href="#ST">ST</A> u (<A class="tref" href="#STArray">STArray</A> elem u)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:fromListST">STArray.fromListST</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.(a-&gt;b-&gt;<A class="tref" href="#Bool">Bool</A>) -&gt; a -&gt; [b] -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#elemBy">elemBy</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.(a-&gt;b-&gt;a) -&gt; a -&gt; [b] -&gt; [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#scanl">scanl</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.(a-&gt;b-&gt;a) -&gt; a -&gt; [b] -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#fold">fold</A>, <A class="fref" href="#foldl">foldl</A>, <A class="fref" href="#foldl_tick">foldl'</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.(a-&gt;b-&gt;b) -&gt; b -&gt; [a] -&gt; b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#foldrs">foldrs</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.(a-&gt;b) -&gt; <A class="tref" href="#Maybe">Maybe</A> a -&gt; <A class="tref" href="#Maybe">Maybe</A> b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Functor_Maybe:fmap">Functor_Maybe.fmap</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.(a-&gt;b) -&gt; [a] -&gt; [b]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#map">map</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a.(a-&gt;b) -&gt; a -&gt; <A class="tref" href="#Either">Either</A> <A class="tref" href="#JException">JException</A> b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_try">try</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.(a-&gt;b) -&gt; a -&gt; b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_dollar">$</A>, <A class="fref" href="#$_excl">$!</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a e.(e-&gt;a-&gt;a) -&gt; a -&gt; [e] -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#foldr">foldr</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s a.(s-&gt;(a, s)) -&gt; <A class="tref" href="#State">State</A> s a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#State:State">State.State</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> s a.(s-&gt;a) -&gt; <A class="tref" href="#ST">ST</A> s a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#ST:ST">ST.ST</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> elem s.<A class="tref" href="#Int">Int</A> -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#STArray">STArray</A> elem s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STArray:_new">STArray.new</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#Either">Either</A> a b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_Either:fail">Monad_Either.fail</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#ST">ST</A> a b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_ST:fail">Monad_ST.fail</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#String">String</A> -&gt; <A class="tref" href="#State">State</A> a b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_State:fail">Monad_State.fail</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.a -&gt; (b-&gt;a) -&gt; <A class="tref" href="#Maybe">Maybe</A> b -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#maybe">maybe</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.a -&gt; b -&gt; (a, b)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple2">strictTuple2</A>, <A class="fref" href="#Tuple2:Tuple2">(,).(,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.a -&gt; b -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_const">const</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.a -&gt; b -&gt; b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#seq">seq</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.a -&gt; <A class="tref" href="#Either">Either</A> a b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Either:Left">Either.Left</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.a -&gt; <A class="tref" href="#Either">Either</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_Either:_return">Monad_Either.return</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.a -&gt; <A class="tref" href="#ST">ST</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_ST:_return">Monad_ST.return</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a s.a -&gt; <A class="tref" href="#ST">ST</A> s (<A class="tref" href="#STRef">STRef</A> a s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#STRef:_new">STRef.new</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.a -&gt; <A class="tref" href="#State">State</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_State:_return">Monad_State.return</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.b -&gt; <A class="tref" href="#Either">Either</A> a b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Either:Right">Either.Right</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> f s.<A class="tref" href="#Cloneable">Cloneable</A> f =&gt; f <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#ST">ST</A> s (f s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable:thaw">Cloneable.thaw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> f s.<A class="tref" href="#Cloneable">Cloneable</A> f =&gt; f s -&gt; <A class="tref" href="#ST">ST</A> s (f <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable:freeze">Cloneable.freeze</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#Eq">Eq</A> b =&gt; (a-&gt;b) -&gt; a -&gt; a -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#using">using</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> f s.<A class="tref" href="#Freezable">Freezable</A> f =&gt; f <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#ST">ST</A> s (f s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Freezable:thaw">Freezable.thaw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> f s.<A class="tref" href="#Freezable">Freezable</A> f =&gt; f s -&gt; <A class="tref" href="#ST">ST</A> s (f <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Freezable:our">Freezable.our</A>, <A class="fref" href="#Freezable:freeze">Freezable.freeze</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> t e.<A class="tref" href="#ListSource">ListSource</A> t =&gt; t e -&gt; [e]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#ListSource:toList">ListSource.toList</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#Monad">Monad</A> a =&gt; [a b] -&gt; a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#sequence_">sequence_</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> m a.<A class="tref" href="#Monad">Monad</A> m =&gt; [m a] -&gt; m [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#sequence">sequence</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> m a.<A class="tref" href="#Monad">Monad</A> m =&gt; <A class="tref" href="#String">String</A> -&gt; m a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad:fail">Monad.fail</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> m a.<A class="tref" href="#Monad">Monad</A> m =&gt; a -&gt; m a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad:_return">Monad.return</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="#Ord">Ord</A> b =&gt; (a-&gt;b) -&gt; a -&gt; a -&gt; <A class="tref" href="#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#ascending">ascending</A>, <A class="fref" href="#comparing">comparing</A>, <A class="fref" href="#descending">descending</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> f s.<A class="tref" href="#Serializable">Serializable</A> f =&gt; f <A class="tref" href="#Immutable">Immutable</A> -&gt; <A class="tref" href="#ST">ST</A> s (f s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Serializable:thaw">Serializable.thaw</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> f s.<A class="tref" href="#Serializable">Serializable</A> f =&gt; f s -&gt; <A class="tref" href="#ST">ST</A> s (f <A class="tref" href="#Immutable">Immutable</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Serializable:freeze">Serializable.freeze</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#Either">Either</A> b c -&gt; <A class="tref" href="#Either">Either</A> b a -&gt; <A class="tref" href="#Either">Either</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_Either:_gt_gt">Monad_Either.&gt;&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#Either">Either</A> b c -&gt; (c-&gt;<A class="tref" href="#Either">Either</A> b a) -&gt; <A class="tref" href="#Either">Either</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_Either:_gt_gt_eq">Monad_Either.&gt;&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#ST">ST</A> b c -&gt; <A class="tref" href="#ST">ST</A> b a -&gt; <A class="tref" href="#ST">ST</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_ST:_gt_gt">Monad_ST.&gt;&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#ST">ST</A> b c -&gt; (c-&gt;<A class="tref" href="#ST">ST</A> b a) -&gt; <A class="tref" href="#ST">ST</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_ST:_gt_gt_eq">Monad_ST.&gt;&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#STArray">STArray</A> b a -&gt; (<A class="tref" href="#STArray">STArray</A> b <A class="tref" href="#Immutable">Immutable</A>-&gt;c) -&gt; <A class="tref" href="#ST">ST</A> a c</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_STArray:withFrozen">Cloneable_STArray.withFrozen</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#STArray">STArray</A> b c -&gt; <A class="tref" href="#STArray">STArray</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable_STArray:clone">Cloneable_STArray.clone</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#State">State</A> b c -&gt; <A class="tref" href="#State">State</A> b a -&gt; <A class="tref" href="#State">State</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_State:_gt_gt">Monad_State.&gt;&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#State">State</A> b c -&gt; (c-&gt;<A class="tref" href="#State">State</A> b a) -&gt; <A class="tref" href="#State">State</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad_State:_gt_gt_eq">Monad_State.&gt;&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.((a, c)-&gt;b) -&gt; a -&gt; c -&gt; b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#uncurry">uncurry</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.(a-&gt;c-&gt;b) -&gt; [a] -&gt; [c] -&gt; [b]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#zipWith">zipWith</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.(a-&gt;b) -&gt; (c-&gt;a) -&gt; c -&gt; b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_at">@</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.(b-&gt;a-&gt;c) -&gt; (b, a) -&gt; c</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#curry">curry</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.(b-&gt;a-&gt;c) -&gt; a -&gt; b -&gt; c</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#flip">flip</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.(b-&gt;a) -&gt; (c-&gt;a) -&gt; <A class="tref" href="#Either">Either</A> b c -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#either">either</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.(b-&gt;a) -&gt; (c-&gt;b) -&gt; c -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_lt_tilde">&lt;~</A>, <A class="fref" href="#_bullet">•</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.(c-&gt;a) -&gt; <A class="tref" href="#Either">Either</A> b c -&gt; <A class="tref" href="#Either">Either</A> b a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Functor_Either:fmap">Functor_Either.fmap</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.(c-&gt;b) -&gt; (b-&gt;a) -&gt; c -&gt; a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#_tilde_gt">~&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a s.(s-&gt;(a, s)) -&gt; (a-&gt;<A class="tref" href="#State">State</A> s b) -&gt; s -&gt; (b, s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#State:bind">State.bind</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> y x z.(x-&gt;y) -&gt; (y-&gt;<A class="tref" href="#ST">ST</A> x z) -&gt; x -&gt; z</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#ST:bind">ST.bind</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a c.a -&gt; b -&gt; c -&gt; (a, b, c)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple3">strictTuple3</A>, <A class="fref" href="#Tuple3:Tuple3">(,,).(,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a f.<A class="tref" href="#Cloneable">Cloneable</A> f =&gt; f a -&gt; f b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Cloneable:clone">Cloneable.clone</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> f s a.<A class="tref" href="#Freezable">Freezable</A> f =&gt; f s -&gt; (f <A class="tref" href="#Immutable">Immutable</A>-&gt;a) -&gt; <A class="tref" href="#ST">ST</A> s a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Freezable:withFrozen">Freezable.withFrozen</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a f.<A class="tref" href="#Functor">Functor</A> f =&gt; (a-&gt;b) -&gt; f a -&gt; f b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Functor:fmap">Functor.fmap</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#Monad">Monad</A> a =&gt; (b-&gt;c-&gt;a b) -&gt; b -&gt; [c] -&gt; a <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#foldM_">foldM_</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#Monad">Monad</A> b =&gt; [c] -&gt; (c-&gt;b a) -&gt; b [a]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#forM">forM</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#Monad">Monad</A> b =&gt; [c] -&gt; (c-&gt;b a) -&gt; b <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#forM_">forM_</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c.<A class="tref" href="#Monad">Monad</A> b =&gt; (c-&gt;b a) -&gt; [c] -&gt; b <A class="tref" href="#Unit">()</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#mapM_">mapM_</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; m a -&gt; m b -&gt; m b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad:_gt_gt">Monad.&gt;&gt;</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; m a -&gt; (a-&gt;m b) -&gt; m b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Monad:_gt_gt_eq">Monad.&gt;&gt;=</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; (a-&gt;m b) -&gt; [a] -&gt; m [b]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#mapM">mapM</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; (a-&gt;b-&gt;m a) -&gt; a -&gt; [b] -&gt; m a</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#foldM">foldM</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a m.<A class="tref" href="#Monad">Monad</A> m =&gt; (a-&gt;b) -&gt; m a -&gt; m b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#liftM">liftM</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a f.<A class="tref" href="#Serializable">Serializable</A> f =&gt; f a -&gt; f b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#Serializable:copySerializable">Serializable.copySerializable</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a c d.a -&gt; b -&gt; c -&gt; d -&gt; (a, b, c, d)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple4">strictTuple4</A>, <A class="fref" href="#Tuple4:Tuple4">(,,,).(,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c d.<A class="tref" href="#Monad">Monad</A> c =&gt; (a-&gt;d-&gt;b) -&gt; c a -&gt; c d -&gt; c b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#liftM2">liftM2</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> b a d c e.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; (a, b, c, d, e)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple5">strictTuple5</A>, <A class="fref" href="#Tuple5:Tuple5">(,,,,).(,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c d e.<A class="tref" href="#Monad">Monad</A> b =&gt; (d-&gt;a-&gt;e-&gt;c) -&gt; b d -&gt; b a -&gt; b e -&gt; b c</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#liftM3">liftM3</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> d b a c e f.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; (a, b, c, d, e, f)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple6">strictTuple6</A>, <A class="fref" href="#Tuple6:Tuple6">(,,,,,).(,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b c d e f.<A class="tref" href="#Monad">Monad</A> b =&gt; (d-&gt;a-&gt;e-&gt;f-&gt;c) -&gt; b d -&gt; b a -&gt; b e -&gt; b f -&gt; b c</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#liftM4">liftM4</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> d b a c f e g.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; (a, b, c, d, e, f, g)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple7">strictTuple7</A>, <A class="fref" href="#Tuple7:Tuple7">(,,,,,,).(,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> d b a c f e g h.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; (a, b, c, d, e, f, g, h)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple8">strictTuple8</A>, <A class="fref" href="#Tuple8:Tuple8">(,,,,,,,).(,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> d b a c f e h g i.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; (a, b, c, d, e, f, g, h, i)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple9">strictTuple9</A>, <A class="fref" href="#Tuple9:Tuple9">(,,,,,,,,).(,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> d b a c h f e g i j.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; (a, b, c, d, e, f, g, h, i, j)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple10">strictTuple10</A>, <A class="fref" href="#Tuple10:Tuple10">(,,,,,,,,,).(,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> d b a c h f e g j i k.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; (a, b, c, d, e, f, g, h, i, j, k)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple11">strictTuple11</A>, <A class="fref" href="#Tuple11:Tuple11">(,,,,,,,,,,).(,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g j i k l.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; (a, b, c, d, e, f, g, h, i, j, k, l)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple12">strictTuple12</A>, <A class="fref" href="#Tuple12:Tuple12">(,,,,,,,,,,,).(,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g j i l k m.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple13">strictTuple13</A>, <A class="fref" href="#Tuple13:Tuple13">(,,,,,,,,,,,,).(,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g l j i k m n.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple14">strictTuple14</A>, <A class="fref" href="#Tuple14:Tuple14">(,,,,,,,,,,,,,).(,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g l j i k n m o.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple15">strictTuple15</A>, <A class="fref" href="#Tuple15:Tuple15">(,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g l j i k n m o p.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple16">strictTuple16</A>, <A class="fref" href="#Tuple16:Tuple16">(,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g l j i k n m p o q.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple17">strictTuple17</A>, <A class="fref" href="#Tuple17:Tuple17">(,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g l j i k p n m o q r.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple18">strictTuple18</A>, <A class="fref" href="#Tuple18:Tuple18">(,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g l j i k p n m o r q s.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple19">strictTuple19</A>, <A class="fref" href="#Tuple19:Tuple19">(,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g p l j i k n m o r q s t.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple20">strictTuple20</A>, <A class="fref" href="#Tuple20:Tuple20">(,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g p l j i k n m o r q t s u.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple21">strictTuple21</A>, <A class="fref" href="#Tuple21:Tuple21">(,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g p l j i k n m o t r q s u v.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple22">strictTuple22</A>, <A class="fref" href="#Tuple22:Tuple22">(,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> h d b a c f e g p l j i k n m o t r q s v u w.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; w -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple23">strictTuple23</A>, <A class="fref" href="#Tuple23:Tuple23">(,,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> p h d b a c f e g l j i k n m o t r q s v u w x.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; w -&gt; x -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple24">strictTuple24</A>, <A class="fref" href="#Tuple24:Tuple24">(,,,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> p h d b a c f e g l j i k n m o t r q s v u x w y.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; w -&gt; x -&gt; y -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple25">strictTuple25</A>, <A class="fref" href="#Tuple25:Tuple25">(,,,,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,,,,)</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> p h d b a c f e g l j i k n m o t r q s x v u w y z.a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h -&gt; i -&gt; j -&gt; k -&gt; l -&gt; m -&gt; n -&gt; o -&gt; p -&gt; q -&gt; r -&gt; s -&gt; t -&gt; u -&gt; v -&gt; w -&gt; x -&gt; y -&gt; z -&gt; (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#strictTuple26">strictTuple26</A>, <A class="fref" href="#Tuple26:Tuple26">(,,,,,,,,,,,,,,,,,,,,,,,,,).(,,,,,,,,,,,,,,,,,,,,,,,,,)</A></P>
</DD>
</DL>
<P>
<A HREF="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" height="31" width="88"></A></P>
</BODY>
</HTML>
