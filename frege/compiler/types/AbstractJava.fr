--- Definitions for the abstract Java language the compiler emits.
--- This is imported by Global, hence cannot use functions from Global

module frege.compiler.types.AbstractJava where

import frege.Prelude hiding(<+>, break)

import Compiler.common.Roman(romanUpper)

import Compiler.types.JNames
import Compiler.types.Types
import Data.Bits
import Data.BitSetJSON ()
import Data.JSON (ToJSON, toJSON)


{--
    Java Attributes like *@final@*, *@static@* etc.
    
    Attributes are printed in the order listed here, hence annotations
    come first.
 -}
data JAttr = JUnchecked  | JFunctionalInterface | JOverride | JRawTypes
                | JFinal | JPrivate | JPublic | JProtected | JStatic
                | JAbstract | JDefault  
 
derive Enum JAttr
derive Bounded JAttr
derive Show JAttr

instance ToJSON JAttr where
  toJSON = toJSON . show

type Attributes =  BitSet JAttr
type FormalArg  = (Attributes, Sigma, JType, String)



{--
    abstract (introduction of) type variable
-}
data JTVar = JTVar { !var ∷ String, !bounds ∷ JTypeBounds }

instance ToJSON JTVar where
  toJSON x = JSON.struct "JTVar" $ JSON.Struct
    [ JSON.assoc "var" x.var
    , JSON.assoc "bounds" x.bounds
    ]

{--
    the bounds for a 'JTVar' or a wildcard
-}
data JTypeBounds = 
      UNBOUNDED
    | EXTENDS [JType]       -- extends A & B
    | SUPER   JType         -- super T

derive Eq JTypeBounds

instance ToJSON JTypeBounds where
  toJSON UNBOUNDED = toJSON "UNBOUNDED"
  toJSON (EXTENDS jts) = JSON.struct "EXTENDS" jts
  toJSON (SUPER jt) = JSON.struct "SUPER" jt


{--
    abstract Java Type
 -}
data JType =

      !Ref   { jname :: JName,  gargs :: [JType] }
                        --- frege type (extends Lazy)

    | TArg  { !var   :: String }
                        --- type argument @A@
    
    | Wild   { !bounds :: JTypeBounds }
                        --- ? extends Foo

    | !Nativ { typ   :: String, gargs :: [JType], generic :: Bool }
                        {-- 
                            Native or array type

                            An array type looks like
                            >  Nativ { type = "[]", gargs = [elem]}
                            where @elem@ is the element type.

                            The gargs are only printed in Java code
                            when generic is @true@. Otherwise, the
                            gargs are treated as phantom types.

                            We need this to make String a higher kinded type, sort of.

                        -}
    -- Box    { !yields, !phantom  :: JType } 
    | Kinded { !arity :: Int, !gargs :: [JType] }

    | !Lazy  { yields :: JType }
                        --- a Thunk for some type

    | !Func  { gargs :: [JType] }
                        {-- function that can take @length gargs - 1@
                            arguments before yielding a result -} 

    | Constr    { !jname :: JName, !gargs :: [JType] }
                        --- a class constraint, must never be lazy
    | Something         {-- something unknown that can be casted
                            to the desired type -} 

!unboundedWild = Wild{bounds=UNBOUNDED}

--- construct a regular 'Nativ' type
nativ s gs = Nativ s gs true

derive Eq JType

instance ToJSON JType where
  toJSON (Ref{jname, gargs}) = JSON.struct "Ref" $ JSON.Struct
    [ JSON.assoc "jname" jname
    , JSON.assoc "gargs" gargs
    ]
  toJSON (TArg{var}) = JSON.struct "TArg" $ JSON.struct "var" var
  toJSON (Wild{bounds}) = JSON.struct "Wild" $ JSON.struct "bounds" bounds
  toJSON (Nativ{typ, gargs, generic}) = JSON.struct "Nativ" $ JSON.Struct
    [ JSON.assoc "typ" typ
    , JSON.assoc "gargs" gargs
    , JSON.assoc "generic" generic
    ]
  toJSON (Kinded{arity, gargs}) = JSON.struct "Kinded" $ JSON.Struct
    [ JSON.assoc "arity" arity
    , JSON.assoc "gargs" gargs
    ]
  toJSON (Lazy{yields}) = JSON.struct "Lazy" $ JSON.struct "yields" yields
  toJSON (Func{gargs}) = JSON.struct "Func" $ JSON.struct "gargs" gargs
  toJSON (Constr{jname, gargs}) = JSON.struct "Constr" $ JSON.Struct
    [ JSON.assoc "jname" jname
    , JSON.assoc "gargs" gargs
    ]
  toJSON Something = toJSON "Something"


--- Create a raw type (generated types possibly not functional, except for display)
rawType ∷ JType → JType

rawType Func{gargs}   = Ref (JName "Func" (romanUpper (length gargs - 1))) []
rawType Kinded{arity} = Ref (JName "Kind" (romanUpper arity))          []
rawType Nativ{typ="[]"} = Something
rawType jt
    | jt.{generic?}, not jt.generic = jt
    | jt.{gargs?} = jt.{gargs=[]}
    | otherwise   = jt

--- compute the raw java type name
rawName :: JType -> String
rawName Ref{jname}      = show jname
rawName TArg{var}       = var
rawName Nativ{typ="[]", gargs=[jt]} = rawName jt ++ "[]"
rawName Nativ{typ}      = typ
rawName Lazy{yields}    = rawName yields
rawName (jt@Func{})     = rawName (rawType jt)
rawName Something       = "java.lang.Object"
rawName Wild{}          = "?"
rawName (jt@Kinded{})   = rawName (rawType jt)
rawName Constr{jname, gargs} = show jname


{--
    abstract Java Expression
 -}
type JX = JExpr


data JExpr =
    JAtom {!name :: String}              --- local variable, null, this, true, false, literal etc.
    | JNew {!jt :: JType, !args :: [JExpr]}                 --- @new Foo(...)@
    | JNewClass {!jt :: JType, !args ::  [JExpr], 
                                !decls :: [JDecl]}          --- @new Foo(...) {...}@
    | JLambda {!fargs :: [FormalArg], !code :: (JExpr|JStmt)}       --- @(int a) -> return a+1@
    | JNewArray {!jt :: JType, !jex :: JExpr}               --- @new Foo[...]@
    | JInvoke {!jex :: JExpr, !args :: [JExpr]}             --- @foo(...)@
    | JStMem {!jt :: JType, !name :: String, !targs :: [JType]}           --- @X.name@
    | JExMem {!jex :: JExpr, !name :: String, 
                !targs :: [JType]}                          --- obj.m
    | JCast {!jt :: JType, !jex :: JExpr }                  --- (T)(x)
    | JUnop { !op :: String, !jex :: JExpr }                --- @!x@
    | JBin {!j1 :: JExpr, !op::String, !j2 :: JExpr}        --- @a + b@
    | JQC {!j1 :: JExpr, !j2 :: JExpr, !j3 :: JExpr}        --- a ? b : c
    | JArrayGet {!j1, !j2 :: JExpr }                        --- arr[i]
    where
        ---  Syntactic precedence of java constructs
        ---  Higher numbers mean more tight binding.
        prec JLambda{} = 1
        prec JQC{}     = 2
        prec JBin{}    = 3
        prec JUnop{}   = 4
        prec JCast{}   = 5
        prec JArrayGet{} = 6
        prec JExMem{}  = 9
        prec JStMem{}  = 9
        prec JInvoke{} = 9
        prec JAtom{}   = 9
        prec JNew{}    = 7
        prec JNewClass{} = 7
        prec JNewArray{} = 7
        --- create a 'JAtom'
        atom   = JAtom
        --- create an instance member without type arguments
        jexmem x s = JExMem{jex=x, name=s, targs=[]}
        --- @invoke args expr@ ---> expr.(args)
        invoke = flip JInvoke
        --- @new args type@    ---> new type(args)
        new    = flip JNew
        --- @cast type expr@   ---> (type) expr
        cast   = JCast
        --- @xmem "name" expr@  ---> expr.name
        xmem   = flip jexmem
        --- @static "forName" (Nativ "java.lang.Class" [A])@ ---> Class.<A>forName
        static name (t@Nativ{typ, gargs, generic})
                            = JStMem{jt = t.{gargs=[]} , name, targs=if generic then gargs else []}
        static name t
            | t.{gargs?}    = JStMem{jt = t.{gargs=[]} , name, targs=t.gargs}
            --Lazy x <- t   = JStMem{jt = Nativ "frege.run.Lazy" [], name, targs=[x]}
            | otherwise     = JStMem{jt = t, name, targs = []}
        --- make a 'JStMem' from a 'JName'
        staticMember (JName cl base) = JStMem{jt = nativ cl [], name = base, targs = []}

instance ToJSON JExpr where
  toJSON (JAtom{name}) = JSON.struct "JAtom" $ JSON.Struct
    [ JSON.assoc "name" name
    ]
  toJSON (JNew{jt, args}) = JSON.struct "JNew" $ JSON.Struct
    [ JSON.assoc "jt" jt
    , JSON.assoc "args" args
    ]
  toJSON (JNewClass{jt, args, decls}) = JSON.struct "JNewClass" $ JSON.Struct
    [ JSON.assoc "jt" jt
    , JSON.assoc "args" args
    , JSON.assoc "decls" decls
    ]
  toJSON (JLambda{fargs, code}) = JSON.struct "JLambda" $ JSON.Struct
    [ JSON.assoc "fargs" fargs
    , JSON.assoc "code" code
    ]
  toJSON (JNewArray{jt, jex}) = JSON.struct "JNewArray" $ JSON.Struct
    [ JSON.assoc "jt" jt
    , JSON.assoc "jex" jex
    ]
  toJSON (JInvoke{jex, args}) = JSON.struct "JInvoke" $ JSON.Struct
    [ JSON.assoc "jex" jex
    , JSON.assoc "args" args
    ]
  toJSON (JStMem{jt, name, targs}) = JSON.struct "JStMem" $ JSON.Struct
    [ JSON.assoc "jt" jt
    , JSON.assoc "name" name
    , JSON.assoc "targs" targs
    ]
  toJSON (JExMem{jex, name, targs}) = JSON.struct "JExMem" $ JSON.Struct
    [ JSON.assoc "jex" jex
    , JSON.assoc "name" name
    , JSON.assoc "targs" targs
    ]
  toJSON (JCast{jt, jex}) = JSON.struct "JCast" $ JSON.Struct
    [ JSON.assoc "jt" jt
    , JSON.assoc "jex" jex
    ]
  toJSON (JUnop{ op, jex}) = JSON.struct "JUnop" $ JSON.Struct
    [ JSON.assoc " op"  op
    , JSON.assoc "jex" jex
    ]
  toJSON (JBin{j1, op, j2}) = JSON.struct "JBin" $ JSON.Struct
    [ JSON.assoc "j1" j1
    , JSON.assoc "op" op
    , JSON.assoc "j2" j2
    ]
  toJSON (JQC{j1, j2, j3}) = JSON.struct "JQC" $ JSON.Struct
    [ JSON.assoc "j1" j1
    , JSON.assoc "j2" j2
    , JSON.assoc "j3" j3
    ]
  toJSON (JArrayGet{j1, j2}) = JSON.struct "JArrayGet" $ JSON.Struct
    [ JSON.assoc "j1" j1
    , JSON.assoc "j2" j2
    ]



{--
    abstract Java Statement
 -}
data JStmt =
    !JError String          --- code that makes javac fail (generated by incomplete code generation)
    | JEmpty                --- empty statement
    | !JBlock  {stmts::[JStmt]}        --- { statements }
    | !JReturn JExpr         --- return expr
    | !JThrow  JExpr         --- throw expr
    | !JAssert JExpr         --- assert expr
    | !JEx     JExpr
    | !JAssign JExpr JExpr   --- a = b
    | !JLocal  {decl::JDecl}
    | !JCond   {keyword :: String, jex :: JExpr, stmts :: [JStmt]}   --- if/while (cond) { ... }
    | !JBlockX {keyword :: String, stmts :: [JStmt]}      --- try/else/catch ... { .... }
    | !JCase   {jex :: JExpr, stmt :: JStmt }


instance ToJSON JStmt where
  toJSON (JError x) = JSON.struct "JError" x
  toJSON JEmpty = toJSON "JEmpty"
  toJSON (JBlock{stmts}) = JSON.struct "JBlock" $ JSON.struct "stmts" stmts
  toJSON (JReturn x) = JSON.struct "JReturn" x
  toJSON (JThrow x) = JSON.struct "JThrow" x
  toJSON (JAssert x) = JSON.struct "JAssert" x
  toJSON (JEx x) = JSON.struct "JEx" x
  toJSON (JAssign x y) = JSON.struct "JAssign" (x, y)
  toJSON (JLocal{decl}) = JSON.struct "JLocal" $ JSON.struct "decl" decl
  toJSON (JCond{keyword, jex, stmts}) = JSON.struct "JCond" $ JSON.Struct
    [ JSON.assoc "keyword" keyword
    , JSON.assoc "jex" jex
    , JSON.assoc "stmts" stmts
    ]
  toJSON (JBlockX{keyword, stmts}) = JSON.struct "JBlockX" $ JSON.Struct
    [ JSON.assoc "keyword" keyword
    , JSON.assoc "stmts" stmts
    ]
  toJSON (JCase{jex, stmt}) = JSON.struct "JCase" $ JSON.Struct
    [ JSON.assoc "jex" jex
    , JSON.assoc "stmt" stmt
    ]


--- placeholder for pipehole optimization
postOpt x = x


{--
    abstract Java Declaration
 -}
data JDecl =
      JComment String   --- > // this is a java comment
    | !JClass {attr::Attributes, 
                name :: String, gvars :: [JTVar],
                extend :: Maybe JType, 
                implement :: [JType], defs :: [JDecl] }
                        {--
                            > class Name extends Foo implements Bar, Baz {
                            > ...
                            > }
                        -}

    | !JInterface {attr::Attributes, 
                name :: String, gvars :: [JTVar],
                implement :: [JType], defs :: [JDecl] }
                        {--
                            > interface Name extends Bar, Baz {
                            > ...
                            > }
                        -}


    | !JMethod {attr::Attributes, gvars :: [JTVar], jtype:: JType, name :: String,
               args::[FormalArg], body:: JStmt}
    | !JConstr {attr::Attributes, jtype::JType, args::[FormalArg], body:: JStmt}
    | !JMember {attr::Attributes, jtype::JType, name::String, init::Maybe JExpr}
    | !JWhile  {body::JStmt}
    where
        isComment JComment{} = true
        isComment _          = false

instance ToJSON JDecl where
  toJSON (JComment x) = JSON.struct "JComment" x
  toJSON (JClass{attr, name, gvars, extend, implement, defs}) = JSON.struct "JClass" $ JSON.Struct
    [ JSON.assoc "attr" attr
    , JSON.assoc "name" name
    , JSON.assoc "gvars" gvars
    , JSON.assoc "extend" extend
    , JSON.assoc "implement" implement
    , JSON.assoc "defs" defs
    ]
  toJSON (JInterface{attr, name, gvars, implement, defs}) = JSON.struct "JInterface" $ JSON.Struct
    [ JSON.assoc "attr" attr
    , JSON.assoc "name" name
    , JSON.assoc "gvars" gvars
    , JSON.assoc "implement" implement
    , JSON.assoc "defs" defs
    ]
  toJSON (JMethod{attr, gvars, jtype, name, args, body}) = JSON.struct "JMethod" $ JSON.Struct
    [ JSON.assoc "attr" attr
    , JSON.assoc "gvars" gvars
    , JSON.assoc "jtype" jtype
    , JSON.assoc "name" name
    , JSON.assoc "args" args
    , JSON.assoc "body" body
    ]
  toJSON (JConstr{attr, jtype, args, body}) = JSON.struct "JConstr" $ JSON.Struct
    [ JSON.assoc "attr" attr
    , JSON.assoc "jtype" jtype
    , JSON.assoc "args" args
    , JSON.assoc "body" body
    ]
  toJSON (JMember{attr, jtype, name, init}) = JSON.struct "JMember" $ JSON.Struct
    [ JSON.assoc "attr" attr
    , JSON.assoc "jtype" jtype
    , JSON.assoc "name" name
    , JSON.assoc "init" init
    ]
  toJSON (JWhile{body}) = JSON.struct "JWhile" $ JSON.struct "body" body
