--- Information about named items.
module frege.compiler.types.Symbols where 

import  frege.data.TreeMap as TM(TreeMap, each, values)
import  frege.control.monad.State
import  frege.compiler.common.Lens (Choice, preview, prism', view)
import  frege.compiler.enums.RFlag(RState, RFlag)
import  frege.compiler.types.Positions
import  frege.compiler.types.Strictness
import  frege.compiler.enums.Visibility
import  frege.compiler.enums.SymState
import  frege.compiler.types.QNames
import  frege.compiler.types.Types
import  frege.compiler.types.Expression
import  frege.compiler.types.ConstructorField
import  frege.compiler.enums.TokenID

-- the symbol table
-- type Symtab = TreeMap String Symbol

--- A delayed expressions that will be build on demand.
type ExprD a = State a Expr

--- data type
data SymT global = !SymT
  { sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name::QName,
    kind::Kind, typ::Sigma, env::TreeMap String (SymbolT global), nativ::Maybe String,
    gargs::[Tau]   --- generic arguments of a native type
    product::Bool  --- indicate product type 
    enum::Bool     --- indicates enumeration type 
    pur::Bool      --- indicates *pure native* types
    newt::Bool     --- indicates *newtype*
  }

--- alias name
data SymL global = !SymL
  { sid::Int, pos::Position, vis::Visibility, name::QName, alias::QName }

--- data constructor
data SymD global = !SymD
  { sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name::QName,
    cid::Int   --- constructor number
    typ::Sigma, flds::[ConField QName],
    strsig :: Strictness,
    op :: TokenID                  --- how to use as operator 
  }

--- class
data SymC global = !SymC
  { sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name::QName,
    tau::Tau, supers::[QName], insts::[(QName, QName)],
    env::TreeMap String (SymbolT global)
  }

--- instance
data SymI global = !SymI
  { sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name ::QName,
    clas::QName, typ::Sigma,
    meth::TreeMap String (SymMeth global)
  }

--- variable or function
data SymV global = !SymV
  { sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name ::QName,
    typ::Sigma,
    --- For imported expressions, we will make them on demand 
    expr::Maybe (ExprD global),
    nativ::Maybe String,
    pur::Bool, anno::Bool, exported::Bool, state::SymState,
    strsig :: Strictness, depth :: Int, rkind :: RState,
    throwing :: [Tau]  --- list of exceptions thrown
    over :: [QName ]   --- list of overloaded members, if any
    gargs::[Tau]       --- generic arguments that must be used on the method
    op   :: TokenID    --- how to use as operator
  }
  where
  -- functions for querying the field 'Symbol.rkind'
  --- Check certain bit in 'Symbol.rkind'
  has :: SymV a -> RFlag -> Bool
  has sym bit = bit RState.`member` sym.rkind
  --- Check if this is 'RMethod'
  isMethod sym = has sym RMethod
  gExpr SymV{expr} g = fmap (\x -> evalState x g) expr

--- type alias
data SymA global = !SymA
  { sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name ::QName,
    kind::Kind, typ::Sigma, vars::[Tau]
  }

--- generalized value
--- variable, function, or data constructor
data SymVal global
    = protected D (SymD global)
    | protected V (SymV global)
    where
    toSymbol :: SymVal g -> SymbolT g
    toSymbol (D s) = SymbolT.D s
    toSymbol (V s) = SymbolT.V s
    fromSymbol :: SymbolT g -> Maybe (SymVal g)
    fromSymbol (SymbolT.D s) = Just (D s)
    fromSymbol (SymbolT.V s) = Just (V s)
    fromSymbol _ = Nothing

    -- name :: Lens' (SymVal g) QName
    name :: Functor f => (QName -> f QName) -> SymVal g -> f (SymVal g)
    name f (D s) = (\name -> D s.{name}) <$> f s.name
    name f (V s) = (\name -> V s.{name}) <$> f s.name
    -- pos :: Lens' (SymVal g) Position
    pos :: Functor f => (Position -> f Position) -> SymVal g -> f (SymVal g)
    pos f (D s) = (\pos -> D s.{pos}) <$> f s.pos
    pos f (V s) = (\pos -> V s.{pos}) <$> f s.pos
    -- sid :: Lens' (SymVal g) Int
    sid :: Functor f => (Int -> f Int) -> SymVal g -> f (SymVal g)
    sid f (D s) = (\sid -> D s.{sid}) <$> f s.sid
    sid f (V s) = (\sid -> V s.{sid}) <$> f s.sid
    -- strsig :: Lens' (SymVal g) Strictness
    strsig :: Functor f => (Strictness -> f Strictness) -> SymVal g -> f (SymVal g)
    strsig f (D s) = (\strsig -> D s.{strsig}) <$> f s.strsig
    strsig f (V s) = (\strsig -> V s.{strsig}) <$> f s.strsig
    -- typ :: Lens' (SymVal g) Sigma
    typ :: Functor f => (Sigma -> f Sigma) -> SymVal g -> f (SymVal g)
    typ f (D s) = (\typ -> D s.{typ}) <$> f s.typ
    typ f (V s) = (\typ -> V s.{typ}) <$> f s.typ

--- the type of 'SymI.env'
--- method of a class
data SymMeth global
    = --- inherited by super classes
      protected L (SymL global)
    | --- ordinary members (methods)
      protected V (SymV global)
    where
    toSymbol :: SymMeth g -> SymbolT g
    toSymbol (L s) = SymbolT.L s
    toSymbol (V s) = SymbolT.V s
    fromSymbol :: SymbolT g -> Maybe (SymMeth g)
    fromSymbol (SymbolT.L s) = Just (L s)
    fromSymbol (SymbolT.V s) = Just (V s)
    fromSymbol _ = Nothing

    -- name :: Lens' (SymMeth g) QName
    name :: Functor f => (QName -> f QName) -> SymMeth g -> f (SymMeth g)
    name f (L s) = (\name -> L s.{name}) <$> f s.name
    name f (V s) = (\name -> V s.{name}) <$> f s.name
    -- pos :: Lens' (SymMeth g) Position
    pos :: Functor f => (Position -> f Position) -> SymMeth g -> f (SymMeth g)
    pos f (L s) = (\pos -> L s.{pos}) <$> f s.pos
    pos f (V s) = (\pos -> V s.{pos}) <$> f s.pos

{--
    The information stored in the 'Symtab' nodes.
    -}
data SymbolT global =
          protected T (SymT global) --- data type
        | protected L (SymL global) --- alias name
        | protected D (SymD global) --- data constructor
        | protected C (SymC global) --- class
        | protected I (SymI global) --- instance
        | protected V (SymV global) --- variable or function
        | protected A (SymA global) --- type alias
    where
        hashCode :: SymbolT global -> Int
        hashCode = view SymbolT.sid

        -- doc :: Traversal' (SymbolT g) (Maybe String)
        doc :: Applicative f => (Maybe String -> f (Maybe String)) -> SymbolT g -> f (SymbolT g)
        doc f (T s) = (\doc -> T s.{doc}) <$> f s.doc
        doc _ (sym@(L _)) = pure sym
        doc f (D s) = (\doc -> D s.{doc}) <$> f s.doc
        doc f (C s) = (\doc -> C s.{doc}) <$> f s.doc
        doc f (I s) = (\doc -> I s.{doc}) <$> f s.doc
        doc f (V s) = (\doc -> V s.{doc}) <$> f s.doc
        doc f (A s) = (\doc -> A s.{doc}) <$> f s.doc
        -- env :: Traversal' (SymbolT g) (TreeMap String (SymbolT g))
        env :: Applicative f => (TreeMap String (SymbolT g) -> f (TreeMap String (SymbolT g))) -> SymbolT g -> f (SymbolT g)
        env f (T s) = (\env -> T s.{env}) <$> f s.env
        env _ (sym@(L _)) = pure sym
        env _ (sym@(D _)) = pure sym
        env f (C s) = (\env -> C s.{env}) <$> f s.env
        env _ (sym@(I _)) = pure sym
        env _ (sym@(V _)) = pure sym
        env _ (sym@(A _)) = pure sym
        -- kind :: Traversal' (SymbolT g) Kind
        kind :: Applicative f => (Kind -> f Kind) -> SymbolT g -> f (SymbolT g)
        kind f (T s) = (\kind -> T s.{kind}) <$> f s.kind
        kind _ (sym@(L _)) = pure sym
        kind _ (sym@(D _)) = pure sym
        kind _ (sym@(C _)) = pure sym
        kind _ (sym@(I _)) = pure sym
        kind _ (sym@(V _)) = pure sym
        kind f (A s) = (\kind -> A s.{kind}) <$> f s.kind
        -- name :: Lens' (SymbolT g) QName
        name :: Functor f => (QName -> f QName) -> SymbolT g -> f (SymbolT g)
        name f (T s) = (\name -> T s.{name}) <$> f s.name
        name f (L s) = (\name -> L s.{name}) <$> f s.name
        name f (D s) = (\name -> D s.{name}) <$> f s.name
        name f (C s) = (\name -> C s.{name}) <$> f s.name
        name f (I s) = (\name -> I s.{name}) <$> f s.name
        name f (V s) = (\name -> V s.{name}) <$> f s.name
        name f (A s) = (\name -> A s.{name}) <$> f s.name
        -- nativ :: Traversal' (SymbolT g) (Maybe String)
        nativ :: Applicative f => (Maybe String -> f (Maybe String)) -> SymbolT g -> f (SymbolT g)
        nativ f (T s) = (\nativ -> T s.{nativ}) <$> f s.nativ
        nativ _ (sym@(L _)) = pure sym
        nativ _ (sym@(D _)) = pure sym
        nativ _ (sym@(C _)) = pure sym
        nativ _ (sym@(I _)) = pure sym
        nativ f (V s) = (\nativ -> V s.{nativ}) <$> f s.nativ
        nativ _ (sym@(A _)) = pure sym
        -- op :: Traversal' (SymbolT g) TokenID
        op :: Applicative f => (TokenID -> f TokenID) -> SymbolT g -> f (SymbolT g)
        op _ (sym@(T _)) = pure sym
        op _ (sym@(L _)) = pure sym
        op f (D s) = (\op -> D s.{op}) <$> f s.op
        op _ (sym@(C _)) = pure sym
        op _ (sym@(I _)) = pure sym
        op f (V s) = (\op -> V s.{op}) <$> f s.op
        op _ (sym@(A _)) = pure sym
        -- pos :: Lens' (SymbolT g) Position
        pos :: Functor f => (Position -> f Position) -> SymbolT g -> f (SymbolT g)
        pos f (T s) = (\pos -> T s.{pos}) <$> f s.pos
        pos f (L s) = (\pos -> L s.{pos}) <$> f s.pos
        pos f (D s) = (\pos -> D s.{pos}) <$> f s.pos
        pos f (C s) = (\pos -> C s.{pos}) <$> f s.pos
        pos f (I s) = (\pos -> I s.{pos}) <$> f s.pos
        pos f (V s) = (\pos -> V s.{pos}) <$> f s.pos
        pos f (A s) = (\pos -> A s.{pos}) <$> f s.pos
        -- pur :: Traversal' (SymbolT g) Bool
        pur :: Applicative f => (Bool -> f Bool) -> SymbolT g -> f (SymbolT g)
        pur f (T s) = (\pur -> T s.{pur}) <$> f s.pur
        pur _ (sym@(L _)) = pure sym
        pur _ (sym@(D _)) = pure sym
        pur _ (sym@(C _)) = pure sym
        pur _ (sym@(I _)) = pure sym
        pur f (V s) = (\pur -> V s.{pur}) <$> f s.pur
        pur _ (sym@(A _)) = pure sym
        -- sid :: Lens' (SymbolT g) Int
        sid :: Functor f => (Int -> f Int) -> SymbolT g -> f (SymbolT g)
        sid f (T s) = (\sid -> T s.{sid}) <$> f s.sid
        sid f (L s) = (\sid -> L s.{sid}) <$> f s.sid
        sid f (D s) = (\sid -> D s.{sid}) <$> f s.sid
        sid f (C s) = (\sid -> C s.{sid}) <$> f s.sid
        sid f (I s) = (\sid -> I s.{sid}) <$> f s.sid
        sid f (V s) = (\sid -> V s.{sid}) <$> f s.sid
        sid f (A s) = (\sid -> A s.{sid}) <$> f s.sid
        -- strsig :: Traversal' (SymbolT g) Strictness
        strsig :: Applicative f => (Strictness -> f Strictness) -> SymbolT g -> f (SymbolT g)
        strsig _ (sym@(T _)) = pure sym
        strsig _ (sym@(L _)) = pure sym
        strsig f (D s) = (\strsig -> D s.{strsig}) <$> f s.strsig
        strsig _ (sym@(C _)) = pure sym
        strsig _ (sym@(I _)) = pure sym
        strsig f (V s) = (\strsig -> V s.{strsig}) <$> f s.strsig
        strsig _ (sym@(A _)) = pure sym
        -- typ :: Traversal' (SymbolT g) Sigma
        typ :: Applicative f => (Sigma -> f Sigma) -> SymbolT g -> f (SymbolT g)
        typ f (T s) = (\typ -> T s.{typ}) <$> f s.typ
        typ _ (sym@(L _)) = pure sym
        typ f (D s) = (\typ -> D s.{typ}) <$> f s.typ
        typ _ (sym@(C _)) = pure sym
        typ f (I s) = (\typ -> I s.{typ}) <$> f s.typ
        typ f (V s) = (\typ -> V s.{typ}) <$> f s.typ
        typ f (A s) = (\typ -> A s.{typ}) <$> f s.typ
        -- vis :: Lens' (SymbolT g) Visibility
        vis :: Functor f => (Visibility -> f Visibility) -> SymbolT g -> f (SymbolT g)
        vis f (T s) = (\vis -> T s.{vis}) <$> f s.vis
        vis f (L s) = (\vis -> L s.{vis}) <$> f s.vis
        vis f (D s) = (\vis -> D s.{vis}) <$> f s.vis
        vis f (C s) = (\vis -> C s.{vis}) <$> f s.vis
        vis f (I s) = (\vis -> I s.{vis}) <$> f s.vis
        vis f (V s) = (\vis -> V s.{vis}) <$> f s.vis
        vis f (A s) = (\vis -> A s.{vis}) <$> f s.vis

        --- a generalized read-only view of 'env'
        env' :: SymbolT g -> Maybe (TreeMap String (SymbolT g))
        env' (I s) = Just $ fmap SymMeth.toSymbol s.meth
        env' s = preview env s
        -- TODO add for performance?
        -- envValues' :: SymbolT g -> Maybe [SymbolT g]

        -- _T :: Prism' (SymbolT g) (SymT g)
        _T :: (Choice p, Applicative f) => p (SymT g) (f (SymT g)) -> p (SymbolT g) (f (SymbolT g))
        _T = prism' T (\s -> case s of { SymbolT.T x -> Just x; _ -> Nothing; })
        -- _L :: Prism' (SymbolT g) (SymL g)
        _L :: (Choice p, Applicative f) => p (SymL g) (f (SymL g)) -> p (SymbolT g) (f (SymbolT g))
        _L = prism' L (\s -> case s of { SymbolT.L x -> Just x; _ -> Nothing; })
        -- _D :: Prism' (SymbolT g) (SymD g)
        _D :: (Choice p, Applicative f) => p (SymD g) (f (SymD g)) -> p (SymbolT g) (f (SymbolT g))
        _D = prism' D (\s -> case s of { SymbolT.D x -> Just x; _ -> Nothing; })
        -- _C :: Prism' (SymbolT g) (SymC g)
        _C :: (Choice p, Applicative f) => p (SymC g) (f (SymC g)) -> p (SymbolT g) (f (SymbolT g))
        _C = prism' C (\s -> case s of { SymbolT.C x -> Just x; _ -> Nothing; })
        -- _I :: Prism' (SymbolT g) (SymI g)
        _I :: (Choice p, Applicative f) => p (SymI g) (f (SymI g)) -> p (SymbolT g) (f (SymbolT g))
        _I = prism' I (\s -> case s of { SymbolT.I x -> Just x; _ -> Nothing; })
        -- _V :: Prism' (SymbolT g) (SymV g)
        _V :: (Choice p, Applicative f) => p (SymV g) (f (SymV g)) -> p (SymbolT g) (f (SymbolT g))
        _V = prism' V (\s -> case s of { SymbolT.V x -> Just x; _ -> Nothing; })
        -- _A :: Prism' (SymbolT g) (SymA g)
        _A :: (Choice p, Applicative f) => p (SymA g) (f (SymA g)) -> p (SymbolT g) (f (SymbolT g))
        _A = prism' A (\s -> case s of { SymbolT.A x -> Just x; _ -> Nothing; })

        -- _Val :: Prism' (SymbolT g) (SymVal g)
        _Val :: (Choice p, Applicative f) => p (SymVal g) (f (SymVal g)) -> p (SymbolT g) (f (SymbolT g))
        _Val = prism' SymVal.toSymbol SymVal.fromSymbol
        -- _Meth :: Prism' (SymbolT g) (SymMeth g)
        _Meth :: (Choice p, Applicative f) => p (SymMeth g) (f (SymMeth g)) -> p (SymbolT g) (f (SymbolT g))
        _Meth = prism' SymMeth.toSymbol SymMeth.fromSymbol



instance Ord (SymT g) where
    sym1 <=> sym2 = SymbolT.T sym1 <=> SymbolT.T sym2
    sym1 ==  sym2 = SymbolT.T sym1 ==  SymbolT.T sym2
    sym1 !=  sym2 = SymbolT.T sym1 !=  SymbolT.T sym2
    hashCode = hashCode . SymbolT.T
instance Ord (SymL g) where
    sym1 <=> sym2 = SymbolT.L sym1 <=> SymbolT.L sym2
    sym1 ==  sym2 = SymbolT.L sym1 ==  SymbolT.L sym2
    sym1 !=  sym2 = SymbolT.L sym1 !=  SymbolT.L sym2
    hashCode = hashCode . SymbolT.L
instance Ord (SymD g) where
    sym1 <=> sym2 = SymbolT.D sym1 <=> SymbolT.D sym2
    sym1 ==  sym2 = SymbolT.D sym1 ==  SymbolT.D sym2
    sym1 !=  sym2 = SymbolT.D sym1 !=  SymbolT.D sym2
    hashCode = hashCode . SymbolT.D
instance Ord (SymC g) where
    sym1 <=> sym2 = SymbolT.C sym1 <=> SymbolT.C sym2
    sym1 ==  sym2 = SymbolT.C sym1 ==  SymbolT.C sym2
    sym1 !=  sym2 = SymbolT.C sym1 !=  SymbolT.C sym2
    hashCode = hashCode . SymbolT.C
instance Ord (SymI g) where
    sym1 <=> sym2 = SymbolT.I sym1 <=> SymbolT.I sym2
    sym1 ==  sym2 = SymbolT.I sym1 ==  SymbolT.I sym2
    sym1 !=  sym2 = SymbolT.I sym1 !=  SymbolT.I sym2
    hashCode = hashCode . SymbolT.I
instance Ord (SymV g) where
    sym1 <=> sym2 = SymbolT.V sym1 <=> SymbolT.V sym2
    sym1 ==  sym2 = SymbolT.V sym1 ==  SymbolT.V sym2
    sym1 !=  sym2 = SymbolT.V sym1 !=  SymbolT.V sym2
    hashCode = hashCode . SymbolT.V
instance Ord (SymA g) where
    sym1 <=> sym2 = SymbolT.A sym1 <=> SymbolT.A sym2
    sym1 ==  sym2 = SymbolT.A sym1 ==  SymbolT.A sym2
    sym1 !=  sym2 = SymbolT.A sym1 !=  SymbolT.A sym2
    hashCode = hashCode . SymbolT.A

--- Symbols ordered by the 'Symbol.sid' field, which is a unique number.
--- This allows us to have sets of symbols.
instance Ord (SymbolT g) where
        sym1 <=> sym2 = view SymbolT.sid sym1 <=> view SymbolT.sid sym2
        sym1 == sym2  = view SymbolT.sid sym1 ==  view SymbolT.sid sym2
        sym1 != sym2  = view SymbolT.sid sym1 !=  view SymbolT.sid sym2


instance Positioned (SymMeth g) where
    is = is . _.toSymbol
    getpos = getpos . _.toSymbol
    getrange = getrange . _.toSymbol

instance Positioned (SymbolT g) where
    is x = ""
    getpos = view SymbolT.pos
    getrange sym =
        case sym.env' of
            Just env -> fold Position.merge (view SymbolT.pos sym) (map getrange (values env))
            Nothing -> getpos sym
