--- The content of a source file in parsed form.
module frege.compiler.types.SourceDefinitions where 

import  frege.compiler.enums.TokenID(TokenID)
import  frege.compiler.types.Positions
import  frege.compiler.types.Tokens
import  frege.compiler.enums.Visibility
import  frege.compiler.enums.Literals
import  frege.compiler.enums.CaseKind
import  frege.compiler.types.SNames
import  frege.compiler.types.ImportDetails
import  frege.compiler.types.Types
import  frege.compiler.instances.PositionedSName
import  frege.compiler.types.ConstructorField
import  frege.data.JSON (ToJSON, toJSON)


--- create 'App' 
nApp a b = App a b 

infixl 16 `App` `nApp`  `TApp`  


{--
 * definitions
 -}
data DefinitionS =
      ImpDcl    {pos::Position, pack::String, as::Maybe String,
                    imports::ImportList}
    | FixDcl    {pos::Position, opid::TokenID, ops::[String]}
    | DocDcl    {pos::Position, text::String}
    | TypDcl    {pos::Position, vis::Visibility, name::String,
                    vars::[TauS], typ::SigmaS, doc::Maybe String}
    | ClaDcl    {pos::Position, vis::Visibility, name::String,
                    clvar::TauS, supers::[SName],
                    defs::[DefinitionS], doc::Maybe String}
    | InsDcl    {pos::Position, vis::Visibility,
                    clas::SName, typ::SigmaS,
                    defs::[DefinitionS], doc::Maybe String}
    | DrvDcl    {pos::Position, vis::Visibility,
                    clas::SName, typ::SigmaS,
                    doc::Maybe String}
    | AnnDcl    {pos::Position, vis::Visibility, name::String, typ::SigmaS, doc::Maybe String}
    | NatDcl    {pos::Position, vis::Visibility, name::String, txs::[SigExs],
                    meth::String, isPure::Bool, gargs::Maybe [TauS], doc::Maybe String}
    | FunDcl    {vis::Visibility, lhs::ExprS,
                    pats::[ExprS], expr::ExprS,
                    doc::Maybe String,
                    positions::[Token]    --- the tokens that introduce the equally named definitions
                }
    | DatDcl    {pos::Position, vis::Visibility, name::String, newt :: Bool,
                    vars::[TauS], ctrs::[DCon], defs::[DefinitionS],
                    doc::Maybe String}
    | JavDcl    {pos::Position, vis::Visibility, name::String, isPure::Bool,
                    jclas::String, vars::[TauS], gargs::Maybe [TauS], defs::[DefinitionS],
                    doc::Maybe String}
    | ModDcl    {pos::Position, extending::Maybe TauS, implementing::[TauS], code::[Token]}

instance ToJSON DefinitionS where
  toJSON (ImpDcl{pos,pack,as,imports}) = JSON.struct "ImpDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "pack" pack
    , JSON.assoc "as" as
    , JSON.assoc "imports" imports
    ]
  toJSON (FixDcl{pos, opid, ops}) = JSON.struct "FixDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "opid" opid
    , JSON.assoc "ops" ops
    ]
  toJSON (DocDcl{pos, text}) = JSON.struct "DocDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "text" text
    ]
  toJSON (TypDcl{pos, vis, name, vars, typ, doc}) = JSON.struct "TypDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "vis" vis
    , JSON.assoc "name" name
    , JSON.assoc "vars" vars
    , JSON.assoc "typ" typ
    , JSON.assoc "doc" doc
    ]
  toJSON (ClaDcl{pos, vis, name, clvar, supers, defs, doc}) = JSON.struct "ClaDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "vis" vis
    , JSON.assoc "name" name
    , JSON.assoc "clvar" clvar
    , JSON.assoc "supers" supers
    , JSON.assoc "defs" defs
    , JSON.assoc "doc" doc
    ]
  toJSON (InsDcl{pos, vis, clas, typ, defs, doc}) = JSON.struct "InsDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "vis" vis
    , JSON.assoc "clas" clas
    , JSON.assoc "typ" typ
    , JSON.assoc "defs" defs
    , JSON.assoc "doc" doc
    ]
  toJSON (DrvDcl{pos, vis, clas, typ, doc}) = JSON.struct "DrvDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "vis" vis
    , JSON.assoc "clas" clas
    , JSON.assoc "typ" typ
    , JSON.assoc "doc" doc
    ]
  toJSON (AnnDcl{pos, vis, name, typ, doc}) = JSON.struct "AnnDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "vis" vis
    , JSON.assoc "name" name
    , JSON.assoc "typ" typ
    , JSON.assoc "doc" doc
    ]
  toJSON (NatDcl{pos, vis, name, txs, meth, isPure, gargs, doc}) = JSON.struct "NatDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "vis" vis
    , JSON.assoc "name" name
    , JSON.assoc "txs" txs
    , JSON.assoc "meth" meth
    , JSON.assoc "isPure" isPure
    , JSON.assoc "gargs" gargs
    , JSON.assoc "doc" doc
    ]
  toJSON (FunDcl{vis, lhs, pats, expr, doc, positions}) = JSON.struct "FunDcl" $ JSON.Struct
    [ JSON.assoc "vis" vis
    , JSON.assoc "lhs" lhs
    , JSON.assoc "pats" pats
    , JSON.assoc "expr" expr
    , JSON.assoc "doc" doc
    , JSON.assoc "positions" positions
    ]
  toJSON (DatDcl{pos, vis, name, newt, vars, ctrs, defs, doc}) = JSON.struct "DatDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "vis" vis
    , JSON.assoc "name" name
    , JSON.assoc "newt" newt
    , JSON.assoc "vars" vars
    , JSON.assoc "ctrs" ctrs
    , JSON.assoc "defs" defs
    , JSON.assoc "doc" doc
    ]
  toJSON (JavDcl{pos, vis, name, isPure, jclas, vars, gargs, defs, doc}) = JSON.struct "JavDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "vis" vis
    , JSON.assoc "name" name
    , JSON.assoc "isPure" isPure
    , JSON.assoc "jclas" jclas
    , JSON.assoc "vars" vars
    , JSON.assoc "gargs" gargs
    , JSON.assoc "defs" defs
    , JSON.assoc "doc" doc
    ]
  toJSON (ModDcl{pos, extending, implementing, code}) = JSON.struct "ModDcl" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "extending" extending
    , JSON.assoc "implementing" implementing
    , JSON.assoc "code" code
    ]

--- Is this a function binding?
--- If so, return the identifier.
funbinding FunDcl{lhs = Vbl{name=Simple{id}},pats}
    | null pats = Just id
    | id.value != "!", 
      id.value != "?",
      id.value != "@",
      id.value != "~" = Just id
funbinding _ = Nothing

--- Is this a real pattern, not just 
--- > !name
patbinding FunDcl{lhs = Con{}} = true
--- > x @ foo
--- is a pattern binding, but not
--- > @
patbinding FunDcl{lhs = Vbl{name=Simple{id}}, pats=(_:_)}
                               = id.value == "@" || id.value == "~"
patbinding _                   = false



{--
    Alternatives (constructors) in a data declaration.
    
    Note: every field has its own strictness information, the overall strictness 
    of the data constructor is derived from that.
 -}
data DCon = DCon {pos::Position, vis::Visibility, name::String,
                  flds::[ConField SName], doc::Maybe String}

instance ToJSON DCon where
  toJSON x = JSON.struct "DCon" $ JSON.Struct
    [ JSON.assoc "pos" x.pos
    , JSON.assoc "vis" x.vis
    , JSON.assoc "name" x.name
    , JSON.assoc "flds" x.flds
    , JSON.assoc "doc" x.doc
    ]

type DConS = DCon


{--
    Source expressions are untyped and contain some constructs
    that will get desugared later.
    
    In addition, contrary to the desugared forms they don't have 
    patterns yet. They, too, are represented by 'ExprS'. 
    
    Infix operator application is parsed as if all operators
    were right associative and had the same precedence:
    
    > a * b + c
    
    results in 
    
    > Infx(*, a, Infx(+, b, c))
    
    This will be desugared later into plain function applications ('App')
    when the precedence and associativity of the operators is known.
    
    In order to distinguish the above from
    
    > a * (b + c)
    
    we have the 'Term' variant, which keeps track of parentheses.
    Hence the above is parsed as:
    
    > Infx(*, a, Term(Infx(+,b,c)))
    
    and operator desugaring will not be able to see through the 'Term'.
    
    The desugaring of do-expressions must take care of refutable patterns.
    If the generator pattern is refutable, the right hand side must be wrapped
    in a case expression. Here is an example:
    
    > do
    >    P x <- foo
    >    return x
    
    Unfortunately, at parsing time, we don't know anything about constructor
    P yet and in particular whether that pattern is refutable or not.
    
    Therefore, we first desugar to:
    
    > foo >>= \P x -> return x
    
    but mark the lambda as generated from do ('ExprS.fromDO').
    
    Later, on translation to internal form, if such a marked lambda is found,
    the pattern will be checked to see if it is refutable. If not, it is 
    translated like any others. Otherwise, we make
    
    > \newvar -> case newvar of
    >       P x -> return x
    >       _   -> fail "pattern mismatch, source.fr line 21"
    
    In this case, the type checker will infer a 'MonadFail' constraint,
    because of the reference to 'fail'.
    
 -}
data ExprS =
      !Vbl      { name::SName }                             --- variable
    | !Lit      { pos::Position, kind::Literalkind, 
                    value::String, negated∷Bool }           --- > 123 "string" 'c' ´regex´
    | !Con      { name::SName }                             --- data constructor
    | !ConFS    { name::SName, 
                    fields::[(String, ExprS)] }             --- > Con{field1 = ex1, field2 = ex2}
    | !App      { fun, arg::ExprS }                         --- > fun arg
    | !Let      { defs::[DefinitionS], ex :: ExprS }        --- > let {defs} in ex
    | !Lam      { pat, ex::ExprS, fromDO  :: Bool }         --- > \pat -> ex
    | !Ifte     { cnd, thn, els::ExprS }                    --- > if cnd then thn else els
    | !Mem      { ex::ExprS, member::Token }                --- > ex.member
    | !Case     { ckind::CKind, ex::ExprS, alts::[CAltS] }  --- > case ex of { alts }
    | !Ann      { ex::ExprS, typ::SigmaT SName}             --- > ex :: typ
    | !Term     { ex::ExprS }                               --- > ( ex )
    | !Infx     { name::SName,
                    left, right :: ExprS }                  --- > left × right
    | !Enclosed  { firstT, lastT :: Token, ex :: ExprS }     --- > (Foo.+)


flats x = reverse (go x)
    where
        go (App a b) = b : go a
        go x         = [x] 

{--
    case alternative 
 -}
data CAltS = CAlt {!pat::ExprS, !ex::ExprS}                 --- > pat -> ex





instance Positioned ExprS where
    is x = "source expression"
    --- get the line number of an expression
    getpos (App a b)    = (getpos a).merge (getpos b)
    getpos Mem{ex}      = getpos ex
    getpos Lam{pat,ex}  = pat.getpos.merge ex.getpos
    getpos (Case _ e alts) = (getpos e).merge (Position.merges (map Positioned.getrange alts))
    getpos (Let _ x)  = getpos x
    getpos (Ifte c a b) = Position.merges (map getpos [c, a, b])
    getpos (Ann e s)      = (getpos e).merge (s.getpos)
    getpos (Term e)       = getpos e
    getpos Infx{name, left, right} = Position.merge (getpos left) (getpos right)
    getpos Enclosed{firstT, lastT, ex} = Pos firstT lastT
    getpos e | e.{pos?}   = e.pos
             | e.{name?}  = getpos e.name
             | otherwise  = Prelude.error ("can't determine expr pos " ++ show (constructor e))

    getrange x = getpos x

instance ToJSON ExprS where
  toJSON (Vbl{name}) = JSON.struct "Vbl" $ JSON.struct "name" name
  toJSON (Lit{pos, kind, value}) = JSON.struct "Lit" $ JSON.Struct
    [ JSON.assoc "pos" pos
    , JSON.assoc "kind" kind
    , JSON.assoc "value" value
    ]
  toJSON (Con{name}) = JSON.struct "Con" $ JSON.struct "name" name
  toJSON (ConFS{name, fields}) = JSON.struct "ConFS" $ JSON.Struct
    [ JSON.assoc "name" name
    , JSON.assoc "fields" fields
    ]
  toJSON (App{fun, arg}) = JSON.struct "App" $ JSON.Struct
    [ JSON.assoc "fun" fun
    , JSON.assoc "arg" arg
    ]
  toJSON (Let{defs, ex}) = JSON.struct "Let" $ JSON.Struct
    [ JSON.assoc "defs" defs
    , JSON.assoc "ex" ex
    ]
  toJSON (Lam{pat, ex, fromDO}) = JSON.struct "Lam" $ JSON.Struct
    [ JSON.assoc "pat" pat
    , JSON.assoc "ex" ex
    , JSON.assoc "fromDO" fromDO
    ]
  toJSON (Ifte{cnd, thn, els}) = JSON.struct "Ifte" $ JSON.Struct
    [ JSON.assoc "cnd" cnd
    , JSON.assoc "thn" thn
    , JSON.assoc "els" els
    ]
  toJSON (Mem{ex, member}) = JSON.struct "Mem" $ JSON.Struct
    [ JSON.assoc "ex" ex
    , JSON.assoc "member" member
    ]
  toJSON (Case{ckind, ex, alts}) = JSON.struct "Case" $ JSON.Struct
    [ JSON.assoc "ckind" ckind
    , JSON.assoc "ex" ex
    , JSON.assoc "alts" alts
    ]
  toJSON (Ann{ex, typ}) = JSON.struct "Ann" $ JSON.Struct
    [ JSON.assoc "ex" ex
    , JSON.assoc "typ" typ
    ]
  toJSON (Term{ex}) = JSON.struct "Term" $ JSON.struct "ex" ex
  toJSON (Infx{name, left, right}) = JSON.struct "Infx" $ JSON.Struct
    [ JSON.assoc "name" name
    , JSON.assoc "left" left
    , JSON.assoc "right" right
    ]
  toJSON (Enclosed{firstT, lastT, ex}) = JSON.struct "Enclosed" $ JSON.Struct
    [ JSON.assoc "firstT" firstT
    , JSON.assoc "lastT" lastT
    , JSON.assoc "ex" ex
    ]


instance Positioned (CAltS) where
    is _ = "case alternative"
    getpos   c = c.pat.getpos.merge   c.ex.getpos
    getrange c = c.pat.getrange.merge c.ex.getrange

instance ToJSON (CAltS) where
  toJSON x = JSON.struct "CAlt" $ JSON.Struct
    [ JSON.assoc "pat" x.pat
    , JSON.assoc "ex" x.ex
    ]

--- retrieve and return the prospective pattern variables contained in this expression
--- > Vbl {Simple{Token{VARID}}}
--- expression types that cannot be patterns are ignored.
exvars :: ExprS -> [ExprS]
exvars (ex@Vbl Simple{id=Token{tokid=VARID}})   = [ex]
exvars ConFS{name, fields}                      = concatMap (exvars . snd) fields
exvars App{fun, arg}                            = exvars fun ++ exvars arg
exvars Ann{ex, typ}                             = exvars ex
exvars Term{ex}                                 = exvars ex
exvars Infx{name, left, right}                  = exvars left ++ exvars right
exvars other = []