--- Transformations on lambda expressions
module frege.compiler.passes.GlobalLam where 
        -- generated by Splitter
import  frege.Prelude  hiding(<+>)
import  frege.compiler.enums.Flags
import  frege.compiler.types.Positions
import  frege.compiler.types.QNames
import  frege.compiler.types.Patterns
import  frege.compiler.types.Expression
import  frege.compiler.types.Symbols
import  frege.compiler.types.Global  as  G
import  frege.compiler.common.Errors  as  E()
import  frege.compiler.common.SymbolTable
import  frege.compiler.classes.Nice
import  frege.lib.PP(msgdoc, text, </>)
import  frege.compiler.Utilities  as  U(allourvars, allvars)
import  frege.compiler.Typecheck  as  TC(checkRho, substInst, zonkExpr, zonkRigid)
import  frege.compiler.common.Trans(replName)

pass = do
    g <- getST

    -- find closed lambdas and make them private global functions
    let collectedvars = allourvars g 
    foreach collectedvars closedLambdaSym
    stio ("expressions", length collectedvars)


{-
singleLetSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- singleLetExpr x
        changeSym vsym.{expr = Just nx}
    | otherwise = stio ()       // do nothing
singleLetSym sym = do
    g <- getST
    E.fatal sym.pos ("unrollSym no SymV : " ++ sym.nice g)
    -}

closedLambdaSym vsym
    | Just x <- vsym.expr = do
        nx <- x >>= U.mapExBody true closedLambda
        changeSym $ SymbolT.V vsym.{expr = Just (return nx)}
    | otherwise = stio ()



{-
closedLambda (app@App (Lam {pat,ex,typ}) b ty) = do
        g <- getST
        let pos = getpos app
        E.logmsg TRACE8 pos (text ("beta reduction on: " ++ nice app g))
        let result = Case CNormal b [CAlt {pat,ex}] ty
        E.logmsg TRACE8 pos (text ("results in: " ++ nice result g))
        closedLambda result

closedLambda (app@App a b ty) = do
        a <- U.mapEx true closedLambda a
        case a of
            Lam {} -> closedLambda (App a b ty)
            _ -> do
                b <- U.mapEx true closedLambda b
                stio (Right (App a b ty))
                -}

--- identify @\x -> glob x@ and simplify to @glob@
closedLambda Lam {pat=PVar{uid,var="in"}, ex=App a b _}
    | Vbl{name} <- a, not name.isLocal,     -- application of a global function
      Vbl{name=Local{uid=vuid}} <- b,       -- to a local variable
      uid == vuid                           -- that is the same as the pattern 
    = return (Right a)

--- identify lambdas that have no references to local variables bound in outer scopes    
--closedLambda (lam@Lam {pat,ex,typ = Just sigma}) = do
--        ex    <- U.mapEx true closedLambda ex   -- recurse
--        used  <- U.localSyms ex                 -- find local vars used
--        inner <- innerSids ex
--        tvs   <- TCU.sigmaTvs sigma
--        let thisSids = fold including inner  [ uid | PVar {uid} <- U.patVars pat ]
--        if all (thisSids `contains`) (keys used)
--            && (null sigma.rho.context                            -- no constraints or
--                || null (filter (not . MetaTv.isFlexi) tvs))      -- no rigid tvs!
--            then do
--                g <- getST
--                -- u <- uniqid
--                
--                let name = U.unusedName (VName g.thisPack ("anon$" ++ show (getpos ex))) g
--                    lamx = Lam {pat,ex,typ = Just sigma}
--                    sym0  = U.patLocal (getpos ex) 0 "anonymous"
--                    vks   = map Tau.varkind (U.freeTVars [] sigma.rho)
--                
--                ctxs <- TC.collectConstrs ex
--                typ  <- TCU.cleanSigma (ForAll vks sigma.rho.{context = ctxs})
--                
--                let sym   = sym0.{name, expr=Just lamx, vis=Private, state=Typechecked, typ}
--                    var   = Vbl {pos=sym.pos, name, typ = Just sigma}
--                enter sym
--                sym <- U.findV sym.name
--                TC.resolveConstraints sym
--                sym <- U.findV sym.name
--                depthSym sym
--                sym <- U.findV sym.name
--                E.logmsg TRACE8 sym.pos (text ("anonymous lambda  " ++ lamx.nice g 
--                        ++ " replaced with " ++ var.nice g
--                        ++ " :: " ++ sym.typ.nice g))
--                E.logmsg TRACE8 sym.pos (text ("context is  " 
--                        ++ U.nicerctx ctxs g))
--                stio (Right var)
--            else stio (Right lam)

closedLambda (letex@Let{env,ex}) = do       -- now we can lift harmless inner lambdas
        -- syms <- mapSt U.findV env
        ex   <- U.mapEx true closedLambda ex
        -- foreach syms closedLambdaInInnerSym
        (nenv, nex) <- foldM inner ([],ex) env
        let result = if null nenv
            then nex
            else letex.{ex=nex, env=nenv}
        when (length nenv < length env) do
            g <- getST
            E.logmsg TRACE8 (getpos letex) (
                text ("let bindings removed.")
                </> text ("before: " ++ nice letex g)
                </> text ("after:  " ++ nice result g))
        pure (Right result) 
    where
        inner (env, ex) qn = do
            sym <- U.findV qn
            case sym.expr of
                Just def -> do
                    def <- def
                    constr <- TC.collectConstrs def
                    if null constr
                    then do
                        ndef <- U.mapEx true closedLambda def
                        case ndef of
                            Vbl{name} -> do
                                nex <- replName sym.sid name ex
                                return (env, nex)
                            sonst -> do
                                changeSym $ SymbolT.V sym.{expr = Just (return ndef)}
                                return (qn:env, ex)
                    else return (qn:env, ex)
                sonst -> return (qn:env, ex) 

closedLambda x = pure (Left x)


