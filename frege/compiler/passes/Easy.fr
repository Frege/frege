--- Bring all expressions in a form suitable for code generation
module frege.compiler.passes.Easy where 
        -- generated by Splitter
import  frege.Prelude  hiding(<+>)
import  frege.data.TreeMap  as  TM(TreeMap, TreeSet, lookup, insert, keys, values, each, fromKeys, including, contains, union)
import  frege.compiler.common.Lens (view)
import  frege.compiler.enums.Flags
import  frege.compiler.enums.Literals
import  frege.compiler.enums.CaseKind
import  frege.compiler.types.Positions
import  frege.compiler.types.Packs
import  frege.compiler.types.QNames
import  frege.compiler.types.Types
import  frege.compiler.types.Patterns
import  frege.compiler.types.Expression
import  frege.compiler.types.Symbols
import  frege.compiler.types.Global  as  G
import  frege.compiler.common.Errors  as  E()
import  frege.compiler.common.SymbolTable
import  frege.compiler.common.Types  as  CT
import  frege.compiler.classes.Nice
import  frege.lib.PP(msgdoc, text, </>)
import  frege.compiler.Utilities  as  U(allourvars, allvars)
import  frege.compiler.Typecheck  as  TC(checkRho, substInst, zonkExpr, zonkRigid)
import  frege.compiler.tc.Util  as  TCU()
import  frege.compiler.common.Trans
{--
 * In this pass, we make sure that all expressions are in
 * a form we need for code generation. We say that an expression is, or is not /easy/.
 *
 * - Every simple expression is also easy.
 * - A literal is simple.
 * - A variable is simple.
 * - A constructor name is simple.
 * - @(x::t)@ has the same properties as @x@
 * - @if a then b else c@ is easy if @b@ and @c@ are easy and @a@ is simple.
 *   If @b@ and @c@ are also simple, then the whole expression is simple.
 * - @a b@ is simple if @a@ and @b@ are both simple. Otherwise the application is
 *   not easy.
 * - @let v = x in e@ is easy, if @x@ is simple and @e@ is easy.
 * - @\p -> x@ is simple, if @x@ is easy
 * - @case x of { p1 -> a1; ...; pn -> an }@ is easy if @x@ is simple and
 *   all alternatives @a1@ ... @an@ are easy.
 *
 * An example for an expression that is not easy would be 
 * > f (case x of p -> e)
 * This is because
 * for an application to be easy, all subexpressions must be simple, 
 * and a case expression can only be easy, but never simple.
 *
 * It can be seen, that an arbitrary expression can be made easy if there is
 * a way to make any expression simple.
 * The latter is indeed possible, because for any expression /x/ 
 * > (\_ -> ex) C
 * is simple, where /ex/ is an easy version of /x/. Together with the
 * observation, that to make an expression easy, only /strictly smaller/
 * expressions need to be made simple (and easy), 
 * which guarantees progress and termination, the proof is complete.

 * This pass should run before strictness analysis so that local definitions
 * we need to introduce get strictness info.
 -}
pass = do
    g <- getST
    let unsafeToSymV s = case s of { SymbolT.V x -> x; }
    -- set lambdadepth for each symbol
    let collectedvars = allourvars g
    foreach collectedvars (depthSym . unsafeToSymV)
    
    -- check instance member's depth
    g <- getST
    let imembers = [ imem | SymbolT.I inst <- values g.thisTab,
                            g.our inst.name, 
                            imem <- values inst.env ]
    foreach imembers checkDepth 
    -- make all expressions easy
    g <- getST
    let collectedvars = allourvars g
    foreach collectedvars (easySym . unsafeToSymV)
    
    stio ("expressions", length collectedvars)


easySym (vsym@SymV {pos})
    
    | Just dx <- vsym.expr = do
        g <- getST
        x <- dx
        if isOn g.options.flags INLINE && not (defaultMethod vsym.name g) then do
            ux <- inlined x >>= easyExpression
            changeSym $ SymbolT.V vsym.{expr = Just (return ux)}
        else do
            nx <- easyExpression x
            changeSym $ SymbolT.V vsym.{expr = Just (return nx)}
    
    | otherwise = stio ()
    
    where
        defaultMethod name g = case name of
                MName tname _ -> case g.findit tname of
                    Just (SymbolT.C _) -> true
                    _                  -> false
                _ -> false


checkDepth (SymbolT.V (vsym@SymV {pos, name = MName inst  base})) = do
        g <- getST
        let unsafeToSymV s = case s of { SymbolT.V x -> x; }
        cmeth <- unsafeToSymV <$> classMethodOfInstMethod pos inst base
        when (cmeth.depth > vsym.depth) do
            U.symWarning E.hint (SymbolT.V vsym) (msgdoc (
                nicer vsym g ++ " has depth " ++ show vsym.depth
                ++ " while " 
                ++ nicer cmeth g ++ " has depth " ++ show cmeth.depth))
        when (cmeth.depth < vsym.depth) do
            changeSym $ SymbolT.V vsym.{depth = cmeth.depth}
        return ()
checkDepth (SymbolT.L (vsym@SymL {pos, alias, name = MName inst  base})) = do
        g <- getST
        let unsafeToSymV s = case s of { SymbolT.V x -> x; }
        cmeth <- unsafeToSymV <$> classMethodOfInstMethod pos inst base
        rmeth <- U.findVD alias
        let d = case rmeth of { SymbolT.V SymV{depth} -> depth; _ -> U.arity rmeth; }
        when (cmeth.depth != d) do
            E.error pos (msgdoc (
                nicer rmeth g ++ " is not a suitable implementation  for "
                ++ nicer vsym.name g  
                ++ " because it has depth " ++ show d
                ++ " while " 
                ++ nicer cmeth g ++ " has depth " ++ show cmeth.depth))
        return ()
checkDepth bad = do
    g <- getST
    E.fatal (view SymbolT.pos bad) (text(nicer bad g ++ " must not occur in instances."))


depthSym (vsym@SymV {pos})
    | Just dx <- vsym.expr = do
        g  ← getST
        x  <- dx
        nx <- depthExpr x
        let depth = U.lambdaDepth nx
        when (depth > length sigmas) do
                g <- getST
                E.error vsym.pos (msgdoc (nice vsym.name g
                    ++ ": the expression " ++ nicer nx g
                    ++ " has more nested lambdas (" ++ show depth 
                    ++ ") than permitted by the arity (" ++ show (length sigmas)
                    ++ ") of its type " ++ nicer typ g))
                E.hint vsym.pos (msgdoc ("This is probably a compiler error."))
        if (depth >= length sigmas)
            then changeSym $ SymbolT.V vsym.{expr = Just (return nx), typ, depth}       -- fine, unless error
            else if depth == 0 && vsym.name.isLocal 
            then changeSym $ SymbolT.V vsym.{expr = Just (pure nx), depth}  -- don't change local syms that are not lambdas
            else do
                g <- getST                                      -- depth < sigmas, eta expand it
                newx <- etaExpand nx
                let newd = U.lambdaDepth newx
                E.logmsg TRACE9 vsym.pos (text ("eta expanded "
                    ++ nice vsym.name g ++ "::" ++ nice typ g
                    ++ " to lambda depth " ++ show newd))
                E.logmsg TRACE9 vsym.pos (text ("old expr: " ++ nice nx   g ++ " :: "
                        ++ maybe "nix" (flip nice g) nx.typ))
                E.logmsg TRACE9 vsym.pos (text ("new expr: " ++ nice newx g
                        ++ " :: " ++ maybe "nix" (flip nice g) nx.typ))
                changeSym $ SymbolT.V vsym.{expr = Just (return newx), typ, depth = newd}
                when (newd != (length sigmas)) do
                    E.fatal vsym.pos (text (nice vsym g ++ ": after eta expansion depth="
                        ++ show newd ++ ", length sigmas=" ++ show (length sigmas)
                        ++", turn on -x9")) 
    | otherwise = changeSym $ SymbolT.V vsym.{depth = length sigmas}
    where
        typ = vsym.typ.{rho <- unTau} -- a -> (b->c)  -->  a -> b -> c
        (_, sigmas) = U.returnType typ.rho
        depthExpr = U.mapEx false depthX
        depthX  x
            | Let {env} <- x = do
                g ← getST
                syms <- mapSt U.findV env
                foreach syms depthSym
                stio (Left x)
            | otherwise = stio (Left x)


--- copy expr and re-establish type
recycle newpos expr rho = do
        g <- getST
        expr <- U.copyExpr (Just newpos) empty expr
        expr <- U.untypeExpr expr
        let freevars =  U.freeTVars [] rho
            tvnames  =  map _.var freevars
        (metas, rho) <- TCU.skolemise (ForAll freevars rho)
        x <- checkRho expr rho
        -- foreach (zip metas freevars) (uncurry unInst)
        x <- zonkExpr x
        x <- zonkRigid tvnames x    -- true (unRigid tvnames) x 
        x <- U.mapEx true substInst x
        E.logmsg TRACE9 (newpos) (text ("recycled  " ++ nice x g))
        stio x
    --where
    --    unRigid ∷ [String] → ExprT→StG (ExprT | ExprT)
    --    unRigid b = pure . Left . Expr.{typ <- fmap (TCU.substRigidSigma b)}
        -- restore old type variables
        -- our instantiated type variable could have been unified
        -- with something else, so follow the unification path
        -- until we find an unbound type variable
        --unInst (Meta (tv@Flexi{})) tvar = do
        --        bound <- TCU.readTv tv
        --        case bound of
        --            Just tau -> unInst tau tvar
        --            Nothing  -> TCU.writeTv tv tvar -- (ref.put (Just tvar))
        --unInst _ _ = return ()  


recyclex :: Expr -> StG Expr
recyclex expr = U.copyExpr Nothing empty expr {- case expr.typ of
    Just sigma -> recycle expr sigma
    _ -> do
        g <- getST
        E.fatal (getpos expr) (text("recyclex untyped: " ++ nicer expr g)) -}


mkSimple (x@Vbl {pos})     = return x
mkSimple (x@Lit {pos})     = return x
mkSimple (x@Con {pos})     = return x
--- @p -> x@ is simple if @x@ is easy
mkSimple (x@Lam {ex})      = do
    ex <- mkEasy ex
    return x.{ex}
mkSimple (x@Ann {ex}) = do
    ex <- mkSimple ex
    return x.{ex}
mkSimple x = do
        g <- getST
        if isSimple g x
        then return x
        else mkS x


{--
    @mkLet ex f@ creates 
    
    > let tmp = ex in ux
    
    where @ux@ is the result of @f@ applied to the fresh pattern @p@
    -}
mkLet :: Expr -> (Expr -> Expr) -> StG Expr
mkLet ex f = do
    uid    <- uniqid
    let unsafeToSymV s = case s of { SymbolT.V x -> x; }
    let pos = getpos ex
        patsym = unsafeToSymV $ U.patLocal pos uid pat.var
        pat = PVar{pos, uid, var="tmp"}
        var = Vbl{pos, name=sym.name, typ=ex.typ}
        aex = f var
        sym = patsym.{typ = fromMaybe pSigma ex.typ, expr = Just (return ex)} 
    enter $ SymbolT.V sym
    return $! Let{env=[sym.name], ex=aex, typ=aex.typ}


--- any expression x can be made simple through (\_ -> easy x) ()
mkS x = do
    e <- mkEasy x
    let lam = Lam {pat = PCon {pos, qname=unitName, pats=[]}, 
                   ex = e,
                   typ = fmap utyp e.typ}
        utyp (ForAll bound rho) = 
                        ForAll bound (
                            RhoFun [] (TC.sigFor "()") rho
                        )
        pos = getpos e                                           
        unitName = MName (TC.tc "()").name "()"
        uni = Con {pos, name=unitName, typ = Just (TC.sigFor "()")}
    g <- getST
    E.hint (getpos e) (text("extra class file needed for complicated expression " ++ nicer e g))                                           
    let !trans = App lam uni e.typ
    E.logmsg TRACE9 (getpos x) (text ("mkEasy LAM INTRO before: " ++ nice x g))
    E.logmsg TRACE9 (getpos x) (text ("mkEasy LAM INTRO after:  " ++ nice trans g))
    return trans


--- tracing wrapper for 'mkEasy'
easyExpression x = do
        g <- getST
        if (isOn g.options.flags TRACE9)
        then do
            r <- mkEasy x
            unless (r `exeq` x) do
                E.logmsg TRACE9 (getpos x) (text("mkEasy before: " ++ nice x g))
                E.logmsg TRACE9 (getpos r) (text("mkEasy after:  " ++ nice r g))
            easier r x
        else do
            r <- mkEasy x
            easier r x
    where
        easier r x = if r `exeq` x then return r else easyExpression r
        -- unexact (structural) equality between expressions 
        exeq :: Expr -> Expr -> Bool
        exeq (a@Vbl{})  (b@Vbl{})  = a.name == b.name
        exeq (a@Con{})  (b@Con{})  = a.name == b.name
        exeq (a@Lit{})  (b@Lit{})  = a.kind == b.kind && a.value == b.value
        exeq (a@App{})  (b@App{})  = a.fun `exeq`  b.fun 
                                        && a.arg `exeq` b.arg 
        exeq (a@Let{})  (b@Let{})  = a.ex  `exeq`  b.ex
        exeq (a@Lam{})  (b@Lam{})  = a.ex  `exeq`  b.ex
        exeq (a@Ann{})  (b@Ann{})  = a.ex  `exeq`  b.ex 
        exeq (a@Ifte{}) (b@Ifte{}) = a.cnd `exeq`  b.cnd 
                                        && a.els `exeq`  b.els 
                                        && a.thn `exeq`  b.thn
        exeq (a@Case{}) (b@Case{}) = a.ex  `exeq`  b.ex  
                                        && and (zipWith exeq (map CAlt.ex a.alts) (map CAlt.ex b.alts))
        exeq _          _          = false


{--
    Items that can be inlined even if 1 arguments are missing.
    
     > f . g = \u -> f (g u)
     
      --} 
superOpt = [VName pPreludeBase "•",
            MName TName{pack = pControlSemi, base = "Semigroupoid_->"} "•"
        -- VName pPreludeBase "flip" 
    ]


{--
    inline all functions appropriate for inlining
    -}
inlined = U.mapEx true inline
    where
        inline (app@App{})
          | (fun,t):rest <- flatx app,
            Vbl {pos = newpos, name, typ = Just sig} <- fun,
            not name.isLocal = do
                g   <- getST
                sym <- U.findV name
                case sym.expr of 
                    Just dx 
                    -- we can't inline any class methods
                    -- because, for example 
                    -- (display x) would be replaced by (show x)
                    -- Hence the instance specific functionality was lost
                    -- e.g. display "foo" = "foo"  
                    -- and  show    "foo" = "\"foo\""
                        | MName tname _ <- name,
                          Just (SymbolT.C _) <- g.findit tname = return (Left app)
                        | sym.exported, d <- length rest, 
                          d >= sym.depth ||
                            d >= sym.depth-1 && sym.name `elem` superOpt = do
                                E.logmsg TRACE9 (getpos fun) (text ("replace " 
                                    ++ nice fun g  ++ " :: " ++ nicer sig g))
                                x <- dx
                                x <- recycle newpos x sig.rho
                                return . Left . unflatx $ (x,t):rest
                    _ -> return (Left app)
        inline (vbl@Vbl{pos, name, typ = Just sig})
            | not name.isLocal = do
                g <- getST
                sym <- U.findV name
                case sym.expr of
                    Just dx | MName tname _ <- name,
                             Just (SymbolT.C _) <- g.findit tname = return (Left vbl)
                            | sym.exported, sym.depth == 0 = do
                                E.logmsg TRACE9 pos (text ("replace " 
                                    ++ nice vbl g  ++ " :: " ++ nicer sig g))
                                x <- dx
                                x <- recycle pos x sig.rho
                                return . Left $ x
                    nothing -> return (Left vbl)
            | otherwise = return (Left vbl)
        inline x = return (Left x)        -- everything else    


{--
    Perform program transformations that ensure an easy expression.
    This may imply making some sub expression simple, which, in turn,
    may imply making this sub-expression at least easy.
    The recursive process must terminate eventually at some expression that
    is inherently easy, because there is no such rule as
    > mkEasy x = mkSimple x
    but only strictly smaller expressions are considered.
        
    Annotations are pushed inside for @let@, @case@ and @if@ like in
    > if a then b else c :: t 
    > if a then b :: t else c :: t
    Hence if the result is  'Ann', the enclosed expression 
    is guaranteed not to be @let@, @case@ or @if@.
    This is important because many rules want to eliminate those in places where
    simple expressions are expected.
    
    1. Easy lambda expressions are arrived at by making the body easy.
    2. Easy @if@ eliminates @let@, @case@ and @if@ from the condition if present,
       otherwise makes the condition simple and the alternatives easy.
    3. Likewise, @case@ eliminates @let@, @case@ and @if@ from the scrutinized expression
       or makes it simple and all alternatives easy.
    4. Let makes the symbols' expression simple and the base expression easy.
    5. Function application removes @let@, @case@ and @if@ from both function and 
       argument. 
    -}
mkEasy :: Expr -> StG Expr    
mkEasy (x@Lit{})    = return x
mkEasy (x@Vbl{})    = return x
mkEasy (x@Con{})    = return x
mkEasy (ann@Ann {ex})
    | Let{}  <- ex = mkEasy ex.{ex <- ann.{ex=}}
    | Ifte{} <- ex = mkEasy ex.{thn <- ann.{ex=}, els <- ann.{ex=}}
    | Case{} <- ex = mkEasy ex.{alts <- map substAlt}
    | otherwise = do
        ex <- mkEasy ex
        return ann.{ex}
    where substAlt :: CAlt -> CAlt
          substAlt calt = calt.{ex <- ann.{ex=}}
mkEasy (x@Lam {ex}) = do
    ex <- mkEasy ex
    return x.{ex}

--- @f a@ is easy if @f@ is simple and @a@ is simple

mkEasy (x@App f arg t) = do
        -- handle argument first
        -- f (case a of {p1->x;p2->y}) ==> case a of {p1->f x;p2->f y}
        -- f (if a then b else c) ==> if a then f b else f c
        -- f (let a = b in c) ==> let a = b in f c  
        ea     <- mkEasy arg
        g      <- getST
        let simple = isSimple g ea
            meager = isMeager f
        
        let !before = App f ea t
        case ea of
            Let{} -> do
                let !trans = ea.{ex = App f ea.ex t, typ = t}
                E.logmsg TRACE9 (getpos x) (text ("mkEasy LETARG before: " ++ nice before g))
                E.logmsg TRACE9 (getpos x) (text ("mkEasy LETARG after:  " ++ nice trans g))
                mkEasy trans
            Ifte a b c _ | not simple = if meager then do
                    f'  <- recyclex f
                    f'' <- recyclex f
                    let !trans = ea.{thn = App f' b t, els = App f'' c t, typ=t}
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy IFARG before: " ++ nice before g))
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy IFARG after:  " ++ nice trans g))
                    mkEasy trans
                else do
                    trans <- mkLet ea (\v -> App f v t)
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy IFARG before: " ++ nice before g))
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy IFARG after:  " ++ nice trans g))
                    mkEasy trans 
            Case{} = if meager || length ea.alts == 1 then do
                    talts <- mapSt adapt (tail ea.alts)
                    let alt1 = head ea.alts
                    let alts = alt1.{ex <- mod f t} : talts
                    let !trans = ea.{alts, typ=t}
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy CASE1ARG before: " ++ nice before g))
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy CASE1ARG after:  " ++ nice trans g))
                    mkEasy trans
                else do
                    trans <- mkLet ea (\v -> App f v t)
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy CASEARG before: " ++ nice before g))
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy CASEARG after:  " ++ nice trans g))
                    mkEasy trans
                where
                    mod f t x = App f x t
                    adapt :: CAlt -> StG CAlt
                    adapt calt = do
                        f' <- recyclex f
                        return calt.{ex <- mod f' t}
            _ -> do
                arg <- if simple then return ea else mkSimple ea
                -- handle function with simple arg
                -- (let a = b in c) r => let a = b in c r
                -- (if a then b else c) r => case r of p -> if a then b p else c p
                -- (case a of {p1->b;p2->c}) r => case a of {p1->b r;p2->c r}
                -- (\p -> a) r => case r of \p -> a
                ef <- mkEasy f
                let !before = App ef arg t
                case ef of
                    Let{} -> do
                        let !trans = ef.{ex = App ef.ex arg t, typ = t}
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy LETAPP before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy LETAPP after:  " ++ nice trans g))
                        mkEasy trans
                    Ifte{} -> do
                        r'  <- recyclex arg
                        r'' <- recyclex arg
                        let !trans = ef.{thn = App ef.thn r' t, els = App ef.els r'' t, typ = t}
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy IFAPP before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy IFAPP after:  " ++ nice trans g))
                        mkEasy trans
                        -- let mk x = ef.{thn = App ef.thn x t, els = App ef.els x t, typ = t}
                        -- mkCase arg mk
                    Case{} -> do
                        talts <- mapSt adapt (tail ef.alts)
                        let alt1   = head ef.alts
                            malt1  = alt1.{ex <- mod arg t}
                            alts   = malt1 : talts
                        let !trans = ef.{alts, typ=t}
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy CASEAPP before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy CASEAPP after:  " ++ nice trans g))
                        mkEasy trans
                      where
                            mod a t x = App x a t
                            adapt :: CAlt -> StG CAlt
                            adapt calt = do
                                r' <- recyclex arg
                                return calt.{ex <- mod r' t}
                    Lam{} -> do 
                        let !trans = Case CNormal arg [CAlt{pat=ef.pat, ex=ef.ex}] t
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy BETA before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy BETA after:  " ++ nice trans g))
                        mkEasy trans
                    _ -> do
                        sf <- mkSimple ef
                        let !trans = App sf arg t
                        unless simple do 
                            E.logmsg TRACE9 (getpos x) (text ("mkEasy SIMPLE before: " ++ nice before g))
                            E.logmsg TRACE9 (getpos x) (text ("mkEasy SIMPLE after:  " ++ nice trans g))
                        return trans
                        -- case sf of
                        --     -- Don't! Transformed code must stay type correct!
                        --     -- Con{name} | newtypeCon name g -> return arg
                        --     _ -> return (App sf arg t)

            
mkEasy (x@Let{env,ex}) = do             -- TODO: handle non-recursive let/case/if
        g <- getST
        mapM U.findV env >>= mapM_ easySym
        mkEasy ex >>= pure . x.{ex=}
        
            
mkEasy  (outer@Case{}) = do
    ea     <- mkEasy outer.ex
    g      <- getST
    let simple = isSimple g ea
    
    let !before = outer.{ex = ea}
    
    case ea of
        -- case let a = b in c of {p1->x;p2->y}
        -- let a = b in case c of {p1->x;p2->y}
        Let{} -> do
            let !trans = Let {env = ea.env, typ = outer.typ,
                                ex = outer.{ex = ea.ex}}
            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE LET before: " ++ nice before g))
            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE LET after:  " ++ nice trans g))
            mkEasy trans
        -- case if a then b else c of {p1->x;p2->y}
        -- if a then case b of {p1->x;p2->y} else case c of {p1->x;p2->y}
        Ifte{} | not simple -> do
            thn <- recyclex outer.{ex = ea.thn}
            els <- recyclex outer.{ex = ea.els}
            let !trans = ea.{thn,els,typ=outer.typ}
            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE IF before: " ++ nice before g))
            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE IF after:  " ++ nice trans g))
            mkEasy trans
        -- case case a of {b -> c; d -> e} of {f -> g; h -> i}
        -- case a of {b -> case c of {f -> g; h -> i}; d -> case e of {f' -> g'; h' -> i'}}
        -- If the outer case has only 1 alternative, but the inner one has more:
        -- case case a of {b -> c; d -> e} of { f -> g }
        -- case a of {b -> case c of f -> g; d -> case e of f -> g} 
        Case{} -> do
                talts <- mapSt adapt (tail ea.alts)
                let alt1 = (head ea.alts).{ex <- outer.{ex=}}
                let alts = alt1 : talts
                let !trans = ea.{alts, typ=outer.typ, 
                                    ckind = if outer.ckind == CWhen then CWhen else ea.ckind}
                E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE CASE before: " ++ nice before g))
                E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE CASE after:  " ++ nice trans g))
                mkEasy trans                
            where
                adapt :: CAlt -> StG CAlt
                adapt calt = do
                    ex <- recyclex outer.{ex = calt.ex}
                    E.logmsg TRACE9 (getpos outer) (text ("duplication because of  CASE/CASE" ++ nice ex g))
                    return calt.{ex}
        _ -> do
                -- case elimination possible?
                let alt1 = head outer.alts
                    match = sMatch alt1.pat ea empty
                    sxs = maybe [] each match
                substOk <- forM sxs (checkSubst alt1.ex) 
                case match of
                    Just tree | and substOk,
                                length outer.alts == 1 = do
                        ex <- foldM doSubst alt1.ex sxs
                        E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASEELIM before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASEELIM after:  " ++ nice ex g))
                        foreach sxs logrep
                        mkEasy ex
                    nothing = do
                        sa  <- if simple then return ea else mkSimple ea
                        alts <- mapSt easyAlt outer.alts
                        let !trans = outer.{ex=sa, alts}
                        unless simple do
                            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE SIMPLE before: " ++ nice before g))
                            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE SIMPLE after:  " ++ nice trans g))
                        return trans
            where
                logrep (uid, ex) = E.logmsg TRACE9 (getpos outer) (text("mkEasy CASEELIM subst: " 
                                        ++ show uid ++ "  "
                                        ++ nice ex g))
                easyAlt calt = do
                    ex <- mkEasy (CAlt.ex calt)
                    return calt.{ex}
                checkSubst ex (uid, x) 
                    | isAtomic x = return true
                    | otherwise = do
                        n <- references [uid] ex
                        return (n < 2)
                doSubst ex (uid, x) = replSid uid x ex
                
                    
        
mkEasy  (Ifte a x y t) = do
    ea     <- mkEasy a
    g      <- getST
    
    let simple = isSimple g ea
    let !before = Ifte ea x y t
    
    case ea of
        -- if let a = b in c then x else y
        -- let a = b in if c then y else y
        Let{} -> do
            let !trans = Let {env=ea.env, typ=t,
                            ex = Ifte ea.ex x y t}
            E.logmsg TRACE9 (getpos before) (text ("mkEasy IF LET before: " ++ nice before g))
            E.logmsg TRACE9 (getpos before) (text ("mkEasy IF LET after:  " ++ nice trans g))
            mkEasy trans
        
        -- if (if a then b else c) then x else y
        -- if a then (if b then x else y) else (if c then x' else y')
        Ifte a b c _ | not simple -> do
            x'  <- recyclex x
            y'  <- recyclex y
            x'' <- recyclex x
            y'' <- recyclex y
            let els = Ifte c x' y' t
                thn = Ifte b x'' y'' t
                !trans = (Ifte a thn els t)
            E.logmsg TRACE9 (getpos before) (text ("mkEasy IF IF before: " ++ nice before g))
            E.logmsg TRACE9 (getpos before) (text ("mkEasy IF IF after:  " ++ nice trans g))
            mkEasy trans
            
        -- if (case a of p1 -> b; p2 -> c ...) then x else y
        -- case a of p1 -> if b then x else y; p2 -> if c then x else y   
        Case{ckind,ex=a,alts} -> do
                alts <- mapSt adapt alts
                let !trans = Case{ckind,ex=a,typ=t,alts}
                E.logmsg TRACE9 (getpos before) (text ("mkEasy IF CASE before: " ++ nice before g))
                E.logmsg TRACE9 (getpos before) (text ("mkEasy IF CASE after:  " ++ nice trans g))
                mkEasy trans 
            where
                adapt :: CAlt -> StG CAlt
                adapt calt = do
                    ex <- recyclex (Ifte calt.ex x y t)
                    return calt.{ex}
        _ -> do
            sa  <- if simple then return ea else mkSimple ea
            ex  <- mkEasy x
            ey  <- mkEasy y
            let !trans = Ifte sa ex ey t
            unless simple do 
                E.logmsg TRACE9 (getpos before) (text ("mkEasy IF SIMPLE before: " ++ nice before g))
                E.logmsg TRACE9 (getpos before) (text ("mkEasy IF SIMPLE after:  " ++ nice trans g))
            return trans

-- should not happen
mkEasy  (x@Mem{})    = return x



{--
    @sMatch tree pat ex@ matches pattern @pat@ symbolically with expression @ex@ 
    and returns either @Nothing@ if there is no match or @Just tree@ where the
    'Tree' maps local unique numbers to expressions.
    
    The symbolic match matches 
    - /v/ with any /x/ and binds /v/ to /x/
    - /C/ with /C/
    - /Con p1 p2 ...pn/ with /Con x1 x2 xn/ if all subpatterns are literals or variables
      and match their corresponding subexpressions
      and binds the variables to the corresponding expressions.
    - /Con p1 ... pn/ with /x/ if /Con/ is a product or newtype constructor 
      and all subpatterns are variables. Nothing is bound.
    
    This is used in case elimination.
    Note that strict patterns are not matched.  
    -}
sMatch :: Pattern -> Expr -> TreeMap Int Expr -> Maybe (TreeMap Int Expr)
sMatch PVar{uid}        x               tree = Just (TreeMap.insert tree uid x)
sMatch PLit{value=pval} Lit{value=xval} tree = if xval == pval then Just tree else Nothing
sMatch PCon{qname,pats} x               tree
    | Con{name}:xs <- map fst (flatx x),
      name == qname, 
      length pats == length xs = fold collect (Just tree) (zipWith sMatch pats xs)
    where -- unStrict PUser{pat} = pat
          -- unStrict pat        = pat  
          collect (Just t) f  = f t
          collect Nothing  _  = Nothing
sMatch p x t = Nothing
