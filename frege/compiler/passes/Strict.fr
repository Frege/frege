--- This is an undocumented module.
module frege.compiler.passes.Strict where 
        -- generated by Splitter
import  frege.Prelude  hiding(<+>)
import  frege.data.TreeMap  as  TM(TreeMap, TreeSet, lookup, insert, keys, values, each, fromKeys, including, contains, union)
import  frege.data.List  as  DL(uniq, sort, partitioned, elemBy)
import  frege.data.Bits(BitSet, BitSet.member, BitSet.union bitunion, BitSet.intersection, BitSet.difference)
import  frege.data.Graph(stronglyConnectedComponents tsort)
import  frege.compiler.enums.Flags
import  frege.compiler.enums.TokenID(VARID)
import  frege.compiler.enums.RFlag
import  frege.compiler.enums.Visibility
import  frege.compiler.enums.SymState
import  frege.compiler.enums.Literals
import  frege.compiler.enums.CaseKind
import  frege.compiler.types.Positions
import  frege.compiler.types.Strictness
import  frege.compiler.types.QNames
import  frege.compiler.types.Types
import  frege.compiler.types.Patterns
import  frege.compiler.types.Expression
import  frege.compiler.types.Symbols
import  frege.compiler.types.Global  as  G
import  frege.compiler.common.Errors  as  E()
import  frege.compiler.common.SymbolTable
import  frege.compiler.classes.Nice
import  frege.lib.PP(msgdoc, text, </>, <+>)
import  frege.compiler.Utilities  as  U(allourvars, allvars)
-- import  frege.compiler.Typecheck  as  TC(checkRho, substInst, zonkExpr)
-- import  frege.compiler.tc.Util  as  TCU()

-- import helper modules
import  frege.compiler.common.Trans

{--
 * Strictness analysis
 *
 * - native functions are strict in all arguments
 * - constructors are lazy in all arguments (but we can adapt this later if the need arises)
 * - every symbol will get a strictness signature and status StrictChecked
 -}
pass = do
        g <- getST
        let ourvars = allourvars g
        names <- mapSt U.fundep ourvars

        let groups = tsort names

        g <- getST
        E.logmsg TRACES Position.null (text ("names: " ++ joined " " (map (flip QName.nice g • fst) names)))
        E.logmsg TRACES Position.null (text ("groups: " ++ display (map (map (flip QName.nice g)) groups)))

        foreach groups checkgroup
        
        -- bring default class methods in good shape
        g <- getST
        let classmethods = [ sym | SymC{env} <- values g.thisTab, sym@SymV{expr = Just _} <- values env ]
        foreach classmethods easyClassMethodSym 

        stio ("functions", length names)
    where
        -- checkgroup :: [QName] -> StG ()
        checkgroup nms = do
            returnNames [] nms                  -- compute return type of java methods
            foreach nms (strictName [])         -- compute strictness
            


{--
    All default class methods must be exported, so instances can derive their own version.
    Not all expressions can be exported.
    In particular they can't if at least one
    of the following applies:
    - a lambda contains a pattern that is refutable
    - a case contains a set of patterns that is refutable
    - it references a private item because this would not resolve when the code is imported
    - it contains a let or where, because the metadata does not know lets (often, lets in
      the source code are transformed to a case, or it's dropped).
    
    To nevertheless being able to export such a class method, the complicated code is moved
    to a new top level function, and the class will only contain an application of this new
    function to the arguments.
    > method a b = let c = b+1 in a c
    transforms to:
    > anon a b = let c = b+1 in a c
    > method a' b' = anon a' b'   
    -}
easyClassMethodSym :: Symbol -> StG ()
easyClassMethodSym (sym@SymV{expr = Just dx, typ}) = do
        x <- dx
        easy <- goodClassMethod x
        unless ( easy ) do
            g <- getST
            U.symWarning E.warn sym (text (nice sym g
                ++ (if easy then "" else " is not easy enough ") 
                ++ (if RSafeTC  `member` sym.rkind  then "" else " recurses deeply ")
                ++ (if RTailRec `member` sym.rkind  then " is tail recursive " else "")))
            let name = U.unusedName (VName (Global.thisPack g) (sym.name.base)) g
            
            nx <- replName sym.sid name x
            
            let anon = sym.{sid=0, name, vis = Protected, expr = Just (return nx)}
                vbl = Vbl{name, pos=anon.pos.change VARID name.base, typ=Just (ForAll [] sym.typ.rho)}
                rk = (sym.rkind.unionE RSafeTC).differenceE RTailRec
            enter anon  
            x <- etaExpand vbl
            changeSym sym.{expr = Just (return x), rkind = rk}
    where
        -- goodClassMethod :: Expr -> StG Bool
        goodClassMethod x = do
            g <- getST
            -- l <- return sym.depth
            case x of
                Ann{} -> goodClassMethod x.ex
                App{} -> liftM2 (&&) (goodClassMethod x.fun) (goodClassMethod x.arg)
                Vbl{name=Local{}} -> return true
                Vbl{name} -> do
                    vsym <- U.findV name
                    -- when (vsym.vis == Private) do
                    --     E.hint (getpos x) (text("uses private " ++ nice name g))
                    return (vsym.vis != Private)
                Con{name} -> return true        -- constructors always exported
                Case{} -> do
                    g <- getST
                    -- do not check the guards, they are checked through Lam and
                    -- the case statement they are in.
                    let compl = x.ckind == CWhen || isNothing (caseComplete g x)
                    eok <- mapM goodClassMethod (map CAlt.ex x.alts)
                    return (and (compl:eok))                    
                Lam{pat,ex}   -> do
                    g <- getST
                    case caseComplete g (Case CNormal ex [CAlt pat ex] Nothing) of
                        Just p  -> do
                            -- E.hint (getpos x) (text("incomplete: " ++ nicer p g))
                            return false      -- incomplete pattern or open case when
                        nothing -> goodClassMethod ex
                Ifte{}  -> do
                    c <- goodClassMethod x.cnd
                    if c then 
                        liftM2 (&&) (goodClassMethod x.thn) (goodClassMethod x.els)
                    else return false                        
                Lit{}   -> return true
                Let{}   -> return true     -- not allowed
                Mem{}   -> return false     -- may not happen 
easyClassMethodSym sym = return ()


{--
 * [usage] @returnKind group symbol@
 * [computes] the return type (lazy=0, boxed=1) of the r-Method, and, if a w-Method is needed,
 * the return kind of the w-Method (none, lazy=2, boxed=4, strict=6)
 *
 * - non nullary Constructors have implicitly 1101 (boxed mk-Method, boxed r-Method)
 *   and are safe tail calls (as they return immediately with the new object)
 * - Native methods have 5 or 7 (the native method *is* the w method, and if the return type
 *   is a java type, then it is 7, otherwise 5 (Maybe, Either or ST s/IO). They make also
 *   safe tail calls.
 * - if functions with constraints have a w-Method, this will be an instance method,
 *   otherwise a static one.
 * - a function with a strict argument gets a w-Method
 * - a CAF (lambdadepth = 0) will have no w-Method. The rkind will show if the CAF is
 *   declared with a lazy type or not. The bit 16 is on if the expression is simple
 *   and no self references or possibly forward references exist.
 *   Forward references can appear in global symbols which reference any global
 *   value from this package.
 -}
returnKind syms (sym@SymV {nativ = Just _}) = do
        g <- getST
        -- jt <- U.isJavaType ((fst • U.returnType) sym.typ.rho)
        changeSym sym.{rkind = RState.fromList [RSafeTC, RValue]}

returnKind syms (sym@SymV {expr = Just dx, depth = 0}) = do
        x      <- dx
        w      <- returnExprKind syms sym x
        self   <- references [sym.sid] x        -- is it self-referential?
        rec    <- references syms x             -- is it recursive
        g      <- getST
        (_, deps) <- U.fundep sym
        let local = sym.name.isLocal                            -- is this a local item?
            sx    = simpleCAF g local x 
        let fwrefs
                | local                = self > 0
                | MName{}  <- sym.name = not (null deps)        -- possible forward references?
                | null syms            = self > 0
                | [mutual] <- syms     = mutual != sym.sid || self > 0
                | otherwise            = true
            selfrec = if self > 0 then RState.singleton RSelfRec else RState.empty
            safe   = if rec > 0 then selfrec else (RState.singleton RSafeTC).union selfrec
            simple = if sx && not fwrefs && self == 0 
                    then RState.singleton RSimple 
                    else RState.empty
            stricter = (null sym.typ.bound || isAtomic x)          -- don't make 'undefined' strict!
                        && not local
                        && RSafeTC `member` safe
                        && RSimple `member` simple 
                    || Strictness.isStrict sym.strsig   -- if it is strict anyway        
            value  = if except then RState.singleton RValue else RState.empty   
            rkind = (safe.union simple).union value
            stri  = if except && not (Strictness.isStrict sym.strsig)
                    then S[] else sym.strsig
            except 
                | stricter,
                  not (RSimple `member` simple),
                  RValue `member` w,
                  not (RSafeTC `member` w)  = false -- don't return a lazy result
                                                    -- and force it right away in the eval() fun
                | stricter, local, self > 0 = false -- local self refs must be lazy 
                | otherwise                 = stricter
        changeSym sym.{rkind, strsig = stri}

returnKind syms (sym@SymV {expr = Just dx}) = do
        x      <- dx
        w      <- returnExprKind syms sym x
        g      <- getST
        self   <- references [sym.sid] x        -- is it self-referential?

        let sx = isSimple g x

        let skind = if sx then w.unionE RSimple else w
            rkind = if self>0 then skind.unionE RSelfRec else skind
            -- if we have proper tail calls then all functions
            -- are safe tail calls. 
            xkind = if isOn g.options.flags PROPERTC 
                        then rkind.unionE RSafeTC else rkind
        -- instance functions must be at least as strict as their class functions
        -- class functions must be RSafeTC
        case sym.name of
            MName inst base | Just symic <- g.findit inst = case symic of
                SymC{} ->  do
                            let nkind = classMemberState
                            changeSym sym.{rkind=nkind}
                SymI{} ->  do
                        cm <- classMethodOfInstMethod sym.pos inst base
                        if cm.rkind.null then do
                            returnKind [] cm
                            returnKind syms sym
                        else do
                            -- let nkind = (xkind.differenceE RAlways).union cm.rkind
                            changeSym sym.{rkind = xkind}
                other -> changeSym sym.{rkind = xkind} 
            other -> changeSym sym.{rkind = xkind}

--- assume abstract class functions are tail call safe and return a value 
returnKind syms (sym@SymV {expr = Nothing, name = MName _ _}) 
    = changeSym sym.{rkind=classMemberState}
returnKind _ _ = stio ()     -- abstract methods


--- the default state of a class member
classMemberState = RState.fromList [RSafeTC, RValue]

--- 'RValue' and 'RSafeTC'
defaultRKind = RState.fromList [RSafeTC, RValue]

{--
 * [usage] @returnExprKind syms symbol x@
 *
 * Look for the return expressions in @x@ and compute the minimum return kind.
 * If any symbol in @syms@ is called, it is regarded as recursive and not fit
 * for tailcall.
 *
 * A return expression is an application, literal, variable or constructor.
 *
 * - When it is a literal, unboxed return (6) is possible.
 * - When it is a local lambda or case bound variable,
 *   return will be according to the variable's strictness boxed or lazy.
 *   Otherwise, it's the return kind of the variable.
 * - Constructor is either a function or a nullary constructor - both are boxed.
 * - A tail recursive application is either 6 or 4, depending on return type
 * - A tail call to a native function or a constructor is 4 or 6 depending on their w-value
 * - Otherwise, if the application is saturated or a lambda/case-bound variable is applied,
 *   it's lazy.
 * - Unsaturated applications are boxed (function types)
 -}
returnExprKind syms sym (x@Lit {pos}) = stio defaultRKind
returnExprKind syms sym (x@Con {pos}) = stio defaultRKind
returnExprKind syms sym (x@Ann {ex})  = returnExprKind syms sym ex

returnExprKind syms sym (x@Vbl {name}) = do
    symv <- U.findV name
    g    <- getST
    case symv.gExpr g of
        Nothing -> case symv.name of
            Local{} -> stio defaultRKind
            _ -> case U.returnType symv.typ.rho of
                (_,[]) -> stio (BitSet.union (RState.singleton RSafeTC) symv.rkind)
                _      -> stio defaultRKind      -- global function
        Just (Lam {})  -> stio defaultRKind      -- return a local function
        Just vx -> stio defaultRKind

returnExprKind syms sym (ex@App a b typ) = do
    returnExprKind syms sym a
    bek ← returnExprKind syms sym b
    g   ← getST
    let (f,_) = head fx
        args  = tail fx
        fx = flatx ex
        -- app = App a b typ
    case f of
        Vbl {name} -> do
            symf <- U.findV name
            g <- getST
            let ari = if isJust symf.expr then symf.depth else U.arity symf
                rwa = defaultRKind.intersection  symf.rkind 
                rw  | MName tname _ <- symf.name,
                      Just SymC{} <- g.findit tname 
                    = rwa.unionE RValue   -- call class methods lazy
                    | otherwise = rwa
            if isJust symf.nativ then stio (rw)
              else if (length args < ari) 
                    then stio (rw.unionE RValue)     -- unsaturated function is a LAMBDA value
              else case symf.expr of
                    Nothing -> case name of
                        Local{} -> stio (RState.singleton RSafeTC)   -- application of lambda/case bound
                        _       -> stio (rw)                         -- global fun
                    Just _ -> do
                        g <- getST
                        if symf.sid == Symbol.sid sym               -- self recursive
                            then stio (defaultRKind.unionE RTailRec)
                            else if (symf.sid `elem` syms)
                                then if isOn g.options.flags PROPERTC
                                    then stio  defaultRKind        -- just like not recursive
                                    else
                                        -- Call of a function in the dependency group
                                        -- This makes this one not tail safe ...
                                        -- ... UNLESS the called is already not tail safe.
                                        -- Because if this is so,  code generation
                                        -- delays this anyway. Hence we are tail safe.
                                        if RSafeTC `member` symf.rkind
                                        then stio (RState.empty)    
                                        else stio (RState.singleton RSafeTC)
                                else return rw                          -- this is safe tc and value
        Con {name} -> pure defaultRKind
        _ -> do
                n <- references syms f
                if n > 0
                    then stio (RState.empty)       -- better safe than sorry
                    else stio defaultRKind


returnExprKind syms sym (Ifte c t e typ) = do
    returnExprKind syms sym c
    w1 <- returnExprKind syms sym t
    w2 <- returnExprKind syms sym e
    let -- always = not (RValue `member` w1) && not (RValue `member` w2)
        -- value  = (RValue `member` w1) && (RValue `member` w2)
        res = minRkind w1 w2
    stio (res)

returnExprKind syms sym (x@Lam {ex}) = returnExprKind syms sym ex 

returnExprKind syms sym (x@Let {env,ex}) = do
        returnNames syms env
        returnExprKind syms sym ex

returnExprKind syms sym (x@Case {ex, alts}) = do
    returnExprKind syms sym ex
    wsalts <- mapSt (altExprKind syms sym) alts
    let m = foldl1 minRkind wsalts
    stio m
returnExprKind syms sym _ = error "returnExprKind bad expr."


altExprKind syms sym (alt@CAlt {ex}) = returnExprKind syms sym ex


{--
    combine two rkinds by taking the minimum of the lower 3 bits and the maximum of
    the 2³ bit, which signifies tail recursion.
 -}
minRkind a b = (safetc.union tailbit).union wrbits where
    safetc  = if (RSafeTC `member` a) && (RSafeTC `member` b) 
                then RState.singleton RSafeTC else RState.empty
    tailbit = if (RTailRec `member` a) || (RTailRec `member` b)
                then RState.singleton RTailRec else RState.empty
    wrbits  = if (RValue `member` a) && (RValue  `member` b) 
                                     && (RSafeTC `member` safetc)
                then RState.singleton RValue
                else RState.empty


{--
 * [usage] returnNames names name
 *
 * gets the symbol and stores the information computed by 'returnKind' in the 'Symbol.rkind'
 * field.
 *
 * The @names@ list gives the names that are mutually dependent on this one.
 -}
returnNames sids nms = do
        syms  <- mapSt U.findV nms
        let !deps = sids ++ map Symbol.sid syms
        foreach syms setsafetc
        foreach syms (returnKind deps)
    where
        setsafetc :: Symbol -> StG ()
        setsafetc sym = changeSym  sym.{rkind = BitSet.singleton RSafeTC}


{--
    Rename unused patterns to "_"
    
    Later, in code generation, those patterns will be ignored
    -}
rmUnusedPat :: [Int] -> Pattern -> Pattern
rmUnusedPat unused p = case p of
        PVar{pos, uid, var}
            | var == "_"        = p
            | uid `elem` unused = p.{var = "_"}
            | otherwise         = p
        PCon{pos, qname, pats}  = p.{pats <- map (rmUnusedPat unused)}
        PConFS{pos, qname, fields} -> undefined    -- TODO: complete code
        PAt{pos, uid, var, pat}
            | uid `elem` unused = rmUnusedPat unused pat
            | otherwise         = p
        PUser{pat, lazy}        = p.{pat <- rmUnusedPat unused}
        PLit{pos, kind, value}  = p
        PAnn{pat, typ}          = p.{pat <- rmUnusedPat unused}
        PMat{pos, uid, var, value}
            | uid `elem` unused = PLit{pos, kind=LRegex, value, negated=false}
            | otherwise         = p


{- ############################### strictness analysis ########################## -}
{--
 * [usage] @lambdaStrictness x@
 * [returns] a list of 'Strictness' items derived from patterns of the lambda in @x@
 *           or the empty list if @x@ is not a lambda
 * [see]     'patternStrictness'
 -}
lambdaStrictness (x@Lam {pat,ex}) = do
        sx <- lambdaStrictness ex
        sp <- patternStrictness pat
        stio (sp:sx)
lambdaStrictness x = stio []        -- not a lambda





{--
    check a name for strictness, sids are already being checked
 -}

strictName sids nm = do
    g <- getST
    v <- U.findV nm
    when (v.state != StrictChecked) do
        E.logmsg TRACES v.pos (text ("strictness analysis for " ++ v.nice g))
    let ari = U.arity v             -- ... based on type
        notLazy sym = RValue `member` sym.rkind
    case v of
        SymV {state = StrictChecked} = stio []          -- do nothing

        SymV {name = MName{tynm}} | Just SymC{} ← g.findit tynm → do
            let strsig = S (take ari allLazy)
            E.logmsg TRACES v.pos (text ("strictness for abstract " ++ v.name.nice g ++ " is "
                                    ++ show strsig))
            changeSym v.{strsig, state = StrictChecked}
            stio []

        SymV {nativ = Just _} -> do
            let strsig = S (take ari allStrict)
            E.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show strsig))
            changeSym v.{strsig, state = StrictChecked}
            stio []

        SymV {} | Just (x@Lam{ex}) <- v.gExpr g -> do
            (x, syms) <- strictReturn (notLazy v) (v.sid:sids) x
            s <- lambdaStrictness x     -- collect strictness from patterns
            E.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show (S s)
                                    ++ " ignoring "
                                    ++ joined ", " (map (flip nice g • Symbol.name) syms)))
            changeSym v.{expr = Just (return x), strsig = S s, state = StrictChecked}
            stio syms
        SymV {expr = Just x} | ari >= 0 = do
                y <- x >>= eta ari 
                (y, syms) <- strictReturn true (v.sid:sids) y
                s <- lambdaStrictness y
                let x  = uneta ari y
                    rs = if null s then v.strsig else S s
                E.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show rs))
                changeSym v.{expr = Just (return x), strsig = rs, state = StrictChecked}
                stio syms
            where
                eta 0 x = stio x
                eta n x = do
                    let pos = getpos x
                    nums <- sequence (take n (repeat uniqid))
                    syms <- mapSt U.mkLocal  [ PVar{pos=pos,uid,var="$"} | uid <- nums ]
                    let vars = map Symbol.name syms
                        mkapp ex n = nApp ex (Vbl {pos, name=n, typ = Nothing})
                        -- mklam :: Expr -> Int -> Expr
                        mklam ex sym = Lam {pat,ex,typ=Nothing}
                            where pat = PVar {pos, uid=Symbol.sid sym, var="$"}
                                  -- env = insert Nil pat.var (U.patLocal pos pat.var).{sid=n}
                        -- \a\b -> x a b
                        body = fold mkapp    x vars
                        lam  = fold mklam body (reverse syms)
                    stio lam
                uneta n x = unapp n • unlam n $ x
                    where unlam 0 x = x
                          unlam n (Lam {ex}) = unlam (n-1) ex
                          unlam _ _ = error "unlam: no Lam"
                          unapp 0 x = x
                          unapp n (App a b _) = unapp (n-1) a
                          unapp _ _ = error "unapp: no App"

        SymV {state} -> do              -- pointless style or just var
            let strsig = if ari == 0 then v.strsig else S (take ari allLazy)
            E.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show strsig))
            changeSym v.{strsig, state = StrictChecked}
            stio []
        other -> E.fatal other.pos (text ("strictness: strange symbol  " ++ other.nice g))


{--
 * - _usage_ @strictness sids x@
 * - _returns_ a possibly modified expression and a list of local symbols that appear strict
 *           under the assumption that @x@ itself is strict
 * - _requires_ environment must be set up correctly and the list @sids@ contains the
 *            symbol numbers of all named functions that are recursively checked to
 *            avoid infinite recursion
 *
 * Strictness rules for various expressions:
 * 1. if @\p -> x@ is strict then @x@ is strict
 * 2. if @case x of alt1;...@ is strict, then @x@ is strict if the pattern in the first
 *    case alternative is strict. Non immediate local
 *    names from subexpressions are strict only when they appear strict in all alternatives.
 * 3. if local variable @v@ is strict, then @v@ is strict
 * 4. if application @f a b c@ is strict, and @f@ is a variable, @f@ is strict
 * 5. if application @g x y@ is strict, and g has a strictness signature, then
 *      the arguments are strict if the signature at the corresponding position is.
 *      Otherwise, if @g@ is checked recursively, assume all arguments as strict.
 *      If @g@ is encountered the first time, look at @g@'s lambda and use
 *      the lambda strictness for the arguments
 * 6. if g is checked recursively, all arguments are strict
 -}
strictReturn :: Bool ->  [Int] -> Expr -> StG (Expr, [Symbol])
strictReturn notLazy sids x = strictness sids x where
  strictness :: [Int] -> Expr -> StG (Expr, [Symbol])
  strictness sids x = do
        g <- getST
        E.logmsg TRACES (getpos x) (text ("strictness for: " ++ nice x g))
        let mine = if x.{env?} then map QName.uid x.env
                    else if x.{pat?} then map Pattern.uid (patVars x.pat) 
                    else []
            my   = filter ((`elem`    mine) • Symbol.sid)
            them = filter ((`notElem` mine) • Symbol.sid)
        case x of
            Vbl {name=Local{}} -> do
                    v <- U.findV x.name
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g [v]))
                    stio (x, if notLazy then [v] else [])
            Vbl {name} -> do
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g []))
                    stio (x, [])
            Con {name} ->  do
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g []))
                    stio (x, [])
            Ifte c a b t -> do
                    (c, sc) <- strictReturn true  sids c
                    (a, sa) <- strictness sids a
                    (b, sb) <- strictness sids b
                    let syms = sc `uni` (sa `inter` sb)
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g syms))
                    stio (Ifte c a b t, syms)
            Let {env,ex} -> do
                    -- let ve = values env
                    results <- mapSt (strictName sids) 
                                  (filter ((`notElem` sids) • QName.uid) env)
                    (ex, syms) <- strictness sids ex
                    let strictSyms = my syms
                        sSsids = map Symbol.sid strictSyms
                        upper = [ sres  | (loc, sres) <- zip env results,
                                        QName.uid loc `elem` sSsids ]
                        result = fold uni (them syms) upper
                    foreach strictSyms mark
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g result))
                    stio (x.{ex}, result)
            Lit {pos} ->  do
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g []))
                    stio (x, [])
            App _ _ _ -> do
                    (fx, syms) <- appstr (flatx x)
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g syms))
                    stio (unflatx fx, syms)
            Lam {ex, pat} -> do
                    (ex, syms) <- strictness sids ex
                    foreach (my syms) mark
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g (them syms)))
                    refs <- mapSt (\sid -> references [sid] ex) mine
                    let unused = [ sid | (sid, 0) <- zip mine refs ]
                        upat = rmUnusedPat unused pat
                    stio (x.{ex, pat=upat}, them syms)
            Case {ex,alts} -> do
                    s0 <- patternStrictness (head alts).pat
                    E.logmsg TRACES (getpos x) (text ("first pattern is at least " ++ show s0))
                    altsyms <- mapSt strictAlt alts
                    let alts = map fst altsyms
                        syms = foldl1 inter (map snd altsyms)
                    -- extract S[...] of patterns
                    s1 <- do patternStrictness (head alts).pat
                    E.logmsg TRACES (getpos x) (text ("first pattern is in fact  " ++ show s1))
                    sx <- foldSt unisa s1 (tail alts)
                    E.logmsg TRACES (getpos x) (text ("all patterns together are " ++ show sx))
                    let ss = maxss s0 sx
                    E.logmsg TRACES (getpos x) (text ("combined with minimum     " ++ show ss))
                    (ex, xsyms) <- apply ex ss         -- take advantage of S[.....] if possible
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g (uni syms xsyms)))
                    stio (x.{ex, alts}, uni syms xsyms)
            Ann {ex} -> do
                    (ex,syms) <- strictness sids ex
                    stio (x.{ex}, syms)
            _ -> do
                E.fatal (getpos x) (text ("no strictness rule, turn on -xs -xr " ++ show (getpos x)))
                stio (x, [])
    where
        names g = show • map (flip QName.nice g • Symbol.name)
        inter as = filter (\b -> elemBy (using Symbol.sid) b as)
        uni :: [Symbol] -> [Symbol] -> [Symbol]
        uni as bs = as ++ [ b | b <- bs, not (elemBy (using Symbol.sid) b as)]
        maxss (S s1) (S s2) = S (zipWith maxss s1 s2)
        maxss U s = s
        maxss s _ = s
        unisa :: Strictness -> CAlt -> StG Strictness
        unisa sleft alt = do
            sright <- patternStrictness alt.pat
            stio (uniss sleft sright)
          where
            uniss (S s1) (S s2) = S (zipWith uniss s1 s2)
            uniss U _ = U
            uniss _ _ = U


        -- mark a symbol as strict
        mark sym = do
            g <- getST
            E.logmsg TRACES (Symbol.pos sym) (text (nice sym.name g ++ " marked as strict"))
            when (sym.strsig == U) do changeSym sym.{strsig = S[]}
        -- strictness for case alternative, same as in lambda
        strictAlt (alt@CAlt {pat,ex}) = do
                (lam, syms) <- strictness sids (Lam {pat,ex,typ=Nothing})
                stio (alt.{ex=lam.ex}, syms)
        subapp (a,b)   = apply a b
        apply ex U     = do
                            (x,_) <- strictness sids ex
                            stio (x, [])      -- lazy
        apply ex (S[]) = strictReturn true sids ex -- strict
        apply ex (S ss) = do
            g <- getST
            case flatx ex of
                fex@((Con {name},_):xs) | productCon name g, length ss == length xs = do
                        E.logmsg TRACES (getpos ex) (text ("apply " ++ show (S ss)
                                                        ++ " to " ++ nice ex g))

                        exsyms <- mapSt (\(a,b) -> apply a b) (zip (map fst xs) ss)
                        let exs = map fst exsyms
                            syms = foldl1 uni (map snd exsyms)
                            flat = head fex : zip exs (map snd xs)
                        E.logmsg TRACES (getpos ex) (text ("apply found: " ++ names g syms))
                        stio (unflatx flat, syms)
                _ -> strictReturn true sids ex
        convar (Con {name}) = true
        convar (Vbl {name}) = true
        convar _ = false
        appstr (app@((f,mbt):as)) | not (convar f) = do
            (f,syms) <- strictness sids f
            fas <- mapSt (strictness sids) (map fst as)
            let nas = zip (map fst fas) (map snd as)
            stio ((f,mbt):nas, syms)
        appstr (app@((f,mbt):as)) = do
            g <- getST
            v <- case f of
                    Con {name} -> U.findD name
                    Vbl {name} -> U.findV name
                    _ -> E.fatal (getpos f) (text ("Can't handle " ++ nice f g ++ "  applications"))
            let fsym | Local {} <- v.name = [v]
                     | otherwise = []
                mkAll = do
                    fapp <- mapSt (strictness sids) (map fst app)
                    let napp = zip (map fst fapp) (map snd app)
                    stio (napp, fsym)
            case v of
                SymV {state = Typechecked, expr = Nothing} = mkAll
                SymV {state = Typechecked, expr = Just _}
                    | Just (Lam{}) <- v.gExpr g = if v.sid `elem` sids
                        then do
                            -- assume all are strict
                            asx <- mapSt (strictness sids) (map fst as)
                            stio ((f,mbt):zip (map fst asx) (map snd as), fold uni fsym (map snd asx))
                        else do
                            strictName sids v.name
                            appstr app              -- repeat
                SymV {state = Typechecked, expr = Just dx}
                    | v.sid `notElem` sids = do
                            -- inline pointless
                            x <- dx
                            let fx = flatx x
                            (fxas, syms) <- appstr (fx ++ as)
                            let as = drop (length fx) fxas
                            stio ((f,mbt):as, fsym ++ syms)
                    | otherwise = mkAll
                SymD {strsig = U} -> mkAll
                SymD {strsig = S ss} -> do
                        let xss = take (length as) (ss ++ repeat U)     -- make sure enough
                        exsyms <- mapSt subapp (zip (map fst as) xss)
                        stio ((f,mbt):zip (map fst exsyms) (map snd as), fold uni fsym (map snd exsyms))
                SymV {state = StrictChecked, strsig = U} -> mkAll
                SymV {state = StrictChecked, strsig = S ss} -> do
                        let xss = take (length as) (ss ++ repeat U)     -- make sure enough
                        E.logmsg TRACES (getpos f) (text ("appstr: xss=" ++ show xss ++ " for " ++ v.name.nice g))
                        exsyms <- mapSt subapp (zip (map fst as) xss)
                        stio ((f,mbt):zip (map fst exsyms) (map snd as), fold uni fsym (map snd exsyms))
                SymV {sid} -> do
                    E.fatal (v.pos) (text ("appstr: unexpected symbol " ++ nice v g
                        ++ ", state=" ++ show v.state
                        ++ ", expr="  ++ show (isJust v.expr)))
                _ -> error "appstr: no appropriate sym"
        appstr _ = error "appstr: []"


