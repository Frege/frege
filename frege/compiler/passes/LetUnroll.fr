--- This is an undocumented module.
module frege.compiler.passes.LetUnroll where 
        -- generated by Splitter
import  frege.Prelude  hiding(<+>)
import  frege.data.TreeMap  as  TM(TreeMap, TreeSet, lookup, insert, keys, values, each, fromKeys, including, contains, union)
import  frege.data.List  as  DL(uniq, sort, sortBy, groupBy, partitioned, elemBy)
import  frege.data.Graph(stronglyConnectedComponents tsort)
import  frege.compiler.enums.Flags
import  frege.compiler.enums.Visibility
import  frege.compiler.types.Positions
import  frege.compiler.types.Tokens
import  frege.compiler.types.Strictness
import  frege.compiler.types.QNames
import  frege.compiler.types.Types
import  frege.compiler.types.Patterns
import  frege.compiler.types.Expression
import  frege.compiler.types.Symbols
import  frege.compiler.types.Global  as  G
import  frege.compiler.common.Errors  as  E()
import  frege.compiler.common.SymbolTable
import  frege.compiler.classes.Nice
import  frege.lib.PP(msgdoc, text, </>, <+>)
import  frege.compiler.Utilities  as  U(allourvars, allvars)

-- import helper modules
import  frege.compiler.common.Trans
import  frege.compiler.common.PatternCompiler

pass = do
    g <- getST

    -- unroll let expressions
    let collectedvars = allourvars g
    foreach collectedvars unrollSym

    -- simplify let expressions by lifting local function bindings to the top
    -- or inlining variables
    g <- getST
    let collectedvars = allourvars g
    foreach collectedvars unLetSym

    -- make multi-equation definitions ready for type check
    g <- getST
    let collectedvars = allourvars g
    foreach collectedvars ccSym

    stio ("symbols", 3 * length collectedvars)


unrollSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- x >>= unrollExpr 
        changeSym vsym.{expr = Just (return nx)}
    | otherwise = stio ()       -- do nothing
unrollSym sym = do
    g <- getST
    E.fatal sym.pos (text ("unrollSym no SymV : " ++ sym.nice g))


unLetSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- x >>= unLetExpr
        changeSym vsym.{expr = Just (return nx)}
    | otherwise = stio ()       -- do nothing
unLetSym sym = do
    g <- getST
    E.fatal sym.pos (text ("unLetSym no SymV : " ++ sym.nice g))

unrollExpr    = U.mapEx true unrollLet


unLetExpr x   = U.mapEx true unusedLet x >>= U.mapEx true unLet



unrollLet (x@Let {env,ex}) = do
        g <- getST
        E.logmsg TRACE7 (getpos x) (text ("unrollLet: " ++ x.nice g))
        -- first do the subexpressions
        let mapsub (sy@SymV {expr=Just x}) = do
                    x <- x >>= unrollExpr
                    changeSym sy.{expr=Just (return x)}
            mapsub sy = error "mapsub: no var"
        ex  <- unrollExpr ex
        syms <- mapSt U.findV env
        foreach syms mapsub
        let -- kvs =  each env
            xdep k = do sym <- U.findV k; ldep (k, sym)
            ldep (k, SymV {expr=Nothing}) = stio (k, [])
            ldep (k, SymV {expr=Just ex}) = do
                    deps <- ex >>= letlocals
                    stio (k, deps)
            ldep (_,_) = error "ldep: no var"
        kdeps  <- mapSt xdep env
        -- env    <- foldSt pbind env kdeps
        let result = fold (sublet env) ex ((reverse • tsort) kdeps)
        E.logmsg TRACE7 (getpos x) (text ("unrollLet: " ++ result.nice g))
        stio (Right result)
    where {-
        sublet env inx [k]
                | #^.?let\$\d+$# <- k,
                  Just (vsym@SymV {expr=Just (Lam {ex,pat})}) <- lookup env k
                = Case (ck inx) ex [CAlt {pat, ex=inx}] Nothing
                where
                    ck (Case {ckind}) = ckind
                    ck _ = CNormal
                    -}
        sublet env xin locals = if null locals then xin else Let locals xin Nothing
        letlocals ex = do
            let thisSids = map QName.uid env
            usedvars <- U.foldEx true (localvar thisSids) [] ex
            stio (DL.unique usedvars)
        localvar sidset acc (Vbl {name=nm@Local{uid}}) = do
                -- sym <- U.findV nm
                if uid `elem` sidset 
                    then stio (Left (nm:acc))
                    else stio (Left acc)
        localvar sidset acc _ = stio (Left acc)

unrollLet x = stio (Left x)


--- return the symbol ids of all local variables introduced in this expression and its subexpression
innerSids ex = U.foldEx true collect TreeMap.empty ex
    where
        patSids env = map Pattern.uid (patVars env)
        collect t (Lam {pat}) = stio (Left (fold including t (patSids pat)))
        collect t (Let {env}) = stio (Left (fold including t (map QName.uid env)))
        collect t (Case {alts}) = stio (Left (fold union t (map altSids alts)))
        collect t x = stio (Left t)
        altSids (CAlt {pat}) = fromKeys (patSids pat) :: TreeSet Int


--- find and remove unused local definitions
unusedLet (x@Let {env,ex}) = do
        down <- references (map QName.uid env) ex
        if down == 0
            then do
                syms <- mapSt U.findV env
                g <- getST
                foreach syms (\(sym::Symbol) ->
                    unless (sym.name.base ~ ´^_´) do
                        E.hint (getrange sym) (msgdoc (
                            nicer sym g ++ " is not used anywhere."))
                    )
                stio (Left ex)
            else stio (Left x)
unusedLet x = stio (Left x)


--- lift mutual recursive let functions to the top level
unLet (x@Let {env,ex}) 
    | length env > 1 = do
        vals <- mapSt U.findV env
        g <- getST
        if (any Symbol.anno vals)
            then unLetMutual g vals x
            else return (Left x) 
  where
    unLetMutual :: Global -> [Symbol] -> Expr -> StG (Either Expr Expr)
    unLetMutual g vals (x@Let {env,ex}) = do
        freevbls <- toPass
        case freevbls of
            [] -> do
                gsyms  <- mapSt globalize vals
                foreach gsyms enter
                let vgs = zip vals gsyms
                syms   <- mapSt (mkGlobal vgs) vgs
                newlet <- foldSt replsym ex vgs
                E.logmsg TRACE7 pos (text ("changed  " ++ nice newlet g))
                foreach syms changeSym
                foreach (map Symbol.name syms) unLetName
                stio (Left newlet)
            xs -> do
                -- let part1 = msgdoc ("implementation restriction: mutual recursive local functions"
                --         ++ " that use variables bound in enclosing lexical scopes"
                --         ++ " are currently not supported.")
                --     part2 = text "functions: " <+> sep "," (map (text • flip nicer g • Symbol.name) vals)
                --     part3 = text "variables: " <+> sep "," (map (text • flip nicer g • Symbol.name) freevbls)
                --     part4 = text "There are two possible workarounds:"
                --     part5 = text "- If possible, make" <+> lit (length vals - 1) <+> text "functions local to the remaining one."
                --     part6 = text "- Pass the variables as arguments."
                -- E.error (getpos x) (part1 </> nest 4 (part2 </> part3 </> part4 </> part5 </> part6))
                stio (Left x)
      where
        pos = getpos x

        exprs :: [Expr]
        exprs = map (unJust • flip Symbol.gExpr g) vals

        freeSym :: Expr -> StG [Symbol]             -- free variables in expression
        freeSym x = do
                used  <- U.localSyms x
                inner <- innerSids   x
                let uids = filter (not • (inner `contains`)) (keys used)
                mapSt U.findV   [ Local uid "_" | uid <- uids ] 
                

        toPass :: StG [Symbol]           -- symbols we must pass to each global val
        toPass = do
            exsyms <- mapSt freeSym exprs
            stio ((uniq • sort) [ s | ss <- exsyms, s <- ss, s `notElem` vals ])

        globalize :: Symbol -> StG Symbol
        globalize sym = do
            g <- getST
            let name = U.unusedName (VName (Global.thisPack g) (sym.name.base)) g
            stio sym.{name, sid=0, expr = Nothing, vis = Private}

        replsym :: Expr -> (Symbol, Symbol) -> StG Expr
        replsym x (sym,gsym) = replName sym.sid gsym.name x


        mkGlobal :: [(Symbol, Symbol)] -> (Symbol,Symbol) -> StG Symbol
        mkGlobal vgs (sym,gsym) = do
            let ex = unJust (sym.gExpr g)
            ex <- foldSt replsym ex vgs
            -- sym <- globalize sym
            g <- getST
            E.logmsg TRACE7 pos (text ("global: " ++ gsym.name.nice g ++ " = " ++ nice ex g))
            let vks  =  U.freeTVars [] sym.typ.rho
            let typ = ForAll vks sym.typ.rho
            changeST Global.{sub <- SubSt.{
                                idKind <- insert (KeyTk gsym.pos.first) (Right gsym.name)}}
            stio gsym.{expr = Just (return ex), typ}

        unLetName nm = do
            symv <- U.findV nm
            unLetSym symv
    unLetMutual g vals x = error "unLetMutual"

unLet (xlet@Let {env=letenv,ex=letex,typ=lettyp})
        | [x] <- letenv = do                  -- let x = ... in ex

    g <- getST
    sym <- U.findV x

    case sym.gExpr g of
        Just (Lam {pat,ex,typ}) = do           -- let x = \_ -> ... in ex
            ex    <- U.mapEx true unLet ex
            used  <- U.localSyms ex
            inner <- innerSids ex
            let thisSids = fold including inner (sym.sid:[ uid | PVar{uid} <- patVars pat ])  -- including x
            if sym.anno 
                && all (thisSids `contains`) (keys used)         -- ex uses only x and
                && isOff g.options.flags NOUNLET
              then do
                g <- getST
                let name = U.unusedName (VName g.thisPack x.base)  g
                ex <- replName sym.sid name ex  -- no reference to x anymore
                letex2 <- replName sym.sid name letex  -- in the inner of the lambda or the let ex
                let lamx = Lam {pat,ex,typ}
                let vks  = U.freeTVars [] sym.typ.rho
                let typ  = ForAll vks sym.typ.rho
                enter sym.{sid = 0, name, expr = Just (return lamx), vis = Private, typ}
                changeST Global.{sub <- SubSt.{
                                idKind <- insert (KeyTk sym.pos.first) (Right name)}}
                E.logmsg TRACE7 sym.pos (text ("let " ++ nice x g ++ " = " ++ nice lamx g ++ " in ... replaced with " ++ nice letex2 g))
                E.logmsg TRACE7 sym.pos (text ("new function is " ++ name.nice g))
                unLet letex2       -- other opportunities possible here
              else do
                changeSym sym.{expr = Just (return  Lam{pat,ex,typ})}
                letex <- U.mapEx true unLet letex
                stio (Right (Let {env=letenv,ex=letex,typ=lettyp}))
        -- a local non function stays local only if it uses other local symbols
        -- if used only once and is non recursive, it will get inlined
        Just cx = do
            g    <- getST
            ulet <- U.mapEx true unLet letex
            cx   <- U.mapEx true unLet cx
            let e = isSimple g cx
            changeSym sym.{expr = Just (return cx)}
            self <- references [sym.sid] cx
            down <- references [sym.sid] ulet
            -- E.logmsg TRACE7 sym.pos (text ("UNLET: " ++ nice x g
            --     ++ "  anno: " ++ show sym.anno
            --     ++ ", simple: " ++ show e
            --     ++ ", self: " ++ show self
            --     ++ ", down: " ++ show down))
            if !sym.anno && e && self == 0 && down == 1       -- used exactly once, note that use
                                                              -- in a local function counts twice.
                    && not sym.strsig.isStrict                -- do not inline strict names                    
            then do
                -- inline that
                let inline = if isPSigma sym.typ then cx
                                else Ann {ex = cx, typ = Just sym.typ}
                ex <- replSid sym.sid inline ulet
                E.logmsg TRACE7 sym.pos (text ("let " ++ nice x g ++ " = " ++ nice inline g ++ " in ... replaced with " ++ nice ex g))
                return (Right ex)
            --
            --  globalize annotated CAFs, if possible
            --
            else if sym.anno && isOff g.options.flags NOUNLET then do
                used  <- U.localSyms cx
                inner <- innerSids cx
                if all ((inner `including` sym.sid)  `contains`) (keys used)
                then do
                     g <- getST
                     let name = U.unusedName (VName g.thisPack x.base)  g
                     ex <- replName sym.sid name cx  -- no reference to x anymore
                     letex2 <- replName sym.sid name ulet  -- in the inner of the lambda or the let ex
                     let vks  = U.freeTVars [] sym.typ.rho
                     let typ  = ForAll vks sym.typ.rho
                     enter sym.{sid = 0, name, expr = Just (return ex), vis = Private, typ}
                     changeST Global.{sub <- SubSt.{
                                     idKind <- insert (KeyTk sym.pos.first) (Right name)}}
                     E.logmsg TRACE7 sym.pos (text ("let " ++ nice x g ++ " = " ++ nice cx g ++ " in ... replaced with " ++ nice letex2 g))
                     E.logmsg TRACE7 sym.pos (text ("new name is " ++ name.nice g))
                     E.hint sym.pos (text("let definition is a constant: " ++ name.nice g))
                     return (Right letex2)       -- no other opportunities possible here
                else stio (Right xlet.{ex = ulet})
            else stio (Right xlet.{ex = ulet})
        other -> stio (Left xlet)
unLet x = stio (Left x)
