{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011 - 2015, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
 * This package deals with various transformations.
 * In compiler pass 7, we unroll let definitions like so:
 * > let a = ex1; b = ex2 in ex3  ==> let a = ex1 in let b = ex2 in ex3
 * provided _ex2_ does not reference _a_.
 -}


package frege.compiler.Transform where

import frege.Prelude hiding(<+>)

import Data.TreeMap as TM(TreeMap, TreeSet, lookup, insert, keys, values, each,
                    fromKeys, including, contains, union)
import Data.List as DL(uniq, sort, partitioned, elemBy)
import Data.Bits (BitSet, BitSet.member, BitSet.union bitunion, BitSet.intersection, BitSet.difference)
import Data.Graph (stronglyConnectedComponents tsort)

import  Compiler.enums.Flags 
import  Compiler.enums.TokenID(VARID)
import  Compiler.enums.RFlag
import  Compiler.enums.Visibility
import  Compiler.enums.SymState
import  Compiler.enums.Literals
import  Compiler.enums.CaseKind

import  Compiler.types.Positions
import  Compiler.types.Tokens
import  Compiler.types.Strictness
import  Compiler.types.Packs
import  Compiler.types.QNames
import  Compiler.types.Types
import  Compiler.types.Patterns
import  Compiler.types.Expression
import  Compiler.types.Symbols
import  Compiler.types.Global as G

import  Compiler.common.Errors as E()
import  Compiler.common.SymbolTable
import  Compiler.common.Binders

import  Compiler.classes.Nice

import Lib.PP (msgdoc, text, </>)
import frege.compiler.Utilities     as U(allourvars, allvars)
import frege.compiler.Typecheck     as TC(checkRho, substInst, zonkExpr)
import frege.compiler.tc.Util        as TCU()

post = stio true

pass7 = do
    g <- getST

    -- unroll let expressions
    let collectedvars = allourvars g
    foreach collectedvars unrollSym

    -- simplify let expressions by lifting local function bindings to the top
    -- or inlining variables
    g <- getST
    let collectedvars = allourvars g
    foreach collectedvars unLetSym

    stio ("expressions", 2 * length collectedvars)

--- actually, this runs after 'pass9' and before 'pass10'
pass8 = do
    g <- getST

    -- find closed lambdas and make them private global functions
    let collectedvars = allourvars g 
    foreach collectedvars closedLambdaSym
    stio ("expressions", length collectedvars)



{--
 * Strictness analysis
 *
 * - native functions are strict in all arguments
 * - constructors are lazy in all arguments (but we can adapt this later if the need arises)
 * - every symbol will get a strictness signature and status StrictChecked
 -}
pass10 = do
        g <- getST
        let ourvars = allourvars g
        names <- mapSt U.fundep ourvars

        let groups = tsort names

        g <- getST
        E.logmsg TRACES Position.null (text ("names: " ++ joined " " (map (flip QName.nice g • fst) names)))
        E.logmsg TRACES Position.null (text ("groups: " ++ display (map (map (flip QName.nice g)) groups)))

        foreach groups checkgroup
        
        -- bring default class methods in good shape
        g <- getST
        let classmethods = [ sym | SymC{env} <- values g.thisTab, sym@SymV{expr = Just _} <- values env ]
        foreach classmethods easyClassMethodSym 

        stio ("functions", length names)
    where
        -- checkgroup :: [QName] -> StG ()
        checkgroup nms = do
            foreach nms (strictName [])         -- compute strictness
            returnNames [] nms                  -- compute return type of java methods

{--
 * In this pass, we make sure that all expressions are in
 * a form we need for code generation. We say that an expression is, or is not /easy/.
 *
 * - Every simple expression is also easy.
 * - A literal is simple.
 * - A variable is simple.
 * - A constructor name is simple.
 * - @(x::t)@ has the same properties as @x@
 * - @if a then b else c@ is easy if @b@ and @c@ are easy and @a@ is simple.
 *   If @b@ and @c@ are also simple, then the whole expression is simple.
 * - @a b@ is simple if @a@ and @b@ are both simple. Otherwise the application is
 *   not easy.
 * - @let v = x in e@ is easy, if @x@ is simple and @e@ is easy.
 * - @\p -> x@ is simple, if @x@ is easy
 * - @case x of { p1 -> a1; ...; pn -> an }@ is easy if @x@ is simple and
 *   all alternatives @a1@ ... @an@ are easy.
 *
 * An example for an expression that is not easy would be 
 * > f (case x of p -> e)
 * This is because
 * for an application to be easy, all subexpressions must be simple, 
 * and a case expression can only be easy, but never simple.
 *
 * It can be seen, that an arbitrary expression can be made easy if there is
 * a way to make any expression simple.
 * The latter is indeed possible, because for any expression /x/ 
 * > (\_ -> ex) C
 * is simple, where /ex/ is an easy version of /x/. Together with the
 * observation, that to make an expression easy, only /strictly smaller/
 * expressions need to be made simple (and easy), 
 * which guarantees progress and termination, the proof is complete.

 * This pass should run before strictness analysis so that local definitions
 * we need to introduce get strictness info.
 -}
pass9 = do
    g <- getST
    -- set lambdadepth for each symbol
    let collectedvars = allourvars g
    foreach collectedvars depthSym
    
    -- check instance member's depth
    g <- getST
    let imembers = [ imem | inst@SymI{} <- values g.thisTab,
                            g.our inst.name, 
                            imem <- values inst.env ]
    foreach imembers checkDepth 
    -- make all expressions easy
    g <- getST
    let collectedvars = allourvars g
    foreach collectedvars easySym
    
    stio ("expressions", length collectedvars)

easySym (vsym@SymV {pos})
    
    | Just dx <- vsym.expr = do
        g <- getST
        x <- dx
        if isOn g.options.flags INLINE && not (defaultMethod vsym.name g) then do
            ux <- inlined x >>= easyExpression
            changeSym vsym.{expr = Just (return ux)}
        else do
            nx <- easyExpression x
            changeSym vsym.{expr = Just (return nx)}
    
    | otherwise = stio ()
    
    where
        defaultMethod name g = case name of
                MName tname _ -> case g.findit tname of
                    Just SymC{} -> true
                    _           -> false
                _ -> false

easySym sym = do
    g <- getST
    E.fatal sym.pos (text ("easySym no SymV : " ++ sym.nice g))

simpleSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- x >>= mkSimple
        changeSym vsym.{expr = Just (return nx)}
    | otherwise = stio ()
simpleSym sym = do
    g <- getST
    E.fatal sym.pos (text ("simpleSym no SymV : " ++ sym.nice g))


{--
    All default class methods must be exported, so instances can derive their own version.
    Not all expressions can be exported.
    In particular they can't if at least one
    of the following applies:
    - a lambda contains a pattern that is refutable
    - a case contains a set of patterns that is refutable
    - it references a private item because this would not resolve when the code is imported
    - it contains a let or where, because the metadata does not know lets (often, lets in
      the source code are transformed to a case, or it's dropped).
    
    To nevertheless being able to export such a class method, the complicated code is moved
    to a new top level function, and the class will only contain an application of this new
    function to the arguments.
    > method a b = let c = b+1 in a c
    transforms to:
    > anon a b = let c = b+1 in a c
    > method a' b' = anon a' b'   
    -}
easyClassMethodSym :: Symbol -> StG ()
easyClassMethodSym (sym@SymV{expr = Just dx, typ}) = do
        x <- dx
        easy <- goodClassMethod x
        unless ( easy ) do
            g <- getST
            U.symWarning E.warn sym (text (nice sym g
                ++ (if easy then "" else " is not easy enough ") 
                ++ (if RSafeTC  `member` sym.rkind  then "" else " recurses deeply ")
                ++ (if RTailRec `member` sym.rkind  then " is tail recursive " else "")))
            let name = U.unusedName (VName (Global.thisPack g) (sym.name.base)) g
            
            nx <- replName sym.sid name x
            
            let anon = sym.{sid=0, name, vis = Protected, expr = Just (return nx)}
                vbl = Vbl{name, pos=anon.pos.change VARID name.base, typ=Just (ForAll [] sym.typ.rho)}
                rk = (sym.rkind.unionE RSafeTC).differenceE RTailRec
            enter anon  
            x <- etaExpand vbl
            changeSym sym.{expr = Just (return x), rkind = rk}
    where
        -- goodClassMethod :: Expr -> StG Bool
        goodClassMethod x = do
            g <- getST
            -- l <- return sym.depth
            case x of
                Ann{} -> goodClassMethod x.ex
                App{} -> liftM2 (&&) (goodClassMethod x.fun) (goodClassMethod x.arg)
                Vbl{name=Local{}} -> return true
                Vbl{name} -> do
                    vsym <- U.findV name
                    -- when (vsym.vis == Private) do
                    --     E.hint (getpos x) (text("uses private " ++ nice name g))
                    return (vsym.vis != Private)
                Con{name} -> return true        -- constructors always exported
                Case{} -> do
                    g <- getST
                    -- do not check the guards, they are checked through Lam and
                    -- the case statement they are in.
                    let compl = x.ckind == CWhen || isNothing (caseComplete g x)
                    eok <- mapM goodClassMethod (map CAlt.ex x.alts)
                    return (and (compl:eok))                    
                Lam{pat,ex}   -> do
                    g <- getST
                    case caseComplete g (Case CNormal ex [CAlt pat ex] Nothing) of
                        Just p  -> do
                            -- E.hint (getpos x) (text("incomplete: " ++ nicer p g))
                            return false      -- incomplete pattern or open case when
                        nothing -> goodClassMethod ex
                Ifte{}  -> do
                    c <- goodClassMethod x.cnd
                    if c then 
                        liftM2 (&&) (goodClassMethod x.thn) (goodClassMethod x.els)
                    else return false                        
                Lit{}   -> return true
                Let{}   -> return false     -- not allowed
                Mem{}   -> return false     -- may not happen 
easyClassMethodSym sym = return ()

checkDepth (vsym@SymV {pos, name = MName inst  base}) = do
        g <- getST
        cmeth <- classMethodOfInstMethod pos inst base
        when (cmeth.depth > vsym.depth) do
            U.symWarning E.hint vsym (msgdoc (
                nicer vsym g ++ " has depth " ++ show vsym.depth
                ++ " while " 
                ++ nicer cmeth g ++ " has depth " ++ show cmeth.depth))
        when (cmeth.depth < vsym.depth) do
            changeSym vsym.{depth = cmeth.depth}
        return ()
checkDepth (vsym@SymL {pos, alias, name = MName inst  base}) = do
        g <- getST
        cmeth <- classMethodOfInstMethod pos inst base
        rmeth <- U.findVD alias
        let d = if rmeth.{depth?} then rmeth.depth else U.arity rmeth
        when (cmeth.depth != d) do
            E.error pos (msgdoc (
                nicer rmeth g ++ " is not a suitable implementation  for "
                ++ nicer vsym.name g  
                ++ " because it has depth " ++ show d
                ++ " while " 
                ++ nicer cmeth g ++ " has depth " ++ show cmeth.depth))
        return ()
checkDepth bad = do
    g <- getST
    E.fatal bad.pos (text(nicer bad g ++ " must not occur in instances.")) 

classMethodOfInstMethod :: Position -> QName -> String -> StG Symbol
classMethodOfInstMethod pos inst base = do
    g <- getST 
    case g.findit inst of
        Just isym | SymI{clas} <- isym = case g.findit clas of
            Just csym | SymC{supers} <- csym = do
                let sym = head [ sym | c <- clas:supers, SymC{env} <- g.findit c,
                            sym <- values env,
                            sym.name.base == base ]
                return sym
            other -> E.fatal pos (text ("classMethodOfInstMethod: " ++ nice clas g ++ " not a type class."))
        other -> E.fatal pos (text ("classMethodOfInstMethod: " ++ nice inst g ++ " not an instance.")) 
            

depthSym (vsym@SymV {pos})
    | Just dx <- vsym.expr = do
        x  <- dx
        nx <- depthExpr x
        let depth = U.lambdaDepth nx
        when (depth > length sigmas) do
                g <- getST
                E.error vsym.pos (msgdoc (nice vsym.name g
                    ++ ": the expression " ++ nicer nx g
                    ++ " has more nested lambdas (" ++ show depth 
                    ++ ") than permitted by the arity (" ++ show (length sigmas)
                    ++ ") of its type " ++ nicer typ g))
                E.hint vsym.pos (msgdoc ("This is probably a compiler error."))
        if (depth >= length sigmas)
            then changeSym vsym.{expr = Just (return nx), typ, depth}       -- fine, unless error
            else do
                g <- getST                                      -- depth < sigmas, eta expand it
                newx <- etaExpand nx
                let newd = U.lambdaDepth newx
                E.logmsg TRACE9 (vsym.pos) (text ("eta expanded "
                    ++ nice vsym.name g ++ "::" ++ nice typ g
                    ++ " to lambda depth " ++ show newd))
                E.logmsg TRACE9 vsym.pos (text ("old expr: " ++ nice nx   g ++ " :: "
                        ++ maybe "nix" (flip nice g) nx.typ))
                E.logmsg TRACE9 vsym.pos (text ("new expr: " ++ nice newx g
                        ++ " :: " ++ maybe "nix" (flip nice g) nx.typ))
                changeSym vsym.{expr = Just (return newx), typ, depth = newd}
                when (newd != (length sigmas)) do
                    E.fatal vsym.pos (text (nice vsym g ++ ": after eta expansion depth="
                        ++ show newd ++ ", length sigmas=" ++ show (length sigmas)
                        ++", turn on -x9")) 
    | otherwise = changeSym vsym.{depth = length sigmas}
    where
        typ = vsym.typ.{rho <- U.unTau} -- a -> (b->c)  -->  a -> b -> c
        (_, sigmas) = U.returnType typ.rho
        depthExpr = U.mapEx false depthX
        depthX  x
            | Let {env} <- x = do
                syms <- mapSt U.findV env
                foreach syms depthSym
                stio (Left x)
            | otherwise = stio (Left x)


depthSym sym = do
    g <- getST
    E.fatal sym.pos (text ("depthSym no SymV : " ++ sym.nice g))

{--
    Eta expansion, applied to a value @x@ with function type
    yields another expression @\\n -> x n@ with the same type.

    This is done as long as the lambda body has still function type.

    This will remove points free stype from definitions like

    > sum = fold (+) 0

    and will turn it into

    > sum n = fold (+) 0 n

    thus promoting fully satisfied applications as often as possible.

    Eta expansion must be done after type check and should be done before strictness check.
-}
etaExpand :: Expr -> StG Expr

etaExpand (lam@Lam {}) = do                 -- eta (\a -> x) = \a -> eta x
            nex <- etaExpand lam.ex
            stio lam.{ex=nex}

etaExpand (x@Ann {}) = do                   -- eta (x :: y) = (eta x :: y)
            nex <- etaExpand x.ex
            stio x.{ex=nex}

etaExpand x = case x.typ of                 -- all other expressions
    Just (ForAll [] (RhoTau ctx tau))
        | Just (farg, fret) <- tau.getFun = do
            uniq <- uniqid
            let var = "η" ++ show uniq
                pos  = (getpos x).change VARID var
                arg = ForAll [] (RhoTau [] farg)
                res = RhoTau [] fret
                sym = U.patLocal pos uniq var
                app = App x (Vbl {pos, name=sym.name, typ = Just arg}) (Just (ForAll [] res))
                pat = PVar {pos=pos, uid=uniq, var}
                -- env = insert Nil pat.var (U.patLocal pos pat.var).{sid=uniq}
            enter sym.{state=Typechecked, typ=arg}
            body <- etaExpand app
            stio  Lam {pat, ex=body, typ = Just (ForAll [] (RhoFun ctx arg res))}
        | otherwise = stio x
    Just (ForAll [] (RhoFun ctx arg res)) = do
            uniq <- uniqid
            sarg <- TCU.skolemise arg
            let pos = (getpos x).change VARID name
                name = "η" ++ show uniq
                pat = PVar{pos=getpos x, uid=uniq, var=name}
                sym = U.patLocal pos uniq name
                iarg = ForAll [] (snd sarg)     -- Num t42#a => t42#a -> t42#a
                app = App x (Vbl {pos, name=sym.name, typ = Just iarg}) (Just (ForAll [] res))
            -- sym <- U.mkLocal pat
            enter sym.{state=Typechecked, typ=arg}
            body <- etaExpand app
            stio  Lam {pat, ex=body, typ = x.typ}

    Just sig = do
        g <- getST
        E.warn (getpos x) (msgdoc ("can't do eta expansion for an expression of type " ++ nice sig g))
        E.hint (getpos x) (msgdoc ("try to write the surrounding binding in a eta expanded form"))
        stio x
    Nothing -> do
        g <- getST
        E.fatal (getpos x) (msgdoc ("eta expansion must be done after type check for "
             ++ nice x g))
        stio x


{--
 * [usage] @returnKind group symbol@
 * [computes] the return type (lazy=0, boxed=1) of the r-Method, and, if a w-Method is needed,
 * the return kind of the w-Method (none, lazy=2, boxed=4, strict=6)
 *
 * - non nullary Constructors have implicitely 1101 (boxed mk-Method, boxed r-Method)
 *   and are safe tail calls (as they return immediately with the new object)
 * - Native methods have 5 or 7 (the native method *is* the w method, and if the return type
 *   is a java type, then it is 7, otherwise 5 (Maybe, Either or ST s/IO). They make also
 *   safe tail calls.
 * - if functions with constraints have a w-Method, this will be an instance method,
 *   otherwise a static one.
 * - a function with a strict argument gets a w-Method
 * - a CAF (lambdadepth = 0) will have no w-Method. The rkind will show if the CAF is
 *   declared with a lazy type or not. The bit 16 is on if the expression is simple
 *   and no self references or possibly forward references exist.
 *   Forward references can appear in global symbols which reference any global
 *   value from this package.
 -}
returnKind syms (sym@SymV {nativ = Just _}) = do
        g <- getST
        -- jt <- U.isJavaType ((fst • U.returnType) sym.typ.rho)
        changeSym sym.{rkind = RState.fromList [RSafeTC, RValue]}

returnKind syms (sym@SymV {expr = Just dx, depth = 0}) = do
        x      <- dx
        w      <- returnExprKind syms sym x
        self   <- references [sym.sid] x        -- is it self-referential?
        rec    <- references syms x             -- is it recursive
        g      <- getST
        (_, deps) <- U.fundep sym
        let local = sym.name.isLocal                            -- is this a local item?
            sx    = isMeager x 
        let fwrefs
                | local                = self > 0
                | MName{}  <- sym.name = not (null deps)        -- possible forward references?
                | null syms            = self > 0
                | [mutual] <- syms     = mutual != sym.sid || self > 0
                | otherwise            = true
            safe   = if rec > 0 then RState.empty else RState.singleton RSafeTC
            simple = if sx && not fwrefs && self == 0 
                    then RState.singleton RSimple 
                    else RState.empty
            stricter = (null sym.typ.bound || isAtomic x)          -- don't make 'undefined' strict!
                        && not local
                        && RSafeTC `member` safe
                        && RSimple `member` simple 
                    || Strictness.isStrict sym.strsig   -- if it is strict anyway        
            value  = RState.singleton (if except then  RValue else RAlways)   
            rkind = (safe.union simple).union value
            stri  = if except && not (Strictness.isStrict sym.strsig)
                    then S[] else sym.strsig
            except 
                | stricter,
                  not (RSimple `member` simple),
                  RValue `member` w,
                  not (RSafeTC `member` w)  = false -- don't return a lazy result
                                                    -- and force it right away in the eval() fun
                | stricter, local, self > 0 = false -- local self refs must be lazy 
                | otherwise                 = stricter
        changeSym sym.{rkind, strsig = stri}

returnKind syms (sym@SymV {expr = Just dx}) = do
        x      <- dx
        w      <- returnExprKind syms sym x
        g      <- getST
        
        let sx = isSimple g x
        
        let rkind = if sx then w.unionE RSimple else w
            -- if we have proper tail calls then all functions
            -- are safe tail calls. 
            xkind = if isOn g.options.flags PROPERTC 
                        then rkind.unionE RSafeTC else rkind
        -- instance functions must be at least as strict as their class functions
        -- class functions must be RSafeTC
        case sym.name of
            MName inst base | Just symic <- g.findit inst = case symic of
                SymC{} ->  do
                            let nkind = (xkind.differenceE RAlways).union classMemberState
                            changeSym sym.{rkind=nkind}
                SymI{} ->  do
                        cm <- classMethodOfInstMethod sym.pos inst base
                        if cm.rkind.null then do
                            returnKind [] cm
                            returnKind syms sym
                        else do
                            -- let nkind = (xkind.differenceE RAlways).union cm.rkind
                            changeSym sym.{rkind = xkind}
                other -> changeSym sym.{rkind = xkind} 
            other -> changeSym sym.{rkind = xkind}

--- assume abstract class functions are tail call safe 
returnKind syms (sym@SymV {expr = Nothing, name = MName _ _}) 
    = changeSym sym.{rkind=classMemberState}
returnKind _ _ = stio ()     -- abstract methods

--- the default state of a class member
classMemberState = RState.fromList [RSafeTC]

{--
 * how often the symbol with 'Symbol.sid' is referenced in 'Expr' @x@
 -}
references sids x = U.foldEx true refs 0 x
    where
        refs n (Vbl {pos,name}) = do
            -- g <- getST
            -- E.logmsg TRACE7 pos ("references " ++ show n ++ " " ++ show sids ++ "  " ++ nice name g)
            sym <- U.findVD name
            if sym.sid `elem` sids then stio (Right (n+1)) else stio (Left n)
        refs n (Ifte c t e _) = do
            crefs <- references sids c
            trefs <- references sids t
            erefs <- references sids e
            stio (Right (n + crefs + max trefs erefs))
        refs n (Case {ex,alts}) = do
            xrefs <- references sids ex
            arefs <- mapSt altRefs alts
            stio (Right (n + xrefs + fold max 0 arefs))
        refs n (Lam {ex}) = do
            lrefs <- references sids ex
            stio (Right (n + lrefs))
        refs n (Let {env,ex}) = do
            syms  <- mapSt U.findV env
            srefs <-sequence [ subex | SymV{expr = Just subex} <- syms ] >>= mapSt (references sids) 
            lrefs <- references sids ex
            stio (Right (n + 2*sum srefs + lrefs))             
        refs n x = do
            -- g <- getST
            -- E.logmsg TRACE7 (getpos x) ("references " ++ show n ++ " " ++ show sids ++ "  " ++ nice x g)
            stio (Left n)
        altRefs (CAlt {ex}) = references sids ex

{--
 * [usage] @returnExprKind syms symbol x@
 *
 * Look for the return expressions in @x@ and compute the minimum return kind.
 * If any symbol in @syms@ is called, it is regarded as recursive and not fit
 * for tailcall.
 *
 * A return expression is an application, literal, variable or constructor.
 *
 * - When it is a literal, unboxed return (6) is possible.
 * - When it is a local lambda or case bound variable,
 *   return will be according to the variable's strictness boxed or lazy.
 *   Otherwise, it's the return kind of the variable.
 * - Constructor is either a function or a nullary constructor - both are boxed.
 * - A tail recursive application is either 6 or 4, depending on return type
 * - A tail call to a native function or a constructor is 4 or 6 depending on their w-value
 * - Otherwise, if the application is saturated or a lambda/case-bound variable is applied,
 *   it's lazy.
 * - Unsaturated applications are boxed (function types)
 -}
returnExprKind syms sym (x@Lit {pos}) = stio (RState.fromList [RSafeTC, RValue])
returnExprKind syms sym (x@Con {pos}) = stio (RState.fromList [RSafeTC, RValue])
returnExprKind syms sym (x@Ann {ex})  = returnExprKind syms sym ex

returnExprKind syms sym (x@Vbl {name}) = do
    symv <- U.findV name
    g    <- getST
    case symv.gExpr g of
        Nothing -> case symv.name of
            Local{} -> stio (RState.fromList [RSafeTC, RValue])
            _ -> case U.returnType symv.typ.rho of
                (_,[]) -> stio (BitSet.union (RState.singleton RSafeTC) symv.rkind)
                _      -> stio (RState.fromList [RSafeTC, RValue])      -- global function
        Just (Lam {})  -> stio (RState.fromList [RSafeTC, RValue])      -- return a local function
        Just vx -> stio (RState.fromList [RSafeTC, RValue])

returnExprKind syms sym (ex@App a b typ) = do
    returnExprKind syms sym a
    returnExprKind syms sym b
    let (f,_) = head fx
        args  = tail fx
        fx = flatx ex
        -- app = App a b typ
    case f of
        Vbl {name} -> do
            symf <- U.findV name
            g <- getST
            let -- r  = symf.rkind `intersection` RState.singleton RSafeTC
                rwa = if RSafeTC `member` symf.rkind 
                        then RState.fromList [RSafeTC, RValue]
                        else RState.singleton RSafeTC
                rw  | MName tname _ <- symf.name,
                      Just SymC{} <- g.findit tname 
                    = (rwa.differenceE RValue).unionE RAlways   -- call class methods lazy
                    | otherwise = rwa
            if isJust symf.nativ then stio (rw)
              else if (length args < symf.depth) 
                    then stio ((rw.differenceE RAlways).unionE RValue)     -- unsaturated function is a LAMBDA value
              else case symf.expr of
                    Nothing -> case name of
                        Local{} -> stio (RState.singleton RSafeTC)  -- application of lambda/case bound
                        _       -> stio (rw)                        -- global fun
                    Just _ -> do
                        g <- getST
                        if symf.sid == Symbol.sid sym               -- self recursive
                            then stio (RState.fromList [RSafeTC, RTailRec, RValue])
                            else if (symf.sid `elem` syms)
                                then if isOn g.options.flags PROPERTC
                                    then stio  (RState.fromList [RSafeTC, RValue])        -- just like not recursive
                                    else
                                        -- Call of a function in the dependency group
                                        -- This makes this one not tail safe ...
                                        -- ... UNLESS the called is already not tail safe.
                                        -- Because if this is so,  code generation
                                        -- delays this anyway. Hence we are tail safe.
                                        if RSafeTC `member` symf.rkind
                                        then stio (RState.singleton RAlways)    
                                        else stio (RState.singleton RSafeTC)
                                else return rw                          -- this is safe tc and value
        Con {name} -> stio (RState.fromList [RSafeTC, RValue])
        _ -> do
                n <- references syms f
                if n > 0
                    then stio (RState.singleton RAlways)       -- better safe than sorry
                    else stio (RState.fromList [RSafeTC, RValue])


returnExprKind syms sym (Ifte c t e typ) = do
    rec <- references syms c    --
    returnExprKind syms sym c
    w1 <- returnExprKind syms sym t
    w2 <- returnExprKind syms sym e
    let -- always = not (RValue `member` w1) && not (RValue `member` w2)
        -- value  = (RValue `member` w1) && (RValue `member` w2)
        res = if rec > 0 
            then minRkind w1 w2 `difference` RState.fromList [RSafeTC] 
            else minRkind w1 w2
    stio (res)

returnExprKind syms sym (x@Lam {ex}) = returnExprKind syms sym ex
        
returnExprKind syms sym (x@Let {env,ex}) = do
        returnNames syms env
        returnExprKind syms sym ex
        
returnExprKind syms sym (x@Case {ex, alts}) = do
    returnExprKind syms sym ex
    rec     <- references syms ex
    wsalts <- mapSt (altExprKind syms sym) alts
    let m = foldl1 minRkind wsalts
        res = if rec > 0 then m `difference` RState.fromList [RSafeTC] else m
    stio (res)
returnExprKind syms sym _ = error "returnExprKindbad epr."

altExprKind syms sym (alt@CAlt {ex}) = returnExprKind syms sym ex

{--
    combine two rkinds by taking the minimum of the lower 3 bits and the maximum of
    the 2³ bit, which signifies tail recursion.
 -}
minRkind a b = (safetc.union tailbit).union wrbits where
    safetc  = if (RSafeTC `member` a) && (RSafeTC `member` b) 
                then RState.singleton RSafeTC else RState.empty
    tailbit = if (RTailRec `member` a) || (RTailRec `member` b)
                then RState.singleton RTailRec else RState.empty
    wrbits  = if (RValue `member` a) && (RValue  `member` b) 
                                     && (RSafeTC `member` safetc)
                then RState.singleton RValue
                else if (RAlways `member` a) && (RAlways `member` b)
                then RState.singleton RAlways
                else RState.empty

{--
 * [usage] returnNames names name
 *
 * gets the symbol and stores the information computed by 'returnKind' in the 'Symbol.rkind'
 * field.
 *
 * The @names@ list gives the names that are mutually dependend on this one.
 -}
returnNames sids nms = do
        syms  <- mapSt U.findV nms
        let !deps = sids ++ map Symbol.sid syms
        foreach syms setsafetc
        foreach syms (returnKind deps)
    where
        setsafetc :: Symbol -> StG ()
        setsafetc sym = changeSym  sym.{rkind = BitSet.singleton RSafeTC}
    

unrollSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- x >>= unrollExpr 
        changeSym vsym.{expr = Just (return nx)}
    | otherwise = stio ()       -- do nothing
unrollSym sym = do
    g <- getST
    E.fatal sym.pos (text ("unrollSym no SymV : " ++ sym.nice g))


unLetSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- x >>= unLetExpr
        changeSym vsym.{expr = Just (return nx)}
    | otherwise = stio ()       -- do nothing
unLetSym sym = do
    g <- getST
    E.fatal sym.pos (text ("unLetSym no SymV : " ++ sym.nice g))

{-
singleLetSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- singleLetExpr x
        changeSym vsym.{expr = Just nx}
    | otherwise = stio ()       // do nothing
singleLetSym sym = do
    g <- getST
    E.fatal sym.pos ("unrollSym no SymV : " ++ sym.nice g)
    -}

closedLambdaSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- x >>= U.mapExBody true closedLambda
        changeSym vsym.{expr = Just (return nx)}
    | otherwise = stio ()
closedLambdaSym sym = do
    g <- getST
    E.fatal sym.pos (text ("closedLambdaSym no SymV : " ++ sym.nice g))

{-
closedLambdaInInnerSym (vsym@SymV{}) 
    | Just x <- vsym.expr = do
        nx <- U.mapEx true closedLambda x
        changeSym vsym.{expr = Just nx}
    | otherwise = stio ()
closedLambdaInInnerSym sym = do
    g <- getST
    E.fatal sym.pos (text ("closedLambdaSym no SymV : " ++ sym.nice g))

renameSym (vsym@SymV {})
    | Just x <- vsym.expr = do
        nx <- U.mapEx true renameLocals x
        changeSym vsym.{expr = Just nx}
    | otherwise = stio ()
renameSym sym = do
    g <- getST
    E.fatal sym.pos (text ("renameSym no SymV : " ++ sym.nice g))

--- map an environment to contain changed names and symbols
renamedEnv = Tree.fromList • map renamekv • each
    where
       renamekv (k, sym@SymV {name=Local 0 s, sid}) = ((mangled s ++ "_" ++ U.base32 sid),
                                              sym.{name = Local 0 (mangled s ++ "_" ++ U.base32 sid)})
       renamekv (k, sym) = error ("bad env, k=" ++ k ++ ", name = " ++ show sym.name)

--- rename all local variables in patterns and expressions
renameLocals (lam@Lam{env,pat,ex}) = with env do
    g <- getST
    let nenv = renamedEnv env
    E.logmsg TRACE8 (getpos lam) (text ("renameLocals before: " ++ nice lam g ++ "  " ++ show ((keys env)) ++ "  " ++ show ((keys nenv))))
    npat <- replPat pat
    E.logmsg TRACE8 (getpos lam) (text ("renameLocals pattern " ++ nice npat g))
    nex  <- replVar (map Symbol.sid (values env)) ex
    let nlam = lam.{env=nenv, ex=nex, pat=npat}
    E.logmsg TRACE8 (getpos lam) (text ("renameLocals after:  " ++ nice nlam g))
    stio (Left nlam)
renameLocals (cas@Case {alts}) = do
    nalts <- mapSt renameAlt alts
    stio (Left cas.{alts=nalts})
renameLocals (letex@Let {env, ex})
        | [(k, SymV {sid, expr=Just _})] <- each env = do        -- exactly 1 definition
            g <- getST
            E.logmsg TRACE8 (getpos letex) (text ("renameLocals before: " ++ nice letex g ++ "  " ++ show ((keys env))))
            let repsym (k,v@SymV {sid, expr = Just x}) = do
                    nx <- with env (replVar [sid] x)
                    stio (k, v.{expr = Just nx})
                repsym (k,v) = stio (k, v)
            nlst <- mapSt repsym (each (renamedEnv env))
            E.logmsg TRACE8 (getpos letex) (text ("renameLocals new: " ++ show (map (fst) nlst)))
            nex <- with env (replVar [sid] ex)
            let nenv = Tree.fromList nlst
                nlet = letex.{ex=nex, env=nenv}
            E.logmsg TRACE8 (getpos letex) (text ("renameLocals before: " ++ nice nlet g))
            stio (Left nlet)
renameLocals other = stio (Left other)

--- rename local variables in a case alternative
renameAlt :: CAlt -> StG CAlt
renameAlt alt = with alt.env do
    g <- getST
    let nenv = renamedEnv alt.env
        -- renameX = [replName (Symbol.sid sym) (Symbol.name sym) | (nm, sym) <- each nenv]
        -- renameP = [replPat  (Symbol.sid sym) nm                | (nm, sym) <- each nenv]
    E.logmsg TRACE8 (getpos alt.pat) (text ("renameAlt before: " ++ nice alt.pat g ++ " -> " ++ nice alt.ex g))
    nex  <- replVar (map Symbol.sid (values alt.env)) alt.ex
    npat <- replPat alt.pat
    let nalt = alt.{env=nenv, ex=nex, pat=npat}
    E.logmsg TRACE8 (getpos alt.pat) (text ("renameAlt after:  " ++ nice npat g ++ " -> " ++ nice nex g))
    stio nalt
-}    

unrollExpr    = U.mapEx true unrollLet
unLetExpr x   = U.mapEx true unusedLet x >>= U.mapEx true unLet


unrollLet (x@Let {env,ex}) = do
        g <- getST
        E.logmsg TRACE7 (getpos x) (text ("unrollLet: " ++ x.nice g))
        -- first do the subexpressions
        let mapsub (sy@SymV {expr=Just x}) = do
                    x <- x >>= unrollExpr
                    changeSym sy.{expr=Just (return x)}
            mapsub sy = error "mapsub: no var"
        ex  <- unrollExpr ex
        syms <- mapSt U.findV env
        foreach syms mapsub
        let -- kvs =  each env
            xdep k = do sym <- U.findV k; ldep (k, sym)
            ldep (k, SymV {expr=Nothing}) = stio (k, [])
            ldep (k, SymV {expr=Just ex}) = do
                    deps <- ex >>= letlocals
                    stio (k, deps)
            ldep (_,_) = error "ldep: no var"
        kdeps  <- mapSt xdep env
        -- env    <- foldSt pbind env kdeps
        let result = fold (sublet env) ex ((reverse • tsort) kdeps)
        E.logmsg TRACE7 (getpos x) (text ("unrollLet: " ++ result.nice g))
        stio (Right result)
    where {-
        sublet env inx [k]
                | #^.?let\$\d+$# <- k,
                  Just (vsym@SymV {expr=Just (Lam {ex,pat})}) <- lookup env k
                = Case (ck inx) ex [CAlt {pat, ex=inx}] Nothing
                where
                    ck (Case {ckind}) = ckind
                    ck _ = CNormal
                    -}
        sublet env xin locals = if null locals then xin else Let locals xin Nothing
        letlocals ex = do
            let thisSids = map QName.uid env
            usedvars <- U.foldEx true (localvar thisSids) [] ex
            stio (DL.unique usedvars)
        localvar sidset acc (Vbl {name=nm@Local{uid}}) = do
                -- sym <- U.findV nm
                if uid `elem` sidset 
                    then stio (Left (nm:acc))
                    else stio (Left acc)
        localvar sidset acc _ = stio (Left acc)
        {-
        -- here we decide whether to translate the pattern binding
        -- conservatively (let$1 = x; a = case let$1 of (a,b) -> a; b = ...
        -- or to a case (which is actually done in sublet later)
        pbind :: [QName] -> (QName, [QName]) -> StG [QName]
        pbind env (k, deps)
            | k.base ~ #^.?let\$\d+$# = do
                ksym <- U.findV k
                case ksym of
                    SymV {pos,expr = Just (Lam {pat,ex})} = do
                        let patnms = map U.pVarLocal (U.patVars pat)                        
                        -- if the pattern binding depends on itself somehow
                        if any (`elem` patnms) deps  -- if any dependency is contained in pat names
                            then do -- conservative ksym ex pat patnms
                                changeSym ksym.{expr = Just ex}  -- let$123 = x
                                foreach patnms (mkCase pat ksym)
                                stio (env ++ patnms) 
                            else stio (filter (`notElem` patnms) env)
                    _ -> stio env                    
            | otherwise = stio env
            where   
                mkCase pat sym patname = do
                    psym <- U.findV patname
                    npat <- U.pReturn pat
                    let npn = head [ Vbl{pos, name=Local uid var,typ=Nothing} | 
                                PVar{pos,uid,var} <- U.patVars npat,
                                var == patname.base ]
                        cas = Case CNormal letvar  [CAlt {pat=npat, ex=npn}] Nothing
                        letvar = Vbl{pos = Symbol.pos sym, typ = Nothing,
                                                name = Symbol.name sym}                                                
                    changeSym psym.{expr = Just cas}
                                -}
unrollLet x = stio (Left x)


--- copy expr and re-establish type
recycle newpos expr rho = do
        g <- getST
        expr <- U.copyExpr (Just newpos) empty expr
        expr <- U.untypeExpr expr
        let freevars =  U.freeTVars [] rho
        (metas, rho) <- TCU.skolemise (ForAll (map Tau.varkind freevars) rho)
        x <- checkRho expr rho
        -- foreach (zip metas freevars) (uncurry unInst)
        x <- zonkExpr x
        x <- U.mapEx true (unRigid (map _.var freevars)) x 
        x <- U.mapEx true substInst x
        E.logmsg TRACE9 (newpos) (text ("recycled  " ++ nice x g))
        stio x
    where
        unRigid b  = return . Left . Expr.{typ <- fmap (TCU.substRigidSigma b)}
        -- restore old type variables
        -- our instantiated type variable could have been unified
        -- with something else, so follow the unification path
        -- until we find an unbound type variable
        unInst (Meta (tv@Flexi{})) tvar = do
                bound <- TCU.readTv tv
                case bound of
                    Just tau -> unInst tau tvar
                    Nothing  -> TCU.writeTv tv tvar -- (ref.put (Just tvar))
        unInst _ _ = return ()  

recyclex :: Expr -> StG Expr
recyclex expr = U.copyExpr Nothing empty expr {- case expr.typ of
    Just sigma -> recycle expr sigma
    _ -> do
        g <- getST
        E.fatal (getpos expr) (text("recyclex untyped: " ++ nicer expr g)) -}

{--
 * [returns] *@true@* if expression is simple. See 'pass9' for more information.
 *
 * A simple expression can be translated to a java expression and will not need
 * blocks, if-then-else constructs, auxiliary declarations etc.
 -}
isSimple :: Global -> Expr -> Bool
isSimple g (App a b _)     = isSimple g a && isSimple g b
isSimple g (Ifte a b c _)  = isSimple g a && isSimple g b && isSimple g c
isSimple g (Ann {ex})      = isSimple g ex
isSimple g (Vbl {pos})     = true
isSimple g (Lit {pos})     = true
isSimple g (Con {pos})     = true
isSimple g (Lam {ex})      = isEasy g ex
isSimple g Mem{ex}         = isSimple g ex
isSimple g _               = false

--- a bit simpler than isSimple, as code duplication is avoided (no lambdas)
isMeager :: Expr -> Bool
isMeager (App a b _)     = isMeager a && isMeager b
isMeager (Ifte a b c _)  = isMeager a && isMeager b && isMeager c
isMeager (Ann {ex})      = isMeager ex
isMeager (Vbl {pos})     = true
isMeager (Lit {pos})     = true
isMeager (Con {pos})     = true
isMeager _               = false
 

mkSimple (x@Vbl {pos})     = return x
mkSimple (x@Lit {pos})     = return x
mkSimple (x@Con {pos})     = return x
--- @p -> x@ is simple if @x@ is easy
mkSimple (x@Lam {ex})      = do
    ex <- mkEasy ex
    return x.{ex}
mkSimple (x@Ann {ex}) = do
    ex <- mkSimple ex
    return x.{ex}
mkSimple x = do
        g <- getST
        if isSimple g x
        then return x
        else mkS x 

{--
    @mkLet ex f@ creates 
    
    > let tmp = ex in ux
    
    where @ux@ is the result of @f@ applied to the fresh pattern @p@
    -}
mkLet :: Expr -> (Expr -> Expr) -> StG Expr
mkLet ex f = do
    uid    <- uniqid
    let pos = getpos ex
        patsym = U.patLocal pos uid pat.var
        pat = PVar{pos, uid, var="tmp"}
        var = Vbl{pos, name=sym.name, typ=ex.typ}
        aex = f var
        sym = patsym.{typ = fromMaybe pSigma ex.typ, expr = Just (return ex)} 
    enter sym
    return $! Let{env=[sym.name], ex=aex, typ=aex.typ}

--- any expression x can be made simple through (\_ -> easy x) ()
mkS x = do
    e <- mkEasy x
    let lam = Lam {pat = PCon {pos, qname=unitName, pats=[]}, 
                   ex = e,
                   typ = fmap utyp e.typ}
        utyp (ForAll bound rho) = 
                        ForAll bound (
                            RhoFun [] (TC.sigFor "()") rho
                        )
        pos = getpos e                                           
        unitName = MName (TC.tc "()").name "()"
        uni = Con {pos, name=unitName, typ = Just (TC.sigFor "()")}
    g <- getST
    E.hint (getpos e) (text("extra class file needed for complicated expression " ++ nicer e g))                                           
    let !trans = App lam uni e.typ
    E.logmsg TRACE9 (getpos x) (text ("mkEasy LAM INTRO before: " ++ nice x g))
    E.logmsg TRACE9 (getpos x) (text ("mkEasy LAM INTRO after:  " ++ nice trans g))
    return trans

{--
 * [returns] *@true@* if expression is easy. See 'pass9' for more information.
 *
 * An easy expression can be translated to a series of java statements
 * with a final return, i.e. to a valid method body.
 -}
isEasy :: Global -> Expr -> Bool
isEasy g (App a b _)       = isSimple g a && isSimple g b
isEasy g (Let {env,ex})    = isEasy g ex && all (isEasy g) xprs
    where
        xprs = [ ex | q <- env, sym <- g.findit q, ex <- sym.gExpr g]
isEasy g (Case {ex,alts})   = isSimple g ex && all (isEasy g • _.ex) alts
    
isEasy g (Ifte a b c _)     = isSimple g a && isEasy g b && isEasy g c
isEasy g (Ann {ex})        = isEasy g ex
isEasy g x                 = isSimple g x

--- tracing wrapper for 'mkEasy'
easyExpression x = do
        g <- getST
        if (isOn g.options.flags TRACE9)
        then do
            r <- mkEasy x
            unless (r `exeq` x) do
                E.logmsg TRACE9 (getpos x) (text("mkEasy before: " ++ nice x g))
                E.logmsg TRACE9 (getpos r) (text("mkEasy after:  " ++ nice r g))
            easier r x
        else do
            r <- mkEasy x
            easier r x
    where
        easier r x = if r `exeq` x then return r else easyExpression r
        -- unexact (structural) equality between expressions 
        exeq :: Expr -> Expr -> Bool
        exeq (a@Vbl{})  (b@Vbl{})  = a.name == b.name
        exeq (a@Con{})  (b@Con{})  = a.name == b.name
        exeq (a@Lit{})  (b@Lit{})  = a.kind == b.kind && a.value == b.value
        exeq (a@App{})  (b@App{})  = a.fun `exeq`  b.fun 
                                        && a.arg `exeq` b.arg 
        exeq (a@Let{})  (b@Let{})  = a.ex  `exeq`  b.ex
        exeq (a@Lam{})  (b@Lam{})  = a.ex  `exeq`  b.ex
        exeq (a@Ann{})  (b@Ann{})  = a.ex  `exeq`  b.ex 
        exeq (a@Ifte{}) (b@Ifte{}) = a.cnd `exeq`  b.cnd 
                                        && a.els `exeq`  b.els 
                                        && a.thn `exeq`  b.thn
        exeq (a@Case{}) (b@Case{}) = a.ex  `exeq`  b.ex  
                                        && and (zipWith exeq (map CAlt.ex a.alts) (map CAlt.ex b.alts))
        exeq _          _          = false 

{--
    Items that can be inlined even if 1 arguments are missing.
    
     > f . g = \u -> f (g u)
     
      --} 
superOpt = [VName pPreludeBase "•",
            MName TName{pack = pControlSemi, base = "Semigroupoid_->"} "•"
        -- VName pPreludeBase "flip" 
    ]
{--
    inline all functions appropriate for inlining
    -}
inlined = U.mapEx true inline
    where
        inline (app@App{})
          | (fun,t):rest <- flatx app,
            Vbl {pos = newpos, name, typ = Just sig} <- fun,
            not name.isLocal = do
                g   <- getST
                sym <- U.findV name
                -- E.logmsg TRACE9 (getpos v) (text ("can we inline " ++ nicer sym g ++ "?"))
                case sym.expr of 
                    Just dx 
                    -- we can't inline any class methods
                    -- because, for example 
                    -- (display x) would be replaced by (show x)
                    -- Hence the instance specific functionality was lost
                    -- e.g. display "foo" = "foo"  
                    -- and  show    "foo" = "\"foo\""
                        | MName tname _ <- name,
                          Just SymC{} <- g.findit tname = return (Left app)  
                        | sym.exported, d <- length rest, 
                          d >= sym.depth ||
                            d >= sym.depth-1 && sym.name `elem` superOpt = do
                                E.logmsg TRACE9 (getpos fun) (text ("replace " 
                                    ++ nice fun g  ++ " :: " ++ nicer sig g))
                                x <- dx
                                x <- recycle newpos x sig.rho
                                return . Left . U.unflatx $ (x,t):rest
                    _ -> return (Left app)
        inline (vbl@Vbl{pos, name, typ = Just sig})
            | not name.isLocal = do
                g <- getST
                sym <- U.findV name
                case sym.expr of
                    Just dx | MName tname _ <- name,
                             Just SymC{} <- g.findit tname = return (Left vbl)
                            | sym.exported, sym.depth == 0 = do
                                E.logmsg TRACE9 pos (text ("replace " 
                                    ++ nice vbl g  ++ " :: " ++ nicer sig g))
                                x <- dx
                                x <- recycle pos x sig.rho
                                return . Left $ x
                    nothing -> return (Left vbl)
            | otherwise = return (Left vbl)
        inline x = return (Left x)        -- everything else    
                    
{--
    Perform program transformations that ensure an easy expression.
    This may imply making some sub expression simple, which, in turn,
    may imply making this sub-expression at least easy.
    The recursive process must terminate eventually at some expression that
    is inherently easy, because there is no such rule as
    > mkEasy x = mkSimple x
    but only strictly smaller expressions are considered.
        
    Annotations are pushed inside for @let@, @case@ and @if@ like in
    > if a then b else c :: t 
    > if a then b :: t else c :: t
    Hence if the result is  'Ann', the enclosed expression 
    is guaranteed not to be @let@, @case@ or @if@.
    This is important because many rules want to eliminate those in places where
    simple expressions are expected.
    
    1. Easy lambda expressions are arrived at by making the body easy.
    2. Easy @if@ eliminates @let@, @case@ and @if@ from the condition if present,
       otherwise makes the condition simple and the alternatives easy.
    3. Likewise, @case@ eliminates @let@, @case@ and @if@ from the scrutinized expression
       or makes it simple and all alternatives easy.
    4. Let makes the symbols' expression simple and the base expression easy.
    5. Function application removes @let@, @case@ and @if@ from both function and 
       argument. 
    -}
mkEasy :: Expr -> StG Expr    
mkEasy (x@Lit{})    = return x
mkEasy (x@Vbl{})    = return x
mkEasy (x@Con{})    = return x
mkEasy (ann@Ann {ex})
    | Let{}  <- ex = mkEasy ex.{ex <- ann.{ex=}}
    | Ifte{} <- ex = mkEasy ex.{thn <- ann.{ex=}, els <- ann.{ex=}}
    | Case{} <- ex = mkEasy ex.{alts <- map substAlt}
    | otherwise = do
        ex <- mkEasy ex
        return ann.{ex}
    where substAlt :: CAlt -> CAlt
          substAlt calt = calt.{ex <- ann.{ex=}}
mkEasy (x@Lam {ex}) = do
    ex <- mkEasy ex
    return x.{ex}

--- @f a@ is easy if @f@ is simple and @a@ is simple

mkEasy (x@App f arg t) = do
        -- handle argument first
        -- f (case a of {p1->x;p2->y}) ==> case a of {p1->f x;p2->f y}
        -- f (if a then b else c) ==> if a then f b else f c
        -- f (let a = b in c) ==> let a = b in f c  
        ea     <- mkEasy arg
        g      <- getST
        let simple = isSimple g ea
            meager = isMeager f
        
        let !before = App f ea t
        case ea of
            Let{} -> do
                let !trans = ea.{ex = App f ea.ex t, typ = t}
                E.logmsg TRACE9 (getpos x) (text ("mkEasy LETARG before: " ++ nice before g))
                E.logmsg TRACE9 (getpos x) (text ("mkEasy LETARG after:  " ++ nice trans g))
                mkEasy trans
            Ifte a b c _ | not simple = if meager then do
                    f'  <- recyclex f
                    f'' <- recyclex f
                    let !trans = ea.{thn = App f' b t, els = App f'' c t, typ=t}
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy IFARG before: " ++ nice before g))
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy IFARG after:  " ++ nice trans g))
                    mkEasy trans
                else do
                    trans <- mkLet ea (\v -> App f v t)
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy IFARG before: " ++ nice before g))
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy IFARG after:  " ++ nice trans g))
                    mkEasy trans 
            Case{} = if meager || length ea.alts == 1 then do
                    talts <- mapSt adapt (tail ea.alts)
                    let alt1 = head ea.alts
                    let alts = alt1.{ex <- mod f t} : talts
                    let !trans = ea.{alts, typ=t}
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy CASE1ARG before: " ++ nice before g))
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy CASE1ARG after:  " ++ nice trans g))
                    mkEasy trans
                else do
                    trans <- mkLet ea (\v -> App f v t)
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy CASEARG before: " ++ nice before g))
                    E.logmsg TRACE9 (getpos x) (text ("mkEasy CASEARG after:  " ++ nice trans g))
                    mkEasy trans
                where
                    mod f t x = App f x t
                    adapt :: CAlt -> StG CAlt
                    adapt calt = do
                        f' <- recyclex f
                        return calt.{ex <- mod f' t}
            _ -> do
                arg <- if simple then return ea else mkSimple ea
                -- handle function with simple arg
                -- (let a = b in c) r => let a = b in c r
                -- (if a then b else c) r => case r of p -> if a then b p else c p
                -- (case a of {p1->b;p2->c}) r => case a of {p1->b r;p2->c r}
                -- (\p -> a) r => case r of \p -> a
                ef <- mkEasy f
                let !before = App ef arg t
                case ef of
                    Let{} -> do
                        let !trans = ef.{ex = App ef.ex arg t, typ = t}
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy LETAPP before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy LETAPP after:  " ++ nice trans g))
                        mkEasy trans
                    Ifte{} -> do
                        r'  <- recyclex arg
                        r'' <- recyclex arg
                        let !trans = ef.{thn = App ef.thn r' t, els = App ef.els r'' t, typ = t}
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy IFAPP before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy IFAPP after:  " ++ nice trans g))
                        mkEasy trans
                        -- let mk x = ef.{thn = App ef.thn x t, els = App ef.els x t, typ = t}
                        -- mkCase arg mk
                    Case{} -> do
                        talts <- mapSt adapt (tail ef.alts)
                        let alt1   = head ef.alts
                            malt1  = alt1.{ex <- mod arg t}
                            alts   = malt1 : talts
                        let !trans = ef.{alts, typ=t}
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy CASEAPP before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy CASEAPP after:  " ++ nice trans g))
                        mkEasy trans
                      where
                            mod a t x = App x a t
                            adapt :: CAlt -> StG CAlt
                            adapt calt = do
                                r' <- recyclex arg
                                return calt.{ex <- mod r' t}
                    Lam{} -> do 
                        let !trans = Case CNormal arg [CAlt{pat=ef.pat, ex=ef.ex}] t
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy BETA before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos x) (text ("mkEasy BETA after:  " ++ nice trans g))
                        mkEasy trans
                    _ -> do
                        sf <- mkSimple ef
                        let !trans = App sf arg t
                        unless simple do 
                            E.logmsg TRACE9 (getpos x) (text ("mkEasy SIMPLE before: " ++ nice before g))
                            E.logmsg TRACE9 (getpos x) (text ("mkEasy SIMPLE after:  " ++ nice trans g))
                        return trans
                        -- case sf of
                        --     -- Don't! Transformed code must stay type correct!
                        --     -- Con{name} | newtypeCon name g -> return arg
                        --     _ -> return (App sf arg t)

            
mkEasy (x@Let{env,ex}) = do             -- TODO: handle non-recursive let/case/if
        g <- getST
        syms <- mapSt U.findV env
        mkEasyLet g x syms
    where
        mkEasyLet g (x@Let{env=[Local{uid}],ex}) [sym]
            | Just (cas@Case{alts=[alt]}) <- Symbol.gExpr sym g = do       
                -- handle  let a = case ... of p -> x in foo a
                --         case ... of p -> foo x
                ntimes <- references [uid] ex
                if ntimes == 1 || isAtomic alt.ex
                then do 
                    g <- getST
                    E.logmsg TRACE9 (getpos x) (text("mkEasyLet before: " ++ nice x g))
                    let alt = head cas.alts
                    ex <- replSid uid alt.ex ex
                    let ck
                         | isCaseWhen x.ex = CWhen
                         | otherwise = cas.ckind
                    let neu = cas.{alts=[alt.{ex}], ckind = ck}
                    E.logmsg TRACE9 (getpos x) (text("mkEasyLet after:  " ++ nice neu g))
                    mkEasy neu
                else do
                    easySym sym
                    ex <- mkEasy ex
                    return x.{ex}  
        mkEasyLet g (x@Let{env,ex}) syms = do
            foreach syms easySym 
            ex <- mkEasy ex
            return x.{ex}
        mkEasyLet g _ _ = undefined
            
mkEasy  (outer@Case{}) = do
    ea     <- mkEasy outer.ex
    g      <- getST
    let simple = isSimple g ea
    
    let !before = outer.{ex = ea}
    
    case ea of
        -- case let a = b in c of {p1->x;p2->y}
        -- let a = b in case c of {p1->x;p2->y}
        Let{} -> do
            let !trans = Let {env = ea.env, typ = outer.typ,
                                ex = outer.{ex = ea.ex}}
            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE LET before: " ++ nice before g))
            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE LET after:  " ++ nice trans g))
            mkEasy trans
        -- case if a then b else c of {p1->x;p2->y}
        -- if a then case b of {p1->x;p2->y} else case c of {p1->x;p2->y}
        Ifte{} | not simple -> do
            thn <- recyclex outer.{ex = ea.thn}
            els <- recyclex outer.{ex = ea.els}
            let !trans = ea.{thn,els,typ=outer.typ}
            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE IF before: " ++ nice before g))
            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE IF after:  " ++ nice trans g))
            mkEasy trans
        -- case case a of {b -> c; d -> e} of {f -> g; h -> i}
        -- case a of {b -> case c of {f -> g; h -> i}; d -> case e of {f' -> g'; h' -> i'}}
        -- If the outer case has only 1 alternative, but the inner one has more:
        -- case case a of {b -> c; d -> e} of { f -> g }
        -- case a of {b -> case c of f -> g; d -> case e of f -> g} 
        Case{} -> do
                talts <- mapSt adapt (tail ea.alts)
                let alt1 = (head ea.alts).{ex <- outer.{ex=}}
                let alts = alt1 : talts
                let !trans = ea.{alts, typ=outer.typ, 
                                    ckind = if outer.ckind == CWhen then CWhen else ea.ckind}
                E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE CASE before: " ++ nice before g))
                E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE CASE after:  " ++ nice trans g))
                mkEasy trans                
            where
                adapt :: CAlt -> StG CAlt
                adapt calt = do
                    ex <- recyclex outer.{ex = calt.ex}
                    E.logmsg TRACE9 (getpos outer) (text ("duplication because of  CASE/CASE" ++ nice ex g))
                    return calt.{ex}
        _ -> do
                -- case elimination possible?
                let alt1 = head outer.alts
                    match = sMatch alt1.pat ea empty
                    sxs = maybe [] each match
                substOk <- forM sxs (checkSubst alt1.ex) 
                case match of
                    Just tree | and substOk,
                                length outer.alts == 1 = do
                        ex <- foldM doSubst alt1.ex sxs
                        E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASEELIM before: " ++ nice before g))
                        E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASEELIM after:  " ++ nice ex g))
                        foreach sxs logrep
                        mkEasy ex
                    nothing = do
                        sa  <- if simple then return ea else mkSimple ea
                        alts <- mapSt easyAlt outer.alts
                        let !trans = outer.{ex=sa, alts}
                        unless simple do
                            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE SIMPLE before: " ++ nice before g))
                            E.logmsg TRACE9 (getpos outer) (text ("mkEasy CASE SIMPLE after:  " ++ nice trans g))
                        return trans
            where
                logrep (uid, ex) = E.logmsg TRACE9 (getpos outer) (text("mkEasy CASEELIM subst: " 
                                        ++ show uid ++ "  "
                                        ++ nice ex g))
                easyAlt calt = do
                    ex <- mkEasy (CAlt.ex calt)
                    return calt.{ex}
                checkSubst ex (uid, x) 
                    | isAtomic x = return true
                    | otherwise = do
                        n <- references [uid] ex
                        return (n < 2)
                doSubst ex (uid, x) = replSid uid x ex
                
                    
        
mkEasy  (Ifte a x y t) = do
    ea     <- mkEasy a
    g      <- getST
    
    let simple = isSimple g ea
    let !before = Ifte ea x y t
    
    case ea of
        -- if let a = b in c then x else y
        -- let a = b in if c then y else y
        Let{} -> do
            let !trans = Let {env=ea.env, typ=t,
                            ex = Ifte ea.ex x y t}
            E.logmsg TRACE9 (getpos before) (text ("mkEasy IF LET before: " ++ nice before g))
            E.logmsg TRACE9 (getpos before) (text ("mkEasy IF LET after:  " ++ nice trans g))
            mkEasy trans
        
        -- if (if a then b else c) then x else y
        -- if a then (if b then x else y) else (if c then x' else y')
        Ifte a b c _ | not simple -> do
            x'  <- recyclex x
            y'  <- recyclex y
            x'' <- recyclex x
            y'' <- recyclex y
            let els = Ifte c x' y' t
                thn = Ifte b x'' y'' t
                !trans = (Ifte a thn els t)
            E.logmsg TRACE9 (getpos before) (text ("mkEasy IF IF before: " ++ nice before g))
            E.logmsg TRACE9 (getpos before) (text ("mkEasy IF IF after:  " ++ nice trans g))
            mkEasy trans
            
        -- if (case a of p1 -> b; p2 -> c ...) then x else y
        -- case a of p1 -> if b then x else y; p2 -> if c then x else y   
        Case{ckind,ex=a,alts} -> do
                alts <- mapSt adapt alts
                let !trans = Case{ckind,ex=a,typ=t,alts}
                E.logmsg TRACE9 (getpos before) (text ("mkEasy IF CASE before: " ++ nice before g))
                E.logmsg TRACE9 (getpos before) (text ("mkEasy IF CASE after:  " ++ nice trans g))
                mkEasy trans 
            where
                adapt :: CAlt -> StG CAlt
                adapt calt = do
                    ex <- recyclex (Ifte calt.ex x y t)
                    return calt.{ex}
        _ -> do
            sa  <- if simple then return ea else mkSimple ea
            ex  <- mkEasy x
            ey  <- mkEasy y
            let !trans = Ifte sa ex ey t
            unless simple do 
                E.logmsg TRACE9 (getpos before) (text ("mkEasy IF SIMPLE before: " ++ nice before g))
                E.logmsg TRACE9 (getpos before) (text ("mkEasy IF SIMPLE after:  " ++ nice trans g))
            return trans

-- should not happen
mkEasy  (x@Mem{})    = return x
            
    
--- return the symbol ids of all local variables introduced in this expression and its subexpression
innerSids ex = U.foldEx true collect TreeMap.empty ex
    where
        patSids env = map Pattern.uid (U.patVars env)
        collect t (Lam {pat}) = stio (Left (fold including t (patSids pat)))
        collect t (Let {env}) = stio (Left (fold including t (map QName.uid env)))
        collect t (Case {alts}) = stio (Left (fold union t (map altSids alts)))
        collect t x = stio (Left t)
        altSids (CAlt {pat}) = fromKeys (patSids pat) :: TreeSet Int

--- @replSid sid r ex@ - replace local variables referncing sid with r in ex
replSid sid r ex = U.mapEx true action ex
    where
        action (v@Vbl {name=Local {}}) = do
            sym <- U.findVD v.name
            if sym.sid == sid then stio (Right r) else stio (Right v)
        action x = stio (Left x)

--- @replName sid nm ex@ - rename variables that references sid in ex
replName sid nm ex = U.mapEx true action ex
    where
        action (v@Vbl {name,pos}) = do
            sym <- U.findVD name
            if sym.sid == sid then do
                changeST Global.{sub <- SubSt.{
                           idKind <- insert (KeyTk pos.first) (Right nm)}}
                stio (Right v.{name=nm}) 
            else stio (Right v)
        action x = stio (Left x)


{--
    Rename unused patterns to "_"
    
    Later, in code generation, those patterns will be ignored
    -}
rmUnusedPat :: [Int] -> Pattern -> Pattern
rmUnusedPat unused p = case p of
        PVar{pos, uid, var}
            | var == "_"        = p
            | uid `elem` unused = p.{var = "_"}
            | otherwise         = p
        PCon{pos, qname, pats}  = p.{pats <- map (rmUnusedPat unused)}
        PConFS{pos, qname, fields} -> undefined    -- TODO: complete code
        PAt{pos, uid, var, pat}
            | uid `elem` unused = rmUnusedPat unused pat
            | otherwise         = p
        PUser{pat, lazy}        = p.{pat <- rmUnusedPat unused}
        PLit{pos, kind, value}  = p
        PAnn{pat, typ}          = p.{pat <- rmUnusedPat unused}
        PMat{pos, uid, var, value}
            | uid `elem` unused = PLit{pos, kind=LRegex, value}
            | otherwise         = p
    

--- find and remove unused local definitions
unusedLet (x@Let {env,ex}) = do
        down <- references (map QName.uid env) ex
        if down == 0
            then do
                syms <- mapSt U.findV env
                g <- getST
                foreach syms (\(sym::Symbol) ->
                    unless (sym.name.base ~ ´^_´) do
                        E.hint (getrange sym) (msgdoc (
                            nicer sym g ++ " is not used anywhere."))
                    )
                stio (Left ex)
            else stio (Left x)
unusedLet x = stio (Left x)


--- lift mutual recursive let functions to the top level
unLet (x@Let {env,ex}) 
    | length env > 1 = do
        vals <- mapSt U.findV env
        g <- getST
        if (any Symbol.anno vals)
            then unLetMutual g vals x
            else return (Left x) 
  where
    unLetMutual :: Global -> [Symbol] -> Expr -> StG (Either Expr Expr)
    unLetMutual g vals (x@Let {env,ex}) = do
        freevbls <- toPass
        case freevbls of
            [] -> do
                gsyms  <- mapSt globalize vals
                foreach gsyms enter
                let vgs = zip vals gsyms
                syms   <- mapSt (mkGlobal vgs) vgs
                newlet <- foldSt replsym ex vgs
                E.logmsg TRACE7 pos (text ("changed  " ++ nice newlet g))
                foreach syms changeSym
                foreach (map Symbol.name syms) unLetName
                stio (Left newlet)
            xs -> do
                -- let part1 = msgdoc ("implementation restriction: mutual recursive local functions"
                --         ++ " that use variables bound in enclosing lexical scopes"
                --         ++ " are currently not supported.")
                --     part2 = text "functions: " <+> sep "," (map (text • flip nicer g • Symbol.name) vals)
                --     part3 = text "variables: " <+> sep "," (map (text • flip nicer g • Symbol.name) freevbls)
                --     part4 = text "There are two possible workarounds:"
                --     part5 = text "- If possible, make" <+> lit (length vals - 1) <+> text "functions local to the remaining one."
                --     part6 = text "- Pass the variables as arguments."
                -- E.error (getpos x) (part1 </> nest 4 (part2 </> part3 </> part4 </> part5 </> part6))
                stio (Left x)
      where
        pos = getpos x

        exprs :: [Expr]
        exprs = map (unJust • flip Symbol.gExpr g) vals

        freeSym :: Expr -> StG [Symbol]             -- free variables in expression
        freeSym x = do
                used  <- U.localSyms x
                inner <- innerSids   x
                let uids = filter (not • (inner `contains`)) (keys used)
                mapSt U.findV   [ Local uid "_" | uid <- uids ] 
                

        toPass :: StG [Symbol]           -- symbols we must pass to each global val
        toPass = do
            exsyms <- mapSt freeSym exprs
            stio ((uniq • sort) [ s | ss <- exsyms, s <- ss, s `notElem` vals ])

        globalize :: Symbol -> StG Symbol
        globalize sym = do
            g <- getST
            let name = U.unusedName (VName (Global.thisPack g) (sym.name.base)) g
            stio sym.{name, sid=0, expr = Nothing, vis = Private}

        replsym :: Expr -> (Symbol, Symbol) -> StG Expr
        replsym x (sym,gsym) = replName sym.sid gsym.name x


        mkGlobal :: [(Symbol, Symbol)] -> (Symbol,Symbol) -> StG Symbol
        mkGlobal vgs (sym,gsym) = do
            let ex = unJust (sym.gExpr g)
            ex <- foldSt replsym ex vgs
            -- sym <- globalize sym
            g <- getST
            E.logmsg TRACE7 pos (text ("global: " ++ gsym.name.nice g ++ " = " ++ nice ex g))
            let vks  = map Tau.varkind (U.freeTVars [] sym.typ.rho)
            let typ = ForAll vks sym.typ.rho
            changeST Global.{sub <- SubSt.{
                                idKind <- insert (KeyTk gsym.pos.first) (Right gsym.name)}}
            stio gsym.{expr = Just (return ex), typ}

        unLetName nm = do
            symv <- U.findV nm
            unLetSym symv
    unLetMutual g vals x = error "unLetMutual"

unLet (xlet@Let {env=letenv,ex=letex,typ=lettyp})
        | [x] <- letenv = do                  -- let x = ... in ex

    g <- getST
    sym <- U.findV x

    case sym.gExpr g of
        Just (Lam {pat,ex,typ}) = do           -- let x = \_ -> ... in ex
            ex    <- U.mapEx true unLet ex
            used  <- U.localSyms ex
            inner <- innerSids ex
            let thisSids = fold including inner (sym.sid:[ uid | PVar{uid} <- U.patVars pat ])  -- including x
            if sym.anno 
                && all (thisSids `contains`) (keys used)         -- ex uses only x and
                && isOff g.options.flags NOUNLET
              then do
                g <- getST
                let name = U.unusedName (VName g.thisPack x.base)  g
                ex <- replName sym.sid name ex  -- no reference to x anymore
                letex2 <- replName sym.sid name letex  -- in the inner of the lambda or the let ex
                let lamx = Lam {pat,ex,typ}
                let vks  = map Tau.varkind (U.freeTVars [] sym.typ.rho)
                let typ  = ForAll vks sym.typ.rho
                enter sym.{sid = 0, name, expr = Just (return lamx), vis = Private, typ}
                changeST Global.{sub <- SubSt.{
                                idKind <- insert (KeyTk sym.pos.first) (Right name)}}
                E.logmsg TRACE7 sym.pos (text ("let " ++ nice x g ++ " = " ++ nice lamx g ++ " in ... replaced with " ++ nice letex2 g))
                E.logmsg TRACE7 sym.pos (text ("new function is " ++ name.nice g))
                unLet letex2       -- other opportunities possible here
              else do
                changeSym sym.{expr = Just (return  Lam{pat,ex,typ})}
                letex <- U.mapEx true unLet letex
                stio (Right (Let {env=letenv,ex=letex,typ=lettyp}))
        -- a local non function stays local only if it uses other local symbols
        -- if used only once and is non recursive, it will get inlined
        Just cx = do
            g    <- getST
            ulet <- U.mapEx true unLet letex
            cx   <- U.mapEx true unLet cx
            let e = isSimple g cx
            changeSym sym.{expr = Just (return cx)}
            self <- references [sym.sid] cx
            down <- references [sym.sid] ulet
            -- E.logmsg TRACE7 sym.pos (text ("UNLET: " ++ nice x g
            --     ++ "  anno: " ++ show sym.anno
            --     ++ ", simple: " ++ show e
            --     ++ ", self: " ++ show self
            --     ++ ", down: " ++ show down))
            if !sym.anno && e && self == 0 && down == 1       -- used exactly once, note that use
                                                              -- in a local function counts twice.
                    && not sym.strsig.isStrict                -- do not inline strict names                    
            then do
                -- inline that
                let inline = if isPSigma sym.typ then cx
                                else Ann {ex = cx, typ = Just sym.typ}
                ex <- replSid sym.sid inline ulet
                E.logmsg TRACE7 sym.pos (text ("let " ++ nice x g ++ " = " ++ nice inline g ++ " in ... replaced with " ++ nice ex g))
                return (Right ex)
            --
            --  globalize annotated CAFs, if possible
            --
            else if sym.anno && isOff g.options.flags NOUNLET then do
                used  <- U.localSyms cx
                inner <- innerSids cx
                if all ((inner `including` sym.sid)  `contains`) (keys used)
                then do
                     g <- getST
                     let name = U.unusedName (VName g.thisPack x.base)  g
                     ex <- replName sym.sid name cx  -- no reference to x anymore
                     letex2 <- replName sym.sid name ulet  -- in the inner of the lambda or the let ex
                     let vks  = map Tau.varkind (U.freeTVars [] sym.typ.rho)
                     let typ  = ForAll vks sym.typ.rho
                     enter sym.{sid = 0, name, expr = Just (return ex), vis = Private, typ}
                     changeST Global.{sub <- SubSt.{
                                     idKind <- insert (KeyTk sym.pos.first) (Right name)}}
                     E.logmsg TRACE7 sym.pos (text ("let " ++ nice x g ++ " = " ++ nice cx g ++ " in ... replaced with " ++ nice letex2 g))
                     E.logmsg TRACE7 sym.pos (text ("new name is " ++ name.nice g))
                     E.hint sym.pos (text("let definition is a constant: " ++ name.nice g))
                     return (Right letex2)       -- no other opportunities possible here
                else stio (Right xlet.{ex = ulet})
            else stio (Right xlet.{ex = ulet})
        other -> stio (Left xlet)
unLet x = stio (Left x)

{--
    tell if an expression is just a literal, variable or constructor name
 -}
isAtomic Vbl {} = true
isAtomic Lit {} = true
isAtomic Con {} = true
isAtomic _      = false

--- tell if a pattern is just a simple variable 
-- private isPVar (PStrict p) = isPVar p
private isPVar (PVar{})    = true
private isPVar _           = false

--- tell if a pattern is a variable or a constant or a nullary constructors
isPVarOrPLit  PVar{} = true
isPVarOrPLit  PLit{} = true
isPVarOrPLit  PCon{pats=[]} = true
isPVarOrPLit  _             = false

{--
    @sMatch tree pat ex@ matches pattern @pat@ symbolically with expression @ex@ 
    and returns either @Nothing@ if there is no match or @Just tree@ where the
    'Tree' maps local unique numbers to expressions.
    
    The symbolic match matches 
    - /v/ with any /x/ and binds /v/ to /x/
    - /C/ with /C/
    - /Con p1 p2 ...pn/ with /Con x1 x2 xn/ if all subpatterns are literals or variables
      and match their corresponding subexpressions
      and binds the variables to the corresponding expressions.
    - /Con p1 ... pn/ with /x/ if /Con/ is a product or newtype constructor 
      and all subpatterns are variables. Nothing is bound.
    
    This is used in case elimination.
    Note that strict patterns are not matched.  
    -}
sMatch :: Pattern -> Expr -> TreeMap Int Expr -> Maybe (TreeMap Int Expr)
sMatch PVar{uid}        x               tree = Just (TreeMap.insert tree uid x)
sMatch PLit{value=pval} Lit{value=xval} tree = if xval == pval then Just tree else Nothing
sMatch PCon{qname,pats} x               tree
    | Con{name}:xs <- map fst (flatx x),
      name == qname, 
      length pats == length xs = fold collect (Just tree) (zipWith sMatch pats xs)
    where -- unStrict PUser{pat} = pat
          -- unStrict pat        = pat  
          collect (Just t) f  = f t
          collect Nothing  _  = Nothing
sMatch p x t = Nothing    

{-
closedLambda (app@App (Lam {pat,ex,typ}) b ty) = do
        g <- getST
        let pos = getpos app
        E.logmsg TRACE8 pos (text ("beta reduction on: " ++ nice app g))
        let result = Case CNormal b [CAlt {pat,ex}] ty
        E.logmsg TRACE8 pos (text ("results in: " ++ nice result g))
        closedLambda result

closedLambda (app@App a b ty) = do
        a <- U.mapEx true closedLambda a
        case a of
            Lam {} -> closedLambda (App a b ty)
            _ -> do
                b <- U.mapEx true closedLambda b
                stio (Right (App a b ty))
                -}

--- identify @\x -> glob x@ and simplify to @glob@
closedLambda Lam {pat=PVar{uid,var="in"}, ex=App a b _}
    | Vbl{name} <- a, not name.isLocal,     -- application of a global function
      Vbl{name=Local{uid=vuid}} <- b,       -- to a local variable
      uid == vuid                           -- that is the same as the pattern 
    = return (Right a)

--- identify lambdas that have no referenes to local variables bound in outer scopes    
--closedLambda (lam@Lam {pat,ex,typ = Just sigma}) = do
--        ex    <- U.mapEx true closedLambda ex   -- recurse
--        used  <- U.localSyms ex                 -- find local vars used
--        inner <- innerSids ex
--        tvs   <- TCU.sigmaTvs sigma
--        let thisSids = fold including inner  [ uid | PVar {uid} <- U.patVars pat ]
--        if all (thisSids `contains`) (keys used)
--            && (null sigma.rho.context                            -- no constraints or
--                || null (filter (not . MetaTv.isFlexi) tvs))      -- no rigid tvs!
--            then do
--                g <- getST
--                -- u <- uniqid
--                
--                let name = U.unusedName (VName g.thisPack ("anon$" ++ show (getpos ex))) g
--                    lamx = Lam {pat,ex,typ = Just sigma}
--                    sym0  = U.patLocal (getpos ex) 0 "anonymous"
--                    vks   = map Tau.varkind (U.freeTVars [] sigma.rho)
--                
--                ctxs <- TC.collectConstrs ex
--                typ  <- TCU.cleanSigma (ForAll vks sigma.rho.{context = ctxs})
--                
--                let sym   = sym0.{name, expr=Just lamx, vis=Private, state=Typechecked, typ}
--                    var   = Vbl {pos=sym.pos, name, typ = Just sigma}
--                enter sym
--                sym <- U.findV sym.name
--                TC.resolveConstraints sym
--                sym <- U.findV sym.name
--                depthSym sym
--                sym <- U.findV sym.name
--                E.logmsg TRACE8 sym.pos (text ("anonymous lambda  " ++ lamx.nice g 
--                        ++ " replaced with " ++ var.nice g
--                        ++ " :: " ++ sym.typ.nice g))
--                E.logmsg TRACE8 sym.pos (text ("context is  " 
--                        ++ U.nicerctx ctxs g))
--                stio (Right var)
--            else stio (Right lam)

closedLambda (letex@Let{env,ex}) = do       -- now we can lift harmless inner lambdas
        -- syms <- mapSt U.findV env
        ex   <- U.mapEx true closedLambda ex
        -- foreach syms closedLambdaInInnerSym
        (nenv, nex) <- foldM inner ([],ex) env
        let result = if null nenv
            then nex
            else letex.{ex=nex, env=nenv}
        when (length nenv < length env) do
            g <- getST
            E.logmsg TRACE8 (getpos letex) (
                text ("let bindings removed.")
                </> text ("before: " ++ nice letex g)
                </> text ("after:  " ++ nice result g))
        return (Right result) 
    where
        inner (env, ex) qn = do
            sym <- U.findV qn
            case sym.expr of
                Just def -> do
                    def <- def
                    constr <- TC.collectConstrs def
                    if null constr
                    then do
                        ndef <- U.mapEx true closedLambda def
                        case ndef of
                            Vbl{name} -> do
                                nex <- replName sym.sid name ex
                                return (env, nex)
                            sonst -> do
                                changeSym sym.{expr = Just (return ndef)}
                                return (qn:env, ex)
                    else return (qn:env, ex)
                sonst -> return (qn:env, ex) 
        
closedLambda x = stio (Left x)

{- ############################### strictness analysis ########################## -}
{--
 * [usage] @lambdaStrictess x@
 * [returns] a list of 'Strictness' items derived from patterns of the lambda in @x@
 *           or the empty list if @x@ is not a lambda
 * [see]     'patternStrictness'
 -}
lambdaStrictness (x@Lam {pat,ex}) = do
        sx <- lambdaStrictness ex
        sp <- patternStrictness pat
        stio (sp:sx)
lambdaStrictness x = stio []        -- not a lambda

{--
 * [usage] @patternStrictness pat@
 * [returns] the 'Strictness' value for the 'Pattern' @pat@
 * [requires] The environment where the pattern bound variables are held must be active.
 * [see] 'productCon'
 *
 * A pattern is /strict/, if it is /refutable/ or if it contains strict variables.
 * A pattern is /refutable/ if the match can possibly fail. Variables and product constructor
 * applications that contain only irrefutable patterns are irrefutable.
 -}
patternStrictness p = case p of
        PVar {uid,var} -> do
            v <- U.findV (Local uid var)
            stio v.strsig
        PAt {pos,uid,var,pat} -> do
            ps <- patternStrictness pat
            if ps == U then patternStrictness (PVar {pos,uid,var}) else stio ps
        PUser {pat, lazy} -> do
            ps <- patternStrictness pat
            if lazy then stio U
            else if ps == U then stio (S[]) else stio ps
        PLit {pos} -> stio (S[])
        PMat {pos} -> stio (S[])
        PAnn {pat} -> patternStrictness pat
        PCon {pos,qname,pats} = do
                g <- getST
                if not (productCon qname g) then stio (S[])
                  else do
                    ps <- mapSt patternStrictness pats
                    -- if all (U==) ps then stio U else stio (S ps)
                    return (S ps)
        PConFS {pos} -> E.fatal pos (text ("patternStrictness: found PConFS")) -- not allowed anymore at this time

{--
 * [usage] @patternRefutable g pat@
 * [returns] *true* if the pattern is refutable, *false* otherwise
 -}
patternRefutable g p = case p of
    PVar {var}      -> false
    PLit {pos}      -> true
    PMat {pos}      -> true
    PCon {pos,pats} -> not (productCon p.qname g) || any (patternRefutable g) pats
    _ | p.{pat?}    -> patternRefutable g p.pat
      | otherwise   -> false

{--
    1. usage: @elimPattern p@
    2. returns: *true* if the pattern supports _case elimination_.
    
    This is the case if the pattern is a variable or a constructor applied only to variables.
    -}
elimPattern (PVar {var}) = true
elimPattern (PCon {pats}) = all isPVar pats
elimPattern _ = false 

{--
 * [usage] @productCon name g@
 * [returns] *@true@* if @name@ names a constructor of a product type in @g@,
 *           *@false@* if it is the name of a sum type
 * [requires] @name@ must name a member of a data type in @g@
 -}
productCon (MName tname _) g = case g.findit tname of
        Just (SymT {product}) -> product
        other -> error ("productCon " ++ tname.nice g ++ " is not a type")
productCon _ _ = false

{--
    @newtypeCon qname g@ returns true if, and only if @qname@ is the name
    of the constructor for a _newtype_, i.e. a product type with a single
    constructor of arity 1.
 -}
newtypeCon (qname@MName tname _) g = case g.findit qname of
    Just SymD{} -> case g.findit tname of
        Just (SymT {newt}) -> newt
        other -> error ("newtypeCon " ++ tname.nice g ++ " is not a type")
    sonst -> false
newtypeCon _ _ = false


{--
 * check a name for strictness, sids are already being checked
 -}
strictName sids nm = do
    g <- getST
    v <- U.findV nm
    when (v.state != StrictChecked) do
        E.logmsg TRACES v.pos (text ("strictness analysis for " ++ v.nice g))
    let ari = U.arity v             -- ... based on type
    case v of
        SymV {state = StrictChecked} = stio []          -- do nothing
        SymV {nativ = Just _} -> do
            let strsig = S (take ari allStrict)
            E.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show strsig))
            changeSym v.{strsig, state = StrictChecked}
            stio []
        SymV {} | Just (x@Lam{ex}) <- v.gExpr g -> do
            (x, syms) <- strictness (v.sid:sids) x
            s <- lambdaStrictness x     -- collect strictness from patterns
            E.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show (S s)
                                    ++ " ignoring "
                                    ++ joined ", " (map (flip nice g • Symbol.name) syms)))
            changeSym v.{expr = Just (return x), strsig = S s, state = StrictChecked}
            stio syms
        SymV {expr = Just x} | ari > 0 = do
                y <- x >>= eta ari 
                (y, syms) <- strictness (v.sid:sids) y
                s <- lambdaStrictness y
                let x  = uneta ari y
                    rs = if null s then v.strsig else S s
                E.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show rs))
                changeSym v.{expr = Just (return x), strsig = rs, state = StrictChecked}
                stio syms
            where
                eta 0 x = stio x
                eta n x = do
                    let pos = getpos x
                    nums <- sequence (take n (repeat uniqid))
                    syms <- mapSt U.mkLocal  [ PVar{pos=pos,uid,var="$"} | uid <- nums ]
                    let vars = map Symbol.name syms
                        mkapp ex n = nApp ex (Vbl {pos, name=n, typ = Nothing})
                        -- mklam :: Expr -> Int -> Expr
                        mklam ex sym = Lam {pat,ex,typ=Nothing}
                            where pat = PVar {pos, uid=Symbol.sid sym, var="$"}
                                  -- env = insert Nil pat.var (U.patLocal pos pat.var).{sid=n}
                        -- \a\b -> x a b
                        body = fold mkapp    x vars
                        lam  = fold mklam body (reverse syms)
                    stio lam
                uneta n x = unapp n • unlam n $ x
                    where unlam 0 x = x
                          unlam n (Lam {ex}) = unlam (n-1) ex
                          unlam _ _ = error "unlam: no Lam"
                          unapp 0 x = x
                          unapp n (App a b _) = unapp (n-1) a
                          unapp _ _ = error "unapp: no App"

        SymV {state} -> do              -- pointless style or just var
            let strsig = if ari == 0 then v.strsig else S (take ari allLazy)
            E.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show strsig))
            changeSym v.{strsig, state = StrictChecked}
            stio []
        other -> E.fatal other.pos (text ("strictness: strange symbol  " ++ other.nice g))


{--
 * - _usage_ @strictness sids x@
 * - _returns_ a possibly modified expression and a list of local symbols that appear strict
 *           under the assumption that @x@ itself is strict
 * - _requires_ environment must be set up correctly and the list @sids@ contains the
 *            symbol numbers of all named functions that are recursively checked to
 *            avoid infinite recursion
 *
 * Strictness rules for various expressions:
 * 1. if @\p -> x@ is strict then @x@ is strict
 * 2. if @case x of alt1;...@ is strict, then @x@ is strict if the pattern in the first
 *    case alternative is strict. Non immediate local
 *    names from subexpressions are strict only when they appear strict in all alternatives.
 * 3. if local variable @v@ is strict, then @v@ is strict
 * 4. if application @f a b c@ is strict, and @f@ is a variable, @f@ is strict
 * 5. if application @g x y@ is strict, and g has a strictness signature, then
 *      the arguments are strict if the signatur at the corresponding position is.
 *      Otherwise, if @g@ is checked recursively, assume all arguments as strict.
 *      If @g@ is encountered the first time, look at @g@'s lambda and use
 *      the lambda strictness for the arguments
 * 6. if g is checked recursively, all arguments are strict
 -}
strictness :: [Int] -> Expr -> StG (Expr, [Symbol])
strictness sids x = do
        g <- getST
        E.logmsg TRACES (getpos x) (text ("strictness for: " ++ nice x g))
        let mine = if x.{env?} then map QName.uid x.env
                    else if x.{pat?} then map Pattern.uid (U.patVars x.pat) 
                    else []
            my   = filter ((`elem`    mine) • Symbol.sid)
            them = filter ((`notElem` mine) • Symbol.sid)
        case x of
            Vbl {name=Local{}} -> do
                    v <- U.findV x.name
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g [v]))
                    stio (x, [v])
            Vbl {name} -> do
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g []))
                    stio (x, [])
            Con {name} ->  do
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g []))
                    stio (x, [])
            Ifte c a b t -> do
                    (c, sc) <- strictness sids c
                    (a, sa) <- strictness sids a
                    (b, sb) <- strictness sids b
                    let syms = sc `uni` (sa `inter` sb)
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g syms))
                    stio (Ifte c a b t, syms)
            Let {env,ex} -> do
                    -- let ve = values env
                    results <- mapSt (strictName sids) 
                                  (filter ((`notElem` sids) • QName.uid) env)
                    (ex, syms) <- strictness sids ex
                    let strictSyms = my syms
                        sSsids = map Symbol.sid strictSyms
                        upper = [ sres  | (loc, sres) <- zip env results,
                                        QName.uid loc `elem` sSsids ]
                        result = fold uni (them syms) upper
                    foreach strictSyms mark
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g result))
                    stio (x.{ex}, result)
            Lit {pos} ->  do
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g []))
                    stio (x, [])
            App _ _ _ -> do
                    (fx, syms) <- appstr (flatx x)
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g syms))
                    stio (U.unflatx fx, syms)
            Lam {ex, pat} -> do
                    (ex, syms) <- strictness sids ex
                    foreach (my syms) mark
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g (them syms)))
                    refs <- mapSt (\sid -> references [sid] ex) mine
                    let unused = [ sid | (sid, 0) <- zip mine refs ]
                        upat = rmUnusedPat unused pat
                    stio (x.{ex, pat=upat}, them syms)
            Case {ex,alts} -> do
                    s0 <- patternStrictness (head alts).pat
                    E.logmsg TRACES (getpos x) (text ("first pattern is at least " ++ show s0))
                    altsyms <- mapSt strictAlt alts
                    let alts = map fst altsyms
                        syms = foldl1 inter (map snd altsyms)
                    -- extract S[...] of patterns
                    s1 <- do patternStrictness (head alts).pat
                    E.logmsg TRACES (getpos x) (text ("first pattern is in fact  " ++ show s1))
                    sx <- foldSt unisa s1 (tail alts)
                    E.logmsg TRACES (getpos x) (text ("all patterns together are " ++ show sx))
                    let ss = maxss s0 sx
                    E.logmsg TRACES (getpos x) (text ("combined with minimum     " ++ show ss))
                    (ex, xsyms) <- apply ex ss         -- take advantage of S[.....] if possible
                    E.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g (uni syms xsyms)))
                    stio (x.{ex, alts}, uni syms xsyms)
            Ann {ex} -> do
                    (ex,syms) <- strictness sids ex
                    stio (x.{ex}, syms)
            _ -> do
                E.fatal (getpos x) (text ("no strictness rule, turn on -xs -xr " ++ show (getpos x)))
                stio (x, [])
    where
        names g = show • map (flip QName.nice g • Symbol.name)
        inter as = filter (\b -> elemBy (using Symbol.sid) b as)
        uni :: [Symbol] -> [Symbol] -> [Symbol]
        uni as bs = as ++ [ b | b <- bs, not (elemBy (using Symbol.sid) b as)]
        maxss (S s1) (S s2) = S (zipWith maxss s1 s2)
        maxss U s = s
        maxss s U = s
        unisa :: Strictness -> CAlt -> StG Strictness
        unisa sleft alt = do
            sright <- patternStrictness alt.pat
            stio (uniss sleft sright)
          where
            uniss (S s1) (S s2) = S (zipWith uniss s1 s2)
            uniss U _ = U
            uniss _ U = U


        -- mark a symbol as strict
        mark sym = do
            g <- getST
            E.logmsg TRACES (Symbol.pos sym) (text (nice sym.name g ++ " marked as strict"))
            when (sym.strsig == U) do changeSym sym.{strsig = S[]}
        -- strictness for case alternative, same as in lambda
        strictAlt (alt@CAlt {pat,ex}) = do
                (lam, syms) <- strictness sids (Lam {pat,ex,typ=Nothing})
                stio (alt.{ex=lam.ex}, syms)
        subapp (a,b)   = apply a b
        apply ex U     = do
                            (x,_) <- strictness sids ex
                            stio (x, [])      -- lazy
        apply ex (S[]) = strictness sids ex -- strict
        apply ex (S ss) = do
            g <- getST
            case flatx ex of
                fex@((Con {name},_):xs) | productCon name g, length ss == length xs = do
                        E.logmsg TRACES (getpos ex) (text ("apply " ++ show (S ss)
                                                        ++ " to " ++ nice ex g))

                        exsyms <- mapSt (\(a,b) -> apply a b) (zip (map fst xs) ss)
                        let exs = map fst exsyms
                            syms = foldl1 uni (map snd exsyms)
                            flat = head fex : zip exs (map snd xs)
                        E.logmsg TRACES (getpos ex) (text ("apply found: " ++ names g syms))
                        stio (U.unflatx flat, syms)
                _ -> strictness sids ex
        convar (Con {name}) = true
        convar (Vbl {name}) = true
        convar _ = false
        appstr (app@((f,mbt):as)) | not (convar f) = do
            (f,syms) <- strictness sids f
            fas <- mapSt (strictness sids) (map fst as)
            let nas = zip (map fst fas) (map snd as)
            stio ((f,mbt):nas, syms)
        appstr (app@((f,mbt):as)) = do
            g <- getST
            v <- case f of
                    Con {name} -> U.findD name
                    Vbl {name} -> U.findV name
                    _ -> E.fatal (getpos f) (text ("Can't handle " ++ nice f g ++ "  applications"))
            let fsym | Local {} <- v.name = [v]
                     | otherwise = []
                mkAll = do
                    fapp <- mapSt (strictness sids) (map fst app)
                    let napp = zip (map fst fapp) (map snd app)
                    stio (napp, fsym)
            case v of
                SymV {state = Typechecked, expr = Nothing} = mkAll
                SymV {state = Typechecked, expr = Just _}
                    | Just (Lam{}) <- v.gExpr g = if v.sid `elem` sids
                        then do
                            -- assume all are strict
                            asx <- mapSt (strictness sids) (map fst as)
                            stio ((f,mbt):zip (map fst asx) (map snd as), fold uni fsym (map snd asx))
                        else do
                            strictName sids v.name
                            appstr app              -- repeat
                SymV {state = Typechecked, expr = Just dx}
                    | v.sid `notElem` sids = do
                            -- inline pointless
                            x <- dx
                            let fx = flatx x
                            (fxas, syms) <- appstr (fx ++ as)
                            let as = drop (length fx) fxas
                            stio ((f,mbt):as, fsym ++ syms)
                    | otherwise = mkAll
                SymD {strsig = U} -> mkAll
                SymD {strsig = S ss} -> do
                        let xss = take (length as) (ss ++ repeat U)     -- make sure enough
                        exsyms <- mapSt subapp (zip (map fst as) xss)
                        stio ((f,mbt):zip (map fst exsyms) (map snd as), fold uni fsym (map snd exsyms))
                SymV {state = StrictChecked, strsig = U} -> mkAll
                SymV {state = StrictChecked, strsig = S ss} -> do
                        let xss = take (length as) (ss ++ repeat U)     -- make sure enough
                        E.logmsg TRACES (getpos f) (text ("appstr: xss=" ++ show xss ++ " for " ++ v.name.nice g))
                        exsyms <- mapSt subapp (zip (map fst as) xss)
                        stio ((f,mbt):zip (map fst exsyms) (map snd as), fold uni fsym (map snd exsyms))
                SymV {sid} -> do
                    E.fatal (v.pos) (text ("appstr: unexpected symbol " ++ nice v g
                        ++ ", state=" ++ show v.state
                        ++ ", expr="  ++ show (isJust v.expr)))
                _ -> error "appstr: no appropriate sym"
        appstr _ = error "appstr: []"


{--
    > caseComplete g (Case ...)
    
    Check if a normal @case@ statement covers all cases.
    This is true if the patterns of the alternatives that 
    have no 'openCaseWhen' expression are complete.
    
    If this is itself a 'CWhen' @case@, the result is the same as
    for 'openCaseWhen'.
 
-}
caseComplete g x
    | Case{ckind, ex, alts, typ} <- x = case ckind of
        CWhen -> openCaseWhen g x
        _ -> case partitioned (isNothing . openCaseWhen g . CAlt.ex) alts of
                            -- use of head justified because there are no case
                            -- statements without alternatives
            ([], oalts) -> openCaseWhen g . CAlt.ex . head $ oalts
            (ralts, _)  -> maybe Nothing (Just . Right) (patsComplete g (map CAlt.pat ralts))
    | otherwise = Nothing   -- not a case?  
         
{--
 * [usage] @patsComplete g [pat, ...]@
 * [return] @Just p@ where @p@ is a pattern that is missing in the set or @Nothing@
 *      if the set of patterns is /complete/.
 * [required] the list of patterns must not be empty
 *
 *
 * A set of patterns is complete if it contains at least one irrefutable pattern
 * or if all possible literals / constructors are listed and for every constructor
 * the set of the subpatterns is complete.
 -}
patsComplete g [] = Just (PVar {pos=Position.null, uid=0, var = "unguarded"})  -- if all case alts carry open case when
patsComplete g ps
    -- Prelude.traceLn ("patsComplete [" ++ joined "," (map (flip nice g) ps) ++ "]") = undefined
    -- Prelude.traceLn ("patsComplete [" ++ joined "," (map (show • not • patternRefutable g) ps) ++ "]") = undefined
    | any (not • patternRefutable g) ps = Nothing
    | otherwise                         = missing canonicPats
    where
        -- refutables  = filter (patternRefutable g) canonicPats
        canonicPats = map canonic ps
        -- only PCon, PLit and PVar are considered
        canonic (PMat {pos, value}) = PLit {pos, kind = LRegex, value}
        canonic (p@PCon {pos}) = p.{pats <- map canonic}
        canonic p | p.{pat?}   = canonic p.pat
        canonic p              = p
        pany                   = PVar {pos=Position.null, uid=0, var = "_"}
        -- compute the missing element from a list of refutable patterns
        missingLiteral [] = Just pany
        missingLiteral ls | any regex ls = Just (PLit {pos=Position.null, kind=LString,
                                            value="\"any string not matched by regular expression\""})
            where regex (PLit {kind = LRegex}) = true
                  regex _                      = false
        missingLiteral (ps@PLit {pos, kind}:_) = Just (PLit {pos, kind, value})
            where value = (head • filter (`notElem` (map Pattern.value ps))) (lany kind)
                  lany LBool = ["true", "false", "blödsinn"]
                  lany LString = allBinders g
                  lany LChar   = map show (iterate Char.succ '!')
                  lany LInt    = map show (iterate Int.succ 42)
                  lany LLong   = map show (iterate Long.succ 42L)
                  lany LBig    = map show (iterate Integer.succ 42n)
                  lany LDouble = map show (iterate (0.42*)  3.14159)
                  lany LFloat  = map show (iterate (0.42f*) 3.14159f)
                  lany LRegex  = allBinders g
        missingLiteral _ = Just pany
        -- compute the missing element from a list of refutable patterns
        missing [] = Just pany                              -- _
        missing (ps@(PLit {kind=LBool}:_)) = case map Pattern.value ps of
            tfs -> if all (`elem` tfs) ["true", "false"]
                then Nothing
                else missingLiteral ps
        missing (ps@(PLit {pos}:_))   = missingLiteral ps
        missing (ps@(PCon {qname}:_))
            | s:_ <- filter (not • (`elem` pnames) • Symbol.name) (cons qname) = Just (mkCon s)
            | otherwise = case (filter isJust • map groupcheck) (group ps) of
                some:_ -> some
                []  -> Nothing
            where
                pnames = map Pattern.qname ps
                cons (MName tname _) = case Global.findit g tname of
                    Just (SymT {env}) -> U.envConstructors env
                    _ -> []
                cons _ = []
                mkCon (SymD {name,flds}) = PCon {pos=Position.null, qname=name,
                                                    pats = map (const pany) flds}
                mkCon _ = error "mkCon: no constructor"
                group :: [Pattern] -> [(QName, [[Pattern]])]
                group [] = []
                group (PCon {qname,pats}:ps) = (qname, pats:map Pattern.pats same):group other
                    where
                        same  = filter ((`==` qname) • Pattern.qname) ps
                        other = filter ((`!=` qname) • Pattern.qname) ps
                group _ = error "group: no PCon"
        missing _ = error "missing: bad patterns"
        -- check a group of patterns (QName, [[p11, p12, p13], [p21, p22, p23], ...])
        groupcheck (qname, [])    = Just pany                   -- cannot happen
        groupcheck (qname, []:_)  = Nothing                     -- nullary constructor
        groupcheck (qname, patss) = anongroup (PCon Position.null qname) patss
        -- [true, 2, c1]
        -- [false, b2, 3]
        -- [_, 1, _]            // irefs
        anongroup recon grp
            | length (head grp) == 1 = result (patsComplete g col1)     -- base case
            | all (not • patternRefutable g) col1 = -- the first column has only irrefutables
                anongroup (\ps -> recon (pany:ps)) cols
            | all (patternRefutable g) col1 = anonRgrp recon grp
            | Nothing <- anongroup recon irefs = Nothing
            | Nothing <- anonRgrp recon refs = Nothing
            -- there are some patterns with refutable heads and some with irrefutable ones
            | otherwise = anonRgrp  recon (refs ++ nrefs)
            where
                col1 = map head grp
                cols = map tail grp
                result Nothing = Nothing
                result (Just p) = Just (recon (p : map (const pany) (head cols)))
                (refs, irefs) = partitioned (patternRefutable g • head) grp
                nrefs = [ p:rest | _:rest <- irefs, p <- cons ]
                cons = constructors (head (head refs))
                -- constructors :: Pattern -> ([Pattern] ->
                constructors (lit@PLit {kind=LBool}) = [ lit.{value=s} | s <- ["true", "false"] ]
                constructors (con@PCon {qname=MName tname _}) = case g.findit tname  of
                    Just (SymT {env}) ->
                        [ PCon con.pos sym.name (take (length sym.flds) dummies) |
                            (sym::Symbol) <- U.envConstructors env ] where
                                dummies = repeat (PVar con.pos 0 "_")
                    _ -> []
                constructors _ = []
                -- [[Just 1, a1, a2]         // refs
                --  [Just x, b1, b2]]
                -- [[Nothing, c1, c2]]            // irefs
                -- transform this to  [[1, a1, a2], [x, b1, b2]]  and [[c1,c2]]
                -- then check each as anon group
                anonRgrp recon grp
                    | Just x <- patsComplete g col1 = Just (recon (x : map (const pany) (head cols)))
                    | otherwise = loop groups
                    where
                        constructor (PCon {qname}) = qname
                        constructor (PLit {value}) = Local 0 value
                        constructor _ = error "constructor: ?"
                        subpats (PCon {pats}) = pats
                        subpats _             = []
                        recreate (PCon {pos, qname}) = PCon pos qname
                        recreate x                   = const x
                        groups = group grp
                        group :: [[Pattern]] -> [[[Pattern]]]
                        group [] = []
                        group ps = pss1 : group xs where
                          p1c = constructor (head (head ps))
                          (pss1, xs) = partitioned samecon ps
                          samecon p = constructor (head p) == p1c
                        col1 = map head grp
                        cols = map tail grp
                        loop [] = Nothing           -- complete!
                        loop (grp:grps) = case anongroup (f rest.length) ung of
                                Nothing -> loop grps
                                other   -> other
                            where
                                rec  = recreate (head (head grp))
                                rest = subpats  (head (head grp))
                                ung  = map uncon grp
                                uncon (p:ps) = subpats p ++ ps
                                uncon [] = undefined
                                f n xs = recon (rec (take n xs) : drop n xs)

{--
 * checks whether an expression is a case expression made from a guard (CWhen)
 * that has no trailing otherwise or irrefutable pattern match
 * If so, returns the expression or pattern that could cause the CaseWhen to fall through
 -}
openCaseWhen :: Global -> Expr -> Maybe (Either Expr Pattern)
openCaseWhen g (Case CWhen _ [alt1, alt2] _) = openCaseWhen g alt2.ex
openCaseWhen g (e@Case CWhen x [alt1] _)
    |  caseOtherwise g e              = Nothing           -- can't fall through
    |  isPTrue alt1.pat, !(isXTrue x) = Just (Left x)
    |  patternRefutable g alt1.pat    = Just (Right alt1.pat)
    |  otherwise = openCaseWhen g alt1.ex
openCaseWhen g (Let {ex}) = openCaseWhen g ex
openCaseWhen _ _ = Nothing

{--
 * tells if this is the pattern "true"
 -}
isPTrue (PLit {kind=LBool, value="true"}) = true
isPTrue p | p.{pat?} = isPTrue p.pat
isPTrue _ = false

{--
 * tells if this is the constant "true"
 -}
isXTrue (Lit {kind=LBool, value="true"}) = true
isXTrue (Vbl {name = VName p "otherwise"}) | pPreludeBase == p = true
isXTrue _ = false

{--
 * tells us if this is the "otherwise" case
 *  > case true of true -> notopencase
 -}
caseOtherwise g (Case CWhen x [alt] _)
    | isCaseWhen alt.ex = false
    | isXTrue x && isPTrue alt.pat = true
    | otherwise = !(patternRefutable g alt.pat)
caseOtherwise _ _ = false
    
--- true iff the expression is a guard case
isCaseWhen (Case CWhen _ _ _) = true
isCaseWhen _ = false

