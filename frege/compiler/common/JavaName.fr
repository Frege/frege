--- Find the java name of a frege item
module frege.compiler.common.JavaName where 
        -- generated by Splitter
import  frege.Prelude  hiding(error, print, println, break, <+>)
import  frege.data.TreeMap  as  TM(TreeMap, lookup, each, insert, union, including, contains, keys, values, fromKeys)
-- import  frege.compiler.enums.Flags
import  frege.compiler.types.JNames
import  frege.compiler.types.Packs
import  frege.compiler.types.QNames
import  frege.compiler.types.Symbols
import  frege.compiler.types.Global  as  G
import  frege.compiler.classes.Nice(Nice)
import  frege.compiler.common.Mangle

{--
 * [usage] @javaName g qname@
 * [return] a java identifier for the corresponding java object, if there is one
 * [requires] the named item must be in scope
 -}
javaName :: Global -> QName -> JName
javaName g (Local uid s) = JName "" (mangled s ++ "$" ++ show uid)
javaName g qname = case g.findit qname of
        Just sym -> symJavaName g sym
        Nothing -> Prelude.error ("javaName: cannot findit " ++ nice qname g)


{--
    > symJavaName g sym
    Returns a 'JName' for the java thing corresponding to sym, if there is one.

    For 'SymV', it is guaranteed that the name is of the form (JName pack base) 
-}
symJavaName g SymV{name=Local uid s} = JName "" (mangled s ++ "$" ++ show uid)
symJavaName g sym = case sym of
            SymT {name} -> t "T" name
            SymD {name = MName tname base} -> case g.findit tname of
                Just (SymT {product,enum}) -> if enum
                    then memberOf (t "T" tname) (mangled base)
                    else if product
                        then t "T" tname
                        else memberOf (t "T" tname) ("D" ++ mangled base)
                fail -> Prelude.error "javaName: tname is no SymT"
            SymC {name} -> t "C" name
            SymI {name} -> t "I" name
            SymV {name = MName tname base} = case g.findit tname of
                    Just (SymT {product=false,enum=false,newt=false,nativ=Nothing})
                                      = memberOf tjname mbase
                    Just (SymC {sid}) = memberOf (memberOf tjname "I") mbase
                    other             = memberOf tjname mbase
                where tjname = javaName g tname
                      mbase  = mangled sym.name.base
            SymV {name = VName pname base}
                | pname == g.thisPack   = JName jpack.base vbase
                | hasJavaImport pname g = JName jpack.base vbase
                | otherwise = memberOf jpack vbase
                where 
                    vbase = mangled sym.name.base
                    jpack = g.packClass pname
            other -> Prelude.error ("javaName: strange symbol " ++ nice sym g)
    where
        -- vid name = mangled name
        t letter (TName pack base)
            | pack == g.thisPack   = JName    ""                   (letter ++ mangled base)
            | hasJavaImport pack g = JName    (g.packClass pack).base (letter ++ mangled base)
            | otherwise            = memberOf (g.packClass pack)   (letter ++ mangled base)
        t _ _ = Prelude.error "t: need a TName"


{-- 
    By convention, if the classname base of some package is unique among
    all known packages, an import statement will be generated so that we can
    use the package base name unqualified.

    This is to avoid even more clutter in java code.
    -}
hasJavaImport :: Pack -> Global -> Bool    
hasJavaImport p g = case g.gen.jimport.lookup ((g.packClass p).base) of
    Just imported -> imported == p
    otherwise     -> false


