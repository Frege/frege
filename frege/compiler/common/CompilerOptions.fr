--- Option parsing and initial 'Global' values
module frege.compiler.common.CompilerOptions where 
        -- generated by Splitter
import  frege.Version
import  frege.java.IO()
import  frege.data.TreeMap(Tree)
import  frege.data.Bits
import  frege.compiler.enums.Flags
import  frege.compiler.types.Positions
import  frege.compiler.types.Packs
import  frege.compiler.types.External(KindA, defEA)
import  frege.compiler.types.Global  as  G
import  frege.compiler.Utilities  as  U()

--- the standard options with filename
public stdOptions = Options {
      source = "-",             -- read from standard input
      sourcePath = ["."],
      flags = fold setFlag Flags.empty [WARNINGS, WITHCP, RUNJAVAC],     -- obviously
      dir = ".",                -- work in current directory
      path = [],                -- same as java classpath
      prefix = "",              -- no prefix
      encoding = Just "UTF-8",  -- use UTF8 by default
      tRanges = []
    }


private ideOptions = stdOptions.{flags = 
            Flags.fromList [WARNINGS, HINTS, IDEMODE, IDETOKENS]}


printHelp = do
    mapM_ stderr.println [
            "usage:",
            "    java frege.compiler.Main [flags] [items ....]",
            "    java frege.compiler.Main -help           print this message",
            "    java frege.compiler.Main -version        print version information",
            "",
            "    JVM properties:",
            "        \"-Dfrege.javac=javac -J-Xmx512m\"   java compiler and options, default internal",
            "        \"-Dfrege.prelude=other.Prelude\"    package name of Prelude, default frege.Prelude",
        ]
    usage
    IO.return 0


printVersion = println version >> return 0


eclipseOptions = do
    g <- standardGlobal
    return g.{options = ideOptions}


--- an initial Gen data structure
initialGen = Gen {
                printer = IO.stdout,
                tunique = 0,
                runique = 0,
                sunique = 0,
                xunique = 1,
                kunique = 1,
                tTree = Tree.empty,
                rTree = Tree.empty,
                sTree = Tree.empty,
                xTree = Tree.empty .insert defEA 0,        -- so that 0 never indexes valid expression
                kTree = Tree.empty .insert (KindA {kind=0, suba=0, subb=0}) 0, -- kind0 = *
                expSym = Tree.empty,
                consts = Tree.empty,
                lambdas = Tree.empty,
                syminfo = Tree.empty,
                jimport = Tree.empty,
            }

--- Starting point when working with 'StG' or 'StIO' actions.
standardGlobal = do
    cache    <- Ref.new Tree.empty      -- start out with empty cache
    loader   <- U.theClassLoader stdOptions

    return Global {
            options = stdOptions,
            sub = Sub {
                cache, loader,
                optab = Tree.empty,
                toks = arrayFromList [],
                idKind = Tree.empty,
                definitions = [],
                sourcedefs  = [],
                packageDoc = Nothing,
                thisPos  = Position.null,
                nsPos = Tree.empty,
                packWhy = Tree.empty,
                nsUsed = Tree.empty,
                thisPack = Pack.new "",
                numErrors  = 0, resErrors = 0,
                messages = [],
                cancelled = return false,
                nextPass = 1,
                stderr = IO.stderr,
                toExport = [],
                funPointers = empty,
            },
            gen = initialGen,
            unique = 1,
            packages = Tree.empty,
            namespaces = Tree.empty,
            genEnv = [],
            javaEnv = Tree.empty,
            locals = Tree.empty,
            typEnv = [],
            tySubst = Tree.empty,
        }


--- print usage information common to many tools
usage = mapM_ stderr.println [
            "    flags:",
            "       -d directory    target directory for *.java and *.class files",
            "       -fp classpath   where to find imported frege packages",
            "       -enc charset    charset for source code files, standard is UTF-8",
            "       -enc DEFAULT    platform default charset for source code files",
            "       -nocp           exclude java classpath from -fp",
            "       -hints          print more detailed error messages and warnings",
            "       -inline         inline functions where possible",
            "       -comments       generate commented code",
            "       -strict         enable strict(er) semantics (eperimental)",
            "       -explain i[-j]  print some debugging output from type checker",
            "                       regarding line(s) i (to j). May help to understand",
            "                       inexplicable type errors better.",
            "       -nowarn         don't print warnings (not recommended)",
            "       -v              verbose mode on",
            "       -make           build outdated or missing imports",
            "       -sp srcpath     look for source files in srcpath, default is .",
            "       -j              do not run the java compiler",
            "       -prefix stage   prefix for package names, used in compiler development",
            "       -xN             debugging output from pass N, where N elem [1..9]",
            "       -xt             debugging output from type checker",
            "       -xo             debugging output from optimizer",
            "       -xs             debugging output from strictness analysis",
            "       -xg             debugging output from code generation",
            "       -xr i[-j]       confine tracing to range of line numbers or just a line",
            "                       multiple ranges can be specified",
            "",
            "A classpath is a list of jar files, zip-Files or directories separated by "
            ++ U.pathSep,
            "A srcpath is a list of directories separated by "
            ++ U.pathSep,
            "To get parser debugging output, set YYDEBUG environment variable to 1",
        ]


--- used to look up flag values
flagtree = Tree.fromList [
    ("-nocp",   (BitSet.`differenceE` WITHCP)),
    ("-j",      (BitSet.`differenceE` RUNJAVAC)),
    ("-nowarn", (BitSet.`differenceE` WARNINGS)),
    ("-lazy",   (BitSet.`differenceE` STRICT)),
    ("-hints",  (BitSet.`unionE` HINTS)),
    ("-make",   (BitSet.`unionE` MAKE)),
    ("-inline",     (BitSet.`unionE` INLINE)),
    ("-O",          (BitSet.union (BitSet.fromList [OPTIMIZE, INLINE]))),
    ("-strict",     (BitSet.`unionE` STRICT)),
    ("-comments",   (BitSet.`unionE` COMMENTS)),
    ("-propertc",   (BitSet.`unionE` PROPERTC)),
    ("-v",          (BitSet.`unionE` VERBOSE)),
    ("-x1",         (BitSet.`unionE` TRACE1)),
    ("-x2",         (BitSet.`unionE` TRACE2)),
    ("-x3",         (BitSet.`unionE` TRACE3)),           -- symbol table operations
    ("-x4",         (BitSet.`unionE` TRACE4)),
    ("-x5",         (BitSet.`unionE` TRACE5)),
    ("-x6",         (BitSet.`unionE` TRACE6)),
    ("-x7",         (BitSet.`unionE` TRACE7)),
    ("-x8",         (BitSet.`unionE` TRACE8)),
    ("-x9",         (BitSet.`unionE` TRACE9)),
    ("-xt",         (BitSet.`unionE` TRACET)),           -- type checker
    ("-xx",         (BitSet.`unionE` TRACEX)),           -- env operations, lots of output
    ("-xm",         (BitSet.`unionE` TRACEM)),           -- make operations
    ("-xk",         (BitSet.`unionE` TRACEK)),           -- kind inference
    ("-xo",         (BitSet.`unionE` TRACEO)),           -- optimizer
    ("-xs",         (BitSet.`unionE` TRACES)),           -- strictness
    ("-xg",         (BitSet.`unionE` TRACEG)),           -- code generator
    ("-xz",         (BitSet.`unionE` TRACEZ)),           -- on demand, for mysterious things
    ]

--- Scan command line using 'stdOptions' as base.
--- This returns either
--- > Nothing
--- when something is not in order, in this case an appropriate message has already been printed.
--- Or it returns:
--- > Just (options, fileargs)
--- where @options@ goes in the 'Global.options' field, and @fileargs@ are the file arguments.
getOpts = scanOpts stdOptions  

--- scan command line with some sanity checks, return indication of success
scanOpts :: Options -> [String] -> IO (Maybe (Options, [String]))
scanOpts opts [] = IO.return (Just (opts, []))
scanOpts opts ("-d":xs)  | null xs || head xs ~ ´^-´ = do
    IO.stderr.println "option -d must be followed by a directory name."
    IO.return Nothing
scanOpts opts ("-d":dir:args) = do
    f     <- File.new dir
    isdir <- f.isDirectory
    if isdir then do
            canRead <- f.canRead
            if canRead then do
                    canWrite <- f.canWrite
                    if canWrite then scanOpts opts.{dir} args
                        else do
                            IO.stderr.println ("directory " ++ dir ++ " is not writable.")
                            IO.return Nothing
                else do
                    IO.stderr.println ("directory " ++ dir ++ " is not readable.")
                    IO.return Nothing
        else do
            IO.stderr.println (dir ++ " is not a directory.")
            IO.return Nothing
scanOpts opts ("-sp":xs) | null xs || head xs ~ ´^-´ = do
    IO.stderr.println "option -sp must be followed by source path."
    IO.return Nothing
scanOpts opts ("-sp":path:args) = do
    let ps = U.pathRE.splitted path
    let pschecked = map peCheck ps
        peCheck pe = do
            f      <- File.new pe
            exists <- f.exists
            readable <- f.canRead
            isdir  <- f.isDirectory
            if exists
              then if readable
                then if isdir
                  then IO.return true
                  else do
                        IO.stderr.println (pe ++ " should be a directory")
                        IO.return false
                else do
                    IO.stderr.println (pe ++ " is not readable")
                    IO.return false
              else do
                IO.stderr.println (pe ++ " does not exist")
                IO.return false
    bits <- sequence pschecked
    rest <- scanOpts opts.{sourcePath = ps} args
    if fold (&&) true bits then IO.return rest else IO.return Nothing
scanOpts opts ("-fp":xs) | null xs || head xs ~ ´^-´ = do
    IO.stderr.println "option -fp must be followed by classpath"
    IO.return Nothing
scanOpts opts ("-fp":path:args) = do
    let ps = U.pathRE.splitted path
    let pschecked = map peCheck ps
        peCheck pe = do
            let isjar = String.toUpperCase pe ~ ´\.(ZIP|JAR)$´
            f      <- File.new pe
            exists <- f.exists
            readable <- f.canRead
            isdir  <- f.isDirectory
            if exists
              then if readable
                then if isdir
                  then IO.return true
                  else if isjar then IO.return true
                    else do
                        IO.stderr.println (pe ++ " should be a jar or zip archive or a directory")
                        IO.return false
                else do
                    IO.stderr.println (pe ++ " is not readable")
                    IO.return false
              else do
                IO.stderr.println (pe ++ " does not exist")
                IO.return false
    bits <- sequence pschecked
    rest <- scanOpts opts.{path = ps} args
    if fold (&&) true bits then IO.return rest else IO.return Nothing
scanOpts opts (´^-enc(oding)?$´:xs) | null xs || head xs ~ ´^-´ = do
    IO.stderr.println "option -enc must be followed by code name"
    IO.return Nothing
scanOpts opts (´^-enc(oding)?$´:enc:args) = scanOpts opts.{encoding = mbEncoding} args
    where mbEncoding = if enc == "DEFAULT" then Nothing else Just enc
scanOpts opts ("-prefix":xs) | null xs || head xs ~ ´^-´ = do
    IO.stderr.println "option -prefix must be followed by prefix string"
    IO.return Nothing
scanOpts opts ("-prefix":pre:args) = scanOpts opts.{prefix = pre} args
scanOpts opts ("-xr":xs) | null xs || head xs !~ ´^\d+(\D\d+)?$´ = do
    IO.stderr.println "option -xr must be followed by number range"
    IO.return Nothing
scanOpts opts ("-xr" : m~´^(\d+)(\D(\d+))?$´ : args) =
    if a <= b then scanOpts opts.{tRanges <- ((a,b):)} args
    else do IO.stderr.println ("Did you mean \"-xr " ++ show  b ++ "-" ++ show a
                    ++ "\"? This way, line specific tracing will be off")
            scanOpts opts.{tRanges <- ((a,b):)} args    -- do what he said, not what he meant
    where (a,b) = case m.group 1 of
            Just s1 -> case m.group 3 of
                Just s2 ->  (s1.atoi, s2.atoi)
                Nothing ->  (s1.atoi, s1.atoi)
            Nothing -> (0, Int.maxBound)                 -- just to make warning go away
scanOpts opts ("-explain":xs) | null xs || head xs !~ ´^\d+(\D\d+)?$´ = do
    IO.stderr.println "option -explain must be followed by number range\n"
    IO.return Nothing
scanOpts opts ("-explain" : m~´^(\d+)(\D(\d+))?$´ : args) =
    if a <= b then scanOpts opts.{tRanges <- ((a,b):), flags = setFlag opts.flags EXPLAIN} args
    else do IO.stderr.println ("Did you mean \"-explain " ++ show b ++ "-" ++ show a
                    ++ "\"? This way, explaining will be off.")
            scanOpts opts.{tRanges <- ((a,b):)} args    -- do what he said, not what he meant
    where (a,b) = case m.group 1 of
            Just s1 -> case m.group 3 of
                Just s2 ->  (s1.atoi, s2.atoi)
                Nothing ->  (s1.atoi, s1.atoi)
            Nothing -> (0, Int.maxBound)                 -- just to make warning go away
scanOpts opts ("-version":args)  = printVersion >> scanOpts opts args
scanOpts opts ("-help":args)     = printHelp    >> scanOpts opts args            
scanOpts opts ((flag@´^-´):args) = case flagtree.lookup flag of
    Just f -> scanOpts opts.{flags <- f} args
    Nothing -> do
        IO.stderr.println ("invalid flag " ++ flag ++ ", use -help for command line syntax.")
        scanOpts opts args
        IO.return Nothing
scanOpts opts filenames | head filenames !~ ´^-´ = IO.return (Just (opts, filenames))
scanOpts opts (wrong:args)  = do
        IO.stderr.println ("invalid argument `" ++ wrong ++ "`,  use -help for command syntax.")
        scanOpts opts args
        IO.return Nothing


