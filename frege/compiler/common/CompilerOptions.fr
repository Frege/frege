--- Option parsing and initial 'Global' values
module frege.compiler.common.CompilerOptions where 
        -- generated by Splitter
import  frege.Version
import  frege.java.IO()
import  frege.data.TreeMap as TM(TreeMap)
import  frege.data.Bits
import  frege.compiler.enums.Flags
import  frege.compiler.types.Positions
import  frege.compiler.types.Packs
import  frege.compiler.types.External(defEA)
import  frege.compiler.types.Global  as  G
import  frege.compiler.Classtools as CT()
import  frege.compiler.types.Targets public(thisTarget, java7)
import  frege.compiler.types.Targets(Target)



--- the path separator used here
pathSep = fromMaybe ":"  (System.getProperty "path.separator")


--- a pattern that can be used to 'Regex.split' a 'String' by the path separator
pathRE = case regcomp pathSep.quote of
    Right p -> p
    Left _ -> Prelude.error ("cannot regcomp " ++ pathSep.quote)


--- the class path this JVM started with, as ['String']
classPath = (pathRE.splitted ‚Ä¢ fromMaybe "." ‚Ä¢ System.getProperty) "java.class.path"


--- get us the one and only class loader
theClassLoader opt = CT.makeClassLoader (ourPath opt)


--- our complete path
ourPath opt = result where
    flags  = Options.flags opt
    result = if isOn flags WITHCP then classPath ++ (opt.dir : opt.path)
                else (opt.dir : opt.path)


--- the standard options with filename
public stdOptions = Options {
      source = "-",             -- read from standard input
      sourcePath = ["."],
      flags = fold setFlag Flags.empty [
            WARNINGS, WITHCP, RUNJAVAC, 
            USEUNICODE, USEGREEK,
            ],
      dir = ".",                -- work in current directory
      path = [],                -- same as java classpath
      prefix = "",              -- no prefix
      encoding = Just "UTF-8",  -- use UTF8 by default
      tRanges = [],
      target = thisTarget,       -- that of the running VM
      extending = Nothing,
      implementing = [],
      code = []
    }


private ideOptions = stdOptions.{
    flags = Flags.fromList [WARNINGS, HINTS, IDEMODE, IDETOKENS,
                            USEUNICODE, USEFRAKTUR],
    target = Target 1 8}


printHelp = do
    mapM_ stderr.println [
            "usage:",
            "    java -jar fregec.jar [flags] [items ....]",
            "    java -jar fregec.jar -help           print this message",
            "    java -jar fregec.jar -version        print version information",
            "",
            "    JVM properties:",
            "        \"-Dfrege.javac=javac -J-Xmx512m\"   java compiler and options, default internal",
            -- "        \"-Dfrege.prelude=other.Prelude\"    package name of Prelude, default frege.Prelude",
        ]
    usage
    IO.return 0


printVersion = do
    let classnotfound (_::ClassNotFoundException) = pure Nothing
        vsn = do
            g   ‚Üê standardGlobal
            fpm ‚Üê CT.getFrege g.sub.loader "frege.Version" `catch` classnotfound
            case fpm of
                Nothing  ‚Üí  pure version
                Just fp  ‚Üí  if Target fp.jmajor fp.jminor <= java7
                        then pure (version.replaceFirst '\.(\d+)\.' ".$1-7.")
                        else pure version
    v <- vsn
    println v
    println commit



eclipseOptions = do
    g <- standardGlobal
    return g.{options = ideOptions}


--- an initial Gen data structure
initialGen = Gen {
                printer = IO.stdout,
                tunique = 0,
                runique = 0,
                sunique = 0,
                xunique = 1,
                tTree = TreeMap.empty,
                rTree = TreeMap.empty,
                sTree = TreeMap.empty,
                xTree = TreeMap.empty .insert defEA 0,        -- so that 0 never indexes valid expression
                expSym = TreeMap.empty,
                consts = TreeMap.empty,
                symi8 = TreeMap.empty,
                jimport = TreeMap.empty,
                main = "",
            }

--- Starting point when working with 'StG' or 'StIO' actions.
standardGlobal = do
    loader   <- theClassLoader stdOptions

    return Global {
            options = stdOptions,
            sub = Sub {
                loader,
                toks = arrayFromList [],
                code = CharSequence.fromString "",
                idKind = TreeMap.empty,
                sourcedefs  = [],
                packageDoc = Nothing,
                thisPos  = Position.null,
                nsPos = TreeMap.empty,
                packWhy = TreeMap.empty,
                nsUsed = TreeMap.empty,
                thisPack = Pack.new "",
                numErrors  = 0, resErrors = 0,
                messages = [],
                cancelled = return false,
                nextPass = 1,
                stderr = IO.stderr,
                toExport = [],
            },
            gen = initialGen,
            unique = 999,
            packages = TreeMap.empty,
            namespaces = TreeMap.empty,
            genEnv = [],
            javaEnv = TreeMap.empty,
            locals = TreeMap.empty,
            typEnv = [],
            tySubst = TreeMap.empty,
        }


--- print usage information common to many tools
usage = mapM_ stderr.println [
            "    flags:",
            "       -d directory    target directory for *.java and *.class files",
            "       -fp classpath   where to find imported frege packages",
            "       -enc charset    charset for source code files, standard is UTF-8",
            "       -enc DEFAULT    platform default charset for source code files",
            "       -nocp           exclude java classpath from -fp",
            "       -hints          print more detailed error messages and warnings",
            "       -inline         inline functions where possible",
            "       -strict-pats    check patterns in multi-argument functions strictly from left to right",
            "       -comments       generate commented code",
            "       -explain i[-j]  print some debugging output from type checker",
            "                       regarding line(s) i (to j). May help to understand",
            "                       inexplicable type errors better.",
            "       -nowarn         don't print warnings (not recommended)",
            "       -v              verbose mode on",
            "       -make           build outdated or missing imports",
            "       -sp srcpath     look for source files in srcpath, default is .",
            "       -target x.y     generate code for java version x.y, default is the",
            "                       version of the JVM the compiler is running in.",
            "       -j              do not run the java compiler",
            "       -ascii          do not use ‚Üí, ‚áí, ‚àÄ and ‚à∑ when presenting types,",
            "                       and use ascii characters for java generics variables",
            "       -greek          make greek type variables",
            "       -fraktur        make ùñãùñóùñÜùñêùñôùñöùñó type variables",
            "       -latin          make latin type variables",
            -- "       -prefix stage   prefix for package names, used in compiler development",
            -- "       -xN             debugging output from pass N, where N elem [1..9]",
            -- "       -xt             debugging output from type checker",
            -- "       -xo             debugging output from optimizer",
            -- "       -xs             debugging output from strictness analysis",
            -- "       -xg             debugging output from code generation",
            -- "       -xr i[-j]       confine tracing to range of line numbers or just a line",
            -- "                       multiple ranges can be specified",
            "",
            "A classpath is a list of jar files, zip-Files or directories separated by "
            ++ pathSep,
            "A srcpath is a list of directories separated by "
            ++ pathSep,
            "To get parser debugging output, set YYDEBUG environment variable to 1",
        ]


--- used to look up flag values
flagtree = TM.fromList [
    ("-nocp",   (BitSet.`differenceE` WITHCP)),
    ("-j",      (BitSet.`differenceE` RUNJAVAC)),
    ("-nowarn", (BitSet.`differenceE` WARNINGS)),
    ("-ascii",  (BitSet.`differenceE` USEUNICODE)),
    ("-hints",  (BitSet.`unionE` HINTS)),
    ("-make",   (BitSet.`unionE` MAKE)),
    ("-inline",     (BitSet.`unionE` INLINE)),
    ("-O",          (BitSet.union (BitSet.fromList [OPTIMIZE, INLINE]))),
    ("-symbols",    (BitSet.`unionE` USEUNICODE)),
    ("-greek",      (BitSet.`differenceE` USEFRAKTUR) ‚Ä¢ (BitSet.`unionE` USEGREEK) ‚Ä¢ (BitSet.`unionE` USEUNICODE)),
    ("-fraktur",    (BitSet.`differenceE` USEGREEK) ‚Ä¢ (BitSet.`unionE` USEFRAKTUR) ‚Ä¢ (BitSet.`unionE` USEUNICODE)),
    ("-latin",      (BitSet.`differenceE` USEGREEK) ‚Ä¢ (BitSet.`differenceE` USEFRAKTUR)),
    ("-comments",   (BitSet.`unionE` COMMENTS)),
    ("-propertc",   (BitSet.`unionE` PROPERTC)),
    ("-strict-pats",(BitSet.`unionE` STRICTLRPATS)), 
    ("-v",          (BitSet.`unionE` VERBOSE)),
    ("-x1",         (BitSet.`unionE` TRACE1)),
    ("-x2",         (BitSet.`unionE` TRACE2)),
    ("-x3",         (BitSet.`unionE` TRACE3)),           -- symbol table operations
    ("-x4",         (BitSet.`unionE` TRACE4)),
    ("-x5",         (BitSet.`unionE` TRACE5)),
    ("-x6",         (BitSet.`unionE` TRACE6)),
    ("-x7",         (BitSet.`unionE` TRACE7)),
    ("-x8",         (BitSet.`unionE` TRACE8)),
    ("-x9",         (BitSet.`unionE` TRACE9)),
    ("-xt",         (BitSet.`unionE` TRACET)),           -- type checker
    ("-xx",         (BitSet.`unionE` TRACEX)),           -- env operations, lots of output
    ("-xm",         (BitSet.`unionE` TRACEM)),           -- make operations
    ("-xk",         (BitSet.`unionE` TRACEK)),           -- kind inference
    ("-xo",         (BitSet.`unionE` TRACEO)),           -- optimizer
    ("-xs",         (BitSet.`unionE` TRACES)),           -- strictness
    ("-xg",         (BitSet.`unionE` TRACEG)),           -- code generator
    ("-xz",         (BitSet.`unionE` TRACEZ)),           -- on demand, for mysterious things
    ]

--- Scan command line using 'stdOptions' as base.
--- This returns either
--- > Nothing
--- when something is not in order, in this case an appropriate message has already been printed.
--- Or it returns:
--- > Just (options, fileargs)
--- where @options@ goes in the 'Global.options' field, and @fileargs@ are the file arguments.
getOpts = scanOpts stdOptions  

--- scan command line with some sanity checks, return indication of success
scanOpts :: Options -> [String] -> IO (Maybe (Options, [String]))
scanOpts opts [] = IO.return (Just (opts, []))
scanOpts opts ("-d":xs)  | null xs || head xs ~ ¬¥^-¬¥ = do
    IO.stderr.println "option -d must be followed by a directory name."
    IO.return Nothing
scanOpts opts ("-d":dir:args) = do
    let f = File.new dir
    isdir <- f.isDirectory
    if isdir then do
            canRead <- f.canRead
            if canRead then do
                    canWrite <- f.canWrite
                    if canWrite then scanOpts opts.{dir} args
                        else do
                            IO.stderr.println ("directory " ++ dir ++ " is not writable.")
                            IO.return Nothing
                else do
                    IO.stderr.println ("directory " ++ dir ++ " is not readable.")
                    IO.return Nothing
        else do
            IO.stderr.println (dir ++ " is not a directory.")
            IO.return Nothing
scanOpts opts ("-sp":xs) | null xs || head xs ~ ¬¥^-¬¥ = do
    IO.stderr.println "option -sp must be followed by source path."
    IO.return Nothing
scanOpts opts ("-sp":path:args) = do
    let ps = pathRE.splitted path
    let pschecked = map peCheck ps
        peCheck pe = do
            let f = File.new pe
            exists <- f.exists
            readable <- f.canRead
            isdir  <- f.isDirectory
            if exists
              then if readable
                then if isdir
                  then IO.return true
                  else do
                        IO.stderr.println (pe ++ " should be a directory")
                        IO.return false
                else do
                    IO.stderr.println (pe ++ " is not readable")
                    IO.return false
              else do
                IO.stderr.println (pe ++ " does not exist")
                IO.return false
    bits <- sequence pschecked
    rest <- scanOpts opts.{sourcePath = ps} args
    if fold (&&) true bits then IO.return rest else IO.return Nothing
scanOpts opts ("-fp":xs) | null xs || head xs ~ ¬¥^-¬¥ = do
    IO.stderr.println "option -fp must be followed by classpath"
    IO.return Nothing
scanOpts opts ("-fp":path:args) = do
    let ps = pathRE.splitted path
    let pschecked = map peCheck ps
        peCheck pe = do
            let isjar = String.toUpperCase pe ~ ¬¥\.(ZIP|JAR)$¬¥
                f = File.new pe
            exists <- f.exists
            readable <- f.canRead
            isdir  <- f.isDirectory
            if exists
              then if readable
                then if isdir
                  then IO.return true
                  else if isjar then IO.return true
                    else do
                        IO.stderr.println (pe ++ " should be a jar or zip archive or a directory")
                        IO.return false
                else do
                    IO.stderr.println (pe ++ " is not readable")
                    IO.return false
              else do
                IO.stderr.println (pe ++ " does not exist")
                IO.return false
    bits <- sequence pschecked
    rest <- scanOpts opts.{path = ps} args
    if fold (&&) true bits then IO.return rest else IO.return Nothing
scanOpts opts (¬¥^-t(arget)?$¬¥:xs) | null xs || head xs ~ ¬¥^-¬¥ = do
    stderr.println "option -target must be followed by target version"
    return Nothing
scanOpts opts (¬¥^-t(arget)?$¬¥:vsn:args) = do
    case Target.decode vsn of
        Just t -> if t < Target 1 6 then do
                stderr.printf "target %s is not supported, minimum is 1.6" (show t)
                stderr.println
                return Nothing
            else if t > thisTarget then do
                stderr.printf "We can't generate code for %s when running JDK %s"
                    (show t) (show thisTarget)
                stderr.println
                stderr.printf "Please run the compiler under a %s JDK to do this." (show t)
                stderr.println
                return Nothing
            else scanOpts opts.{target = t} args
        Nothing -> do
            stderr.printf "%s is an invalid target version" vsn
            stderr.println
            return Nothing
scanOpts opts (¬¥^-enc(oding)?$¬¥:xs) | null xs || head xs ~ ¬¥^-¬¥ = do
    IO.stderr.println "option -enc must be followed by the name of an encoding"
    IO.return Nothing
scanOpts opts (¬¥^-enc(oding)?$¬¥:enc:args) = scanOpts opts.{encoding = mbEncoding} args
    where mbEncoding = if enc == "DEFAULT" then Nothing else Just enc
scanOpts opts ("-prefix":xs) | null xs || head xs ~ ¬¥^-¬¥ = do
    IO.stderr.println "option -prefix must be followed by prefix string"
    IO.return Nothing
scanOpts opts ("-prefix":pre:args) = scanOpts opts.{prefix = pre} args
scanOpts opts ("-xr":xs) | null xs || head xs !~ ¬¥^\d+(\D\d+)?$¬¥ = do
    IO.stderr.println "option -xr must be followed by number range"
    IO.return Nothing
scanOpts opts ("-xr" : m~¬¥^(\d+)(\D(\d+))?$¬¥ : args) =
    if a <= b then scanOpts opts.{tRanges <- ((a,b):)} args
    else do IO.stderr.println ("Did you mean \"-xr " ++ show  b ++ "-" ++ show a
                    ++ "\"? This way, line specific tracing will be off")
            scanOpts opts.{tRanges <- ((a,b):)} args    -- do what he said, not what he meant
    where (a,b) = case m.group 1 of
            Just s1 -> case m.group 3 of
                Just s2 ->  (s1.atoi, s2.atoi)
                Nothing ->  (s1.atoi, s1.atoi)
            Nothing -> (0, Int.maxBound)                 -- just to make warning go away
scanOpts opts ("-explain":xs) | null xs || head xs !~ ¬¥^\d+(\D\d+)?$¬¥ = do
    IO.stderr.println "option -explain must be followed by number range\n"
    IO.return Nothing
scanOpts opts ("-explain" : m~¬¥^(\d+)(\D(\d+))?$¬¥ : args) =
    if a <= b then scanOpts opts.{tRanges <- ((a,b):), flags = setFlag opts.flags EXPLAIN} args
    else do IO.stderr.println ("Did you mean \"-explain " ++ show b ++ "-" ++ show a
                    ++ "\"? This way, explaining will be off.")
            scanOpts opts.{tRanges <- ((a,b):)} args    -- do what he said, not what he meant
    where (a,b) = case m.group 1 of
            Just s1 -> case m.group 3 of
                Just s2 ->  (s1.atoi, s2.atoi)
                Nothing ->  (s1.atoi, s1.atoi)
            Nothing -> (0, Int.maxBound)                 -- just to make warning go away
scanOpts opts ("-version":args)  = printVersion >> scanOpts opts args
scanOpts opts ("-help":args)     = printHelp    >> scanOpts opts args            
scanOpts opts ((flag@¬¥^-¬¥):args) = case flagtree.lookup flag of
    Just f -> scanOpts opts.{flags <- f} args
    Nothing -> do
        IO.stderr.println ("invalid flag " ++ flag ++ ", use -help for command line syntax.")
        scanOpts opts args
        IO.return Nothing
scanOpts opts (filenames@wrong:args)
    | wrong !~ ¬¥^-¬¥ = IO.return (Just (opts, filenames))
    | otherwise  = do
        IO.stderr.println ("invalid argument `" ++ wrong ++ "`,  use -help for command syntax.")
        scanOpts opts args
        IO.return Nothing


