--- Common stuff from formerly Transform
module frege.compiler.common.Trans where 
        -- generated by Splitter
import  frege.Prelude  hiding(<+>)
import  Data.TreeMap  as  TM(TreeMap, TreeSet, lookup, insert, keys, values, each, fromKeys, including, contains, union)
import  Data.List (partitioned)
import  Lib.PP(text, msgdoc, <+>, text)

import  Compiler.enums.TokenID(VARID)
import  Compiler.enums.SymState(Typechecked)
import  Compiler.enums.CaseKind(CWhen)
import  Compiler.enums.Flags(TRACES)

import  Compiler.classes.Nice(nice, nicer)

import  Compiler.types.Positions
import  Compiler.types.Tokens
import  Compiler.types.QNames
import  Compiler.types.Expression
import  Compiler.types.Symbols
import  Compiler.types.Types
import  Compiler.types.Strictness
import  Compiler.types.Packs(pPreludeBase)
import  Compiler.types.Global  as  G

import  Compiler.tc.Util as TCU()

import  Compiler.Utilities  as  U(allourvars, allvars)

import  Compiler.common.SymbolTable(enter, changeSym)
import  Compiler.common.Binders
import  Compiler.types.Patterns
import  Compiler.enums.Literals
import  Compiler.common.Types as T(unifySigma)
import  Compiler.common.Errors as E()
-- import  Compiler.types.Expression

{--
 * how often the symbol with 'Symbol.sid' is referenced in 'Expr' @x@
 -}
references sids x = U.foldEx true refs 0 x
    where
        refs n (Vbl {pos,name}) = do
            -- g <- getST
            -- E.logmsg TRACE7 pos ("references " ++ show n ++ " " ++ show sids ++ "  " ++ nice name g)
            sym <- U.findVD name
            if sym.sid `elem` sids then stio (Right (n+1)) else stio (Left n)
        refs n (Ifte c t e _) = do
            crefs <- references sids c
            trefs <- references sids t
            erefs <- references sids e
            stio (Right (n + crefs + max trefs erefs))
        refs n (Case {ex,alts}) = do
            xrefs <- references sids ex
            arefs <- mapSt altRefs alts
            stio (Right (n + xrefs + fold max 0 arefs))
        refs n (Lam {ex}) = do
            lrefs <- references sids ex
            stio (Right (n + lrefs))
        refs n (Let {env,ex}) = do
            syms  <- mapSt U.findV env
            srefs <-sequence [ subex | SymV{expr = Just subex} <- syms ] >>= mapSt (references sids) 
            lrefs <- references sids ex
            stio (Right (n + 2*sum srefs + lrefs))             
        refs n x = do
            -- g <- getST
            -- E.logmsg TRACE7 (getpos x) ("references " ++ show n ++ " " ++ show sids ++ "  " ++ nice x g)
            stio (Left n)
        altRefs (CAlt {ex}) = references sids ex


{--
 * [returns] *@true@* if expression is simple. See 'pass9' for more information.
 *
 * A simple expression can be translated to a java expression and will not need
 * blocks, if-then-else constructs, auxiliary declarations etc.
 -}
isSimple :: Global -> Expr -> Bool
isSimple g (App a b _)     = isSimple g a && isSimple g b
isSimple g (Ifte a b c _)  = isSimple g a && isSimple g b && isSimple g c
isSimple g (Ann {ex})      = isSimple g ex
isSimple g (Vbl {pos})     = true
isSimple g (Lit {pos})     = true
isSimple g (Con {pos})     = true
isSimple g (Lam {ex})      = isEasy g ex
isSimple g Mem{ex}         = isSimple g ex
isSimple g _               = false


{--
 * [returns] *@true@* if expression is easy. See 'pass9' for more information.
 *
 * An easy expression can be translated to a series of java statements
 * with a final return, i.e. to a valid method body.
 -}
isEasy :: Global -> Expr -> Bool
isEasy g (App a b _)       = isSimple g a && isSimple g b
isEasy g (Let {env,ex})    = isEasy g ex && all (isEasy g) xprs
    where
        xprs = [ ex | q <- env, sym <- g.findit q, ex <- sym.gExpr g]
isEasy g (Case {ex,alts})   = isSimple g ex && all (isEasy g • _.ex) alts
    
isEasy g (Ifte a b c _)     = isSimple g a && isEasy g b && isEasy g c
isEasy g (Ann {ex})        = isEasy g ex
isEasy g x                 = isSimple g x


--- @replSid sid r ex@ - replace local variables referencing sid with r in ex
replSid ∷ Int → ExprT → ExprT → ExprD Global
replSid sid r ex = U.mapEx true action ex
    where
        action (v@Vbl {name=Local {}}) = do
            sym <- U.findVD v.name
            if sym.sid == sid then stio (Right r) else stio (Right v)
        action x = stio (Left x)


--- @replName sid nm ex@ - rename variables that references sid in ex
replName sid nm ex = U.mapEx true action ex
    where
        action (v@Vbl {name,pos}) = do
            sym <- U.findVD name
            if sym.sid == sid then do
                changeST Global.{sub <- SubSt.{
                           idKind <- insert (KeyTk pos.first) (Right nm)}}
                stio (Right v.{name=nm}) 
            else stio (Right v)
        action x = stio (Left x)

--- substitute the local variable with uid _old_  in _ex_ replace their name with _local_
changeSID :: Int -> QName -> Expr -> StG Expr
changeSID !old !local ex = U.mapEx true ch ex
    where
        ch (v@Vbl{name=Local{uid}})
            | uid == old = pure (Right v.{name=local})
            | otherwise  = pure (Right v)
        ch x = pure (Left x)  


{--
 * [usage] @patternRefutable g pat@
 * [returns] *true* if the pattern is refutable, *false* otherwise
 -}
patternRefutable g p = case p of
    PVar {var}      -> false
    PLit {pos}      -> true
    PMat {pos}      -> true
    PCon {pos,pats} -> not (productCon p.qname g) || any (patternRefutable g) pats
    _ | p.{pat?}    -> patternRefutable g p.pat
      | otherwise   -> false

{--
 * [usage] @patternStrictness pat@
 * [returns] the 'Strictness' value for the 'Pattern' @pat@
 * [requires] The environment where the pattern bound variables are held must be active.
 * [see] 'productCon'
 *
 * A pattern is _strict_, if it is _refutable_ or if it contains strict variables.
 * A pattern is _refutable_ if the match can possibly fail. Variables and product constructor
 * applications that contain only irrefutable patterns are irrefutable.
 -}
patternStrictness p = case p of
        PVar {uid,var} -> do
            g ← getST
            v <- U.findV (Local uid var)
            E.logmsg TRACES (getpos p) (
                    text "patternStrictness: "
                    <+> text (nicer p g)
                    <+> text " :: "
                    <+> text (nice v.typ g)
                    <+> text (if v.typ.isFun then " function" else " no function")
                )
            pure v.strsig
            --if v.typ.isFun
            --then do
            --    unless v.strsig.isStrict do
            --        changeSym v.{strsig = S[]}
            --    pure (S[])
            --else pure v.strsig
        PAt {pos,uid,var,pat} -> do
            ps <- patternStrictness pat
            if ps == U then patternStrictness (PVar {pos,uid,var}) else stio ps
        PUser {pat, lazy} -> do
            ps <- patternStrictness pat
            if lazy then case pat of
                    PVar{uid, var} -> do
                        v <- U.findV (Local uid var)
                        when v.strsig.isStrict do changeSym v.{strsig = U}
                        pure U
                    other → pure U
            else if ps == U then stio (S[]) else stio ps
        PLit {pos} -> stio (S[])
        PMat {pos} -> stio (S[])
        PAnn {pat} -> patternStrictness pat
        PCon {pos,qname,pats} = do
                g <- getST
                if not (productCon qname g) then stio (S[])
                  else do
                    ps <- mapSt patternStrictness pats
                    -- if all (U==) ps then stio U else stio (S ps)
                    return (S ps)
        PConFS {pos} -> E.fatal pos (text ("patternStrictness: found PConFS")) -- not allowed anymore at this time



{--
 * [usage] @productCon name g@
 * [returns] *@true@* if @name@ names a constructor of a product type in @g@,
 *           *@false@* if it is the name of a sum type
 * [requires] @name@ must name a member of a data type in @g@
 -}
productCon (MName tname _) g = case g.findit tname of
        Just (SymT {product}) -> product
        other -> error ("productCon " ++ tname.nice g ++ " is not a type")
productCon _ _ = false

{--
 * [usage] @newtypeCon name g@
 * [returns] *@true@* if @name@ names a constructor of a newtype in @g@,
 *           *@false@* otherwise
 * [requires] @name@ must name a member of a data type in @g@
 -}
newtypeCon (MName tname _) g = case g.findit tname of
        Just (SymT {newt}) -> newt
        other -> error ("productCon " ++ tname.nice g ++ " is not a type")
newtypeCon _ _ = false

{--
 * [usage] @patsComplete g [pat, ...]@
 * [return] @Just p@ where @p@ is a pattern that is missing in the set or @Nothing@
 *      if the set of patterns is _complete_.
 * [required] the list of patterns must not be empty
 *
 *
 * A set of patterns is complete if it contains at least one irrefutable pattern
 * or if all possible literals / constructors are listed and for every constructor
 * the set of the subpatterns is complete.
 -}
patsComplete g [] = Just (PVar {pos=Position.null, uid=0, var = "unguarded"})  -- if all case alts carry open case when
patsComplete g ps
    -- Prelude.traceLn ("patsComplete [" ++ joined "," (map (flip nice g) ps) ++ "]") = undefined
    -- Prelude.traceLn ("patsComplete [" ++ joined "," (map (show • not • patternRefutable g) ps) ++ "]") = undefined
    | any (not • patternRefutable g) ps = Nothing
    | otherwise                         = missing canonicPats
    where
        -- refutables  = filter (patternRefutable g) canonicPats
        canonicPats = map canonic ps
        -- only PCon, PLit and PVar are considered
        canonic (PMat {pos, value}) = PLit {pos, kind = LRegex, value, negated = false}
        canonic (p@PCon {pos}) = p.{pats <- map canonic}
        canonic p | p.{pat?}   = canonic p.pat
        canonic p              = p
        pany                   = PVar {pos=Position.null, uid=0, var = "_"}
        -- compute the missing element from a list of refutable patterns
        missingLiteral [] = Just pany
        missingLiteral ls | any regex ls = Just (PLit {pos=Position.null, kind=LString, negated = false,
                                            value="\"any string not matched by regular expression\""})
            where regex (PLit {kind = LRegex}) = true
                  regex _                      = false
        missingLiteral (ps@PLit {pos, kind}:_) = Just (PLit {pos, kind, value, negated = false})
            where value = (head • filter (`notElem` (map Pattern.value ps))) (lany kind)
                  lany LBool = ["true", "false", "blödsinn"]
                  lany LString = allBinders g
                  lany LChar   = map show (iterate Char.succ '!')
                  lany LInt    = map show (iterate Int.succ 42)
                  lany LLong   = map show (iterate Long.succ 42L)
                  lany LBig    = map show (iterate Integer.succ 42n)
                  lany LDouble = map show (iterate (0.42*)  3.14159)
                  lany LFloat  = map show (iterate (0.42f*) 3.14159f)
                  lany LRegex  = allBinders g
                  lany LDec    = map show (iterate (0.42*)  3.14159)
        missingLiteral _ = Just pany
        -- compute the missing element from a list of refutable patterns
        missing [] = Just pany                              -- _
        missing (ps@(PLit {kind=LBool}:_)) = case map Pattern.value ps of
            tfs -> if all (`elem` tfs) ["true", "false"]
                then Nothing
                else missingLiteral ps
        missing (ps@(PLit {pos}:_))   = missingLiteral ps
        missing (ps@(PCon {qname}:_))
            | s:_ <- filter (not • (`elem` pnames) • Symbol.name) (cons qname) = Just (mkCon s)
            | otherwise = case (filter isJust • map groupcheck) (group ps) of
                some:_ -> some
                []  -> Nothing
            where
                pnames = map Pattern.qname ps
                cons (MName tname _) = case Global.findit g tname of
                    Just (SymT {env}) -> U.envConstructors env
                    _ -> []
                cons _ = []
                mkCon (SymD {name,flds}) = PCon {pos=Position.null, qname=name,
                                                    pats = map (const pany) flds}
                mkCon _ = error "mkCon: no constructor"
                group :: [Pattern] -> [(QName, [[Pattern]])]
                group [] = []
                group (PCon {qname,pats}:ps) = (qname, pats:map Pattern.pats same):group other
                    where
                        same  = filter ((`==` qname) • Pattern.qname) ps
                        other = filter ((`!=` qname) • Pattern.qname) ps
                group _ = error "group: no PCon"
        missing _ = error "missing: bad patterns"
        -- check a group of patterns (QName, [[p11, p12, p13], [p21, p22, p23], ...])
        groupcheck (qname, [])    = Just pany                   -- cannot happen
        groupcheck (qname, []:_)  = Nothing                     -- nullary constructor
        groupcheck (qname, patss) = anongroup (PCon Position.null qname) patss
        -- [true, 2, c1]
        -- [false, b2, 3]
        -- [_, 1, _]            // irefs
        anongroup recon grp
            | length (head grp) == 1 = result (patsComplete g col1)     -- base case
            | all (not • patternRefutable g) col1 = -- the first column has only irrefutables
                anongroup (\ps -> recon (pany:ps)) cols
            | all (patternRefutable g) col1 = anonRgrp recon grp
            | Nothing <- anongroup recon irefs = Nothing
            | Nothing <- anonRgrp recon refs = Nothing
            -- there are some patterns with refutable heads and some with irrefutable ones
            | otherwise = anonRgrp  recon (refs ++ nrefs)
            where
                col1 = map head grp
                cols = map tail grp
                result Nothing = Nothing
                result (Just p) = Just (recon (p : map (const pany) (head cols)))
                (refs, irefs) = partitioned (patternRefutable g • head) grp
                nrefs = [ p:rest | _:rest <- irefs, p <- cons ]
                cons = constructors (head (head refs))
                -- constructors :: Pattern -> ([Pattern] ->
                constructors (lit@PLit {kind=LBool}) = [ lit.{value=s} | s <- ["true", "false"] ]
                constructors (con@PCon {qname=MName tname _}) = case g.findit tname  of
                    Just (SymT {env}) ->
                        [ PCon con.pos sym.name (take (length sym.flds) dummies) |
                            (sym::Symbol) <- U.envConstructors env ] where
                                dummies = repeat (PVar con.pos 0 "_")
                    _ -> []
                constructors _ = []
                -- [[Just 1, a1, a2]         // refs
                --  [Just x, b1, b2]]
                -- [[Nothing, c1, c2]]            // irefs
                -- transform this to  [[1, a1, a2], [x, b1, b2]]  and [[c1,c2]]
                -- then check each as anon group
                anonRgrp recon grp
                    | Just x <- patsComplete g col1 = Just (recon (x : map (const pany) (head cols)))
                    | otherwise = loop groups
                    where
                        constructor (PCon {qname}) = qname
                        constructor (PLit {value}) = Local 0 value
                        constructor _ = error "constructor: ?"
                        subpats (PCon {pats}) = pats
                        subpats _             = []
                        recreate (PCon {pos, qname}) = PCon pos qname
                        recreate x                   = const x
                        groups = group grp
                        group :: [[Pattern]] -> [[[Pattern]]]
                        group [] = []
                        group ps = pss1 : group xs where
                          p1c = constructor (head (head ps))
                          (pss1, xs) = partitioned samecon ps
                          samecon p = constructor (head p) == p1c
                        col1 = map head grp
                        cols = map tail grp
                        loop [] = Nothing           -- complete!
                        loop (grp:grps) = case anongroup (f rest.length) ung of
                                Nothing -> loop grps
                                other   -> other
                            where
                                rec  = recreate (head (head grp))
                                rest = subpats  (head (head grp))
                                ung  = map uncon grp
                                uncon (p:ps) = subpats p ++ ps
                                uncon [] = undefined
                                f n xs = recon (rec (take n xs) : drop n xs)




classMethodOfInstMethod :: Position -> QName -> String -> StG Symbol
classMethodOfInstMethod pos inst base = do
    g <- getST 
    case g.findit inst of
        Just isym | SymI{clas} <- isym = case g.findit clas of
            Just csym | SymC{supers} <- csym = do
                let sym = head [ sym | c <- clas:supers, SymC{env} <- g.findit c,
                            sym <- values env,
                            sym.name.base == base ]
                return sym
            other -> E.fatal pos (text ("classMethodOfInstMethod: " ++ nice clas g ++ " not a type class."))
        other -> E.fatal pos (text ("classMethodOfInstMethod: " ++ nice inst g ++ " not an instance."))


{--
    Eta expansion, applied to a value @x@ with function type
    yields another expression @\\n -> x n@ with the same type.

    This is done as long as the lambda body has still function type.

    This will remove points free style from definitions like

    > sum = fold (+) 0

    and will turn it into

    > sum n = fold (+) 0 n

    thus promoting fully satisfied applications as often as possible.

    Eta expansion must be done after type check and should be done before strictness check.
-}
etaExpand :: Expr -> StG Expr

etaExpand (lam@Lam {}) = do                 -- eta (\a -> x) = \a -> eta x
            nex <- etaExpand lam.ex
            stio lam.{ex=nex}

etaExpand (x@Ann {}) = do                   -- eta (x :: y) = (eta x :: y)
            nex <- etaExpand x.ex
            stio x.{ex=nex}

   

etaExpand x = case x.typ of                 -- all other expressions
        Just (ForAll [] (RhoTau ctx tau))
            | Just (farg, fret) <- tau.getFun = do
                g ← getST
                uniq <- uniqid
                let var = "η" ++ show uniq
                    pos  = (getpos x).change VARID var
                    arg = ForAll [] (RhoTau [] farg)
                    res = RhoTau [] fret
                    sym = U.patLocal pos uniq var
                    y = cleanVarType g x
                    app = App y (Vbl {pos, name=sym.name, typ = Just arg}) (Just (ForAll [] res))
                    pat = PVar {pos=pos, uid=uniq, var}
                    -- env = insert Nil pat.var (U.patLocal pos pat.var).{sid=uniq}
                enter sym.{state=Typechecked, typ=arg}
                body <- etaExpand app
                stio  Lam {pat, ex=body, typ = Just (ForAll [] (RhoFun ctx arg res))}
            | otherwise = stio x
        Just (ForAll [] (RhoFun ctx arg res)) = do
                g ← getST
                uniq <- uniqid
                sarg <- TCU.skolemise arg
                let pos = (getpos x).change VARID name
                    name = "η" ++ show uniq
                    pat = PVar{pos=getpos x, uid=uniq, var=name}
                    sym = U.patLocal pos uniq name
                    iarg = ForAll [] (snd sarg)     -- Num t42#a => t42#a -> t42#a
                    y = cleanVarType g x
                    app = App y (Vbl {pos, name=sym.name, typ = Just iarg}) (Just (ForAll [] res))
                -- sym <- U.mkLocal pat
                enter sym.{state=Typechecked, typ=arg}
                body <- etaExpand app
                stio  Lam {pat, ex=body, typ = x.typ}
    
        Just sig = do
            g <- getST
            E.warn (getpos x) (msgdoc ("can't do eta expansion for an expression of type " ++ nice sig g))
            E.hint (getpos x) (msgdoc ("try to write the surrounding binding in a eta expanded form"))
            stio x
        Nothing -> do
            g <- getST
            E.fatal (getpos x) (msgdoc ("eta expansion must be done after type check for "
                 ++ nice x g))
            stio x
    where
        -- clean unwanted contexts from the given type of a variable
        -- see also #294
        cleanVarType g (v@Vbl{pos, name, typ = Just sigma}) | not (null sigma.rho.context) = 
            case g.findit name of
                Just sym → v.{typ = Just vtyp} 
                    where
                        subst = unifySigma g sym.typ sigma
                        vtyp = ForAll [b | b ← sym.typ.bound, not (TM.member b.var subst)] (T.substRho subst sym.typ.rho)
                other → error ("etaExpand: variable not found:" ++  nicer name g)
        cleanVarType g novar = novar



--- a bit simpler than isSimple, as code duplication is avoided (no lambdas)
isMeager :: Expr -> Bool
isMeager (App a b _)     = isMeager a && isMeager b
isMeager (Ifte a b c _)  = isMeager a && isMeager b && isMeager c
isMeager (Ann {ex})      = isMeager ex
isMeager (Vbl {pos})     = true
isMeager (Lit {pos})     = true
isMeager (Con {pos})     = true
isMeager _               = false

--- Check if a CAF is simple, which is the case if it contains only
---  - literals
---  - constructors
---  - native functions or CAFs
simpleCAF :: Global -> Bool -> Expr -> Bool
simpleCAF g local Vbl{pos, name, typ}         = case g.findit name of
    Just (sym@SymV{}) 
        | Just _ <- sym.nativ   = true
        | otherwise             = local || sym.depth == 0
    other                       = false
simpleCAF g local Con{pos, name, typ}         = true
simpleCAF g local App{fun, arg, typ}          = simpleCAF g local fun && simpleCAF g local arg
simpleCAF g local Lit{pos, kind, value, typ}  = true
simpleCAF g local Let{env, ex, typ}           = false
simpleCAF g local Lam{pat, ex, typ}           = true
simpleCAF g local Ifte{cnd, thn, els, typ}    = simpleCAF g local cnd 
                                            && simpleCAF g local thn
                                            && simpleCAF g local els
simpleCAF g local Mem{ex, member, typ}        = false     -- should not happen here
simpleCAF g local Case{ckind, ex, alts, typ}  = false 
                                          -- simpleCAF g ex && all (simpleCAF g . _.ex) alts
simpleCAF g local Ann{ex, typ}                = simpleCAF g local ex


{--
    tell if an expression is just a literal, variable or constructor name
 -}
isAtomic Vbl {} = true
isAtomic Lit {} = true
isAtomic Con {} = true
isAtomic _      = false


--- true iff the expression is a guard case
isCaseWhen (Case CWhen _ _ _) = true
isCaseWhen _ = false

{--
    > caseComplete g (Case ...)

    Check if a normal @case@ statement covers all cases.
    This is true if the patterns of the alternatives that 
    have no 'openCaseWhen' expression are complete.

    If this is itself a 'CWhen' @case@, the result is the same as
    for 'openCaseWhen'.
 
-}
caseComplete g x
    | Case{ckind, ex, alts, typ} <- x = case ckind of
        CWhen -> openCaseWhen g x
        _ -> case partitioned (isNothing . openCaseWhen g . CAlt.ex) alts of
                            -- use of head justified because there are no case
                            -- statements without alternatives
            ([], oalts) -> openCaseWhen g . CAlt.ex . head $ oalts
            (ralts, _)  -> maybe Nothing (Just . Right) (patsComplete g (map CAlt.pat ralts))
    | otherwise = Nothing   -- not a case?  


{--
 * checks whether an expression is a case expression made from a guard (CWhen)
 * that has no trailing otherwise or irrefutable pattern match
 * If so, returns the expression or pattern that could cause the CaseWhen to fall through
 -}
openCaseWhen :: Global -> Expr -> Maybe (Either Expr Pattern)
openCaseWhen g (Case CWhen _ [alt1, alt2] _) = openCaseWhen g alt2.ex
openCaseWhen g (e@Case CWhen x [alt1] _)
    |  caseOtherwise g e              = Nothing           -- can't fall through
    |  isPTrue alt1.pat, !(isXTrue x) = Just (Left x)
    |  patternRefutable g alt1.pat    = Just (Right alt1.pat)
    |  otherwise = openCaseWhen g alt1.ex
openCaseWhen g (Let {ex}) = openCaseWhen g ex
openCaseWhen _ _ = Nothing

{--
 * tells if this is the pattern "true"
 -}
isPTrue (PLit {kind=LBool, value="true"}) = true
isPTrue p | p.{pat?} = isPTrue p.pat
isPTrue _ = false


{--
 * tells if this is the constant "true"
 -}
isXTrue (Lit {kind=LBool, value="true"}) = true
isXTrue (Vbl {name = VName p "otherwise"}) | pPreludeBase == p = true
isXTrue _ = false


{--
 * tells us if this is the "otherwise" case
 *  > case true of true -> notopencase
 -}
caseOtherwise g (Case CWhen x [alt] _)
    | isCaseWhen alt.ex = false
    | isXTrue x && isPTrue alt.pat = true
    | otherwise = !(patternRefutable g alt.pat)
caseOtherwise _ _ = false
