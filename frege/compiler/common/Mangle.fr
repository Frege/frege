--- This is an undocumented module
module frege.compiler.common.Mangle where

import Data.TreeMap as TM
import Data.Tuples()
import Compiler.common.Binders( jtvArray )


{--
 * Java keywords (along with substitutions)
 * as specified in the Java Language Specification, Version 3.0, page 21
 * and, in addition, "true", "false", and "null"
 *
 * It is, for instance, possible to name a frege item _int_, though
 * in the generated java code, this will appear as \__int_.
 *
 -}
!javakeywords = TM.fromList  [(kw, "_"++kw) | kw <- [
    "abstract",     "continue",     "for",          "new",          "switch",
    "assert",       "default",      "if",           "package",      "synchronized",
    "boolean",      "do",           "goto",         "private",      "this",
    "break",        "double",       "implements",   "protected",    "then",
    "byte",         "else",         "import",       "public",       "throws",
    "case",         "enum",         "instanceof",   "return",       "transient",
    "catch",        "extends",      "int",          "short",        "try",
    "char",         "final",        "interface",    "static",       "void",
    "class",        "finally",      "long",         "strictfp",     "volatile",
    "const",        "float",        "native",       "super",        "while",
    -- also the literals, as variables cannot be named like so
    "true",         "false",        "null",
    -- likewise assert and main, in order to avoid confusion
    "assert",       "main",
    -- forgot throw
    "throw"
    ]]



repljavakws s = case TreeMap.lookupS javakeywords s of
    Just k  -> k
    Nothing -> s



--- replacement for certain graphic characters âˆ€
!graphReplacements = TM.fromList . map (fmap unpacked) $ [
    ('Â°', "_deg"),  ('^', "_caret"),    ('!', "_excl"), ('Â²', "_two"),  ('Â³', "_three"),
    ('Â§', "_par"),  ('%', "_pct"),      ('&', "_amp"),  ('/', "_div"),  ('=', "_eq"),
    ('?', "_qm"),   ('\\', "_back"),     ('*', "_star"), ('+', "_plus"), ('~', "_tilde"),
    ('\'', "_tick"),('#', "_num"),      ('-', "_minus"),('.', "_dot"),  (':', "_colon"),   -- '#
    (',', "c"),(';', "_semi"),     ('@', "_at"),   ('|', "_bar"),  ('<', "_lt"),
    ('>', "_gt"),   ('â€¢', "_bullet"),   ('Â«', "_lang"), ('Â»', "_rang"), ('Â¦', "_bar2"),
    ('Â¿', "_iqm"),  ('â‚¬', "_euro"),     ('Â£', "_pound"),('Â¥', "_yen"),  ('Â¢', "_cent"),
    ('Â¬', "_not"),  ('Â±', "_plusminus"),('Â¡', "_iexcl"),('Â¤', "_money"),('Â©', "_copy"),
    ('Â®', "_trade"),('Â¹', "_one"),      ('$', "_dollar"),
    ('[', "_lbrack"), (']', "_rbrack"), ('(', "l_"), (')', "_r")]


--- look in 'graphReplacements' for character translation, if not there, use ordinal number
replaceGraphic c = case graphReplacements.lookup c of
    Just s ->  s
    Nothing -> unpacked (String.format "_%d" (ord c))


{--
    encode certain special characters so that the result is a
    valid java identifier
 -}
mangled :: String -> String
mangled s | s.startsWith "(," = "Tuple" ++ show (length s - 2 + 1)
mangled "()" = "Unit"
mangled "[]" = "List"
mangled ":"  = "Cons"
mangled "->" = "Function"
mangled s = (repljavakws . packed . loop . unpacked) s
    where
        loop (a:xs)
            | a.isLetterOrDigit
              || a == '$' || a == '_' = a : loop xs
            | (b:ys) <- xs,
              Char.isSurrogatePair a b,
              cp <- Char.toCodePoint a b,
              Char.isLetter cp || Char.isDigit cp = a:b:loop ys
            | otherwise = (replaceGraphic a) ++ loop xs
        loop [] = []

{--
    Replace lower case latin single letter type variables with 
    matheatical capitals.
    
    This will make Java type annotations look more familiar, like:
    
    > class Functor f where fmap :: (a -> b) -> f a -> f b
    
    would read in Java
    
    > interface Functor<ð“• extends Kind.U<ð“•,?> {
    >    public<ð“, ð“‘> Kind.U<ð“•, ð“‘> fmap(Func.U<ð“, ð“‘> f, Kind.U<ð“•, ð“> v)
    > }  
-}
mangleJtv name
    | name ~ '^[a-z]$' = elemAt jtvArray (ord (name.charAt 0) - ord 'a')
    | name ~ '[a-z]'   = "ð“£" ++ name    -- prepend ð“£ before latin name
    | otherwise        = name           -- not latin, leave as is


private !alphabet = [
    (1_000_000_000, 'T', 100_000_000, 'R'),
    (  500_000_000, 'S', 100_000_000, 'R'),
    (100_000_000, 'R', 10_000_000, 'O'),
    ( 50_000_000, 'P', 10_000_000, 'O'),
    (10_000_000, 'O', 1_000_000, 'K'),
    ( 5_000_000, 'N', 1_000_000, 'K'),
    (1000000, 'K', 100000, 'H'),
    ( 500000, 'J', 100000, 'H'),
    (100000, 'H', 10000, 'F'),
    ( 50000, 'G', 10000, 'F'),
    (10000, 'F', 1000, 'M'),
    ( 5000, 'E', 1000, 'M'), 
    (1000, 'M', 100, 'C'),
    ( 500, 'D', 100, 'C'),
    ( 100, 'C',  10, 'X'),
    (  50, 'L',  10, 'X'),
    (  10, 'X',   1, 'I'),
    (   5, 'V',   1, 'I'),
    (   1, 'I',   0, 'Z')
    ]

!romNums = arrayCache (\n arr -> packed (romanNumber n)) 100
romanUpper x
    | x >= 0, x < 100 = romNums `elemAt` x
    | otherwise       = packed (romanNumber x)

romanLower x = (romanUpper x).toLowerCase

romanNumber n 
    | n == minBound = '-' : 'T' : rom alphabet (abs (n + 1_000_000_000))
    | n < 0     = '-' : rom alphabet (abs n)
    | n == 0    = ['Z']
    | otherwise = rom alphabet n
    where
        rom :: [(Int, Char, Int, Char)] -> Int -> [Char]
        rom (alpha@(u, uc, d, dc):xs) n
            | n >= u = uc : rom alpha (n-u)
            | n >= (u-d) = dc : uc : rom xs (n-u+d)
            | otherwise  = rom xs n
        rom [] 0 = []
        rom xx y = error ("rom " ++ show xx ++ " " ++ show y) 
