--- Handling of the symbol table.
--- There are only two operations: 'enter' and 'changeSym'
module frege.compiler.common.SymbolTable where 
        -- generated by Splitter
import  frege.Prelude  hiding(error, print, println, break, <+>)
import  frege.data.TreeMap as TM(TreeMap, lookup, each, insert, union, including, contains, keys, values, fromKeys)
import  frege.lib.PP(fill, break, pretty, text, nest, msgdoc, <+>, <>, DOCUMENT)
import  frege.compiler.common.Lens (preview, set)
import  frege.compiler.enums.Flags
import  frege.compiler.enums.SymState
import  frege.compiler.enums.Visibility
import  frege.compiler.types.Positions
import  frege.compiler.types.Packs
import  frege.compiler.types.QNames
import  frege.compiler.types.Types
import  frege.compiler.types.Symbols
import  frege.compiler.types.Global  as  G
import  frege.compiler.classes.Nice(Nice)
import  frege.compiler.common.Annotate(lit)
import  frege.compiler.common.Errors  as  E()
import  frege.compiler.instances.Nicer


-- "private" crashes fregedoc
protected data InsUpd = DoInsert | DoUpdate
protected derive Show InsUpd


private enterWith :: InsUpd -> Pack -> String -> Symbol -> StG ()
private enterWith insupd p n s = do
        g <- getST        -- give me the state
        case g.packages.lookup p of
            Just tab -> do
                    ntab <- doInsUpd tab n s
                    changeST Global.{packages <- insert p ntab}
            Nothing  -> do
                    let sp = g.unpack p
                    E.error s.pos (fill ([text "module", text "`" <> text sp <> text "`"]
                                                 ++  break "does not exist."))
    where
    doInsUpd = case insupd of
        DoInsert -> insertSym id
        DoUpdate -> updateSym id



{-- insert symbol, but make sure it does not exist yet -}
private insertSym :: (sym -> Symbol) -> TreeMap String sym -> String -> sym -> StG (TreeMap String sym)
private insertSym toSymbol tab key value = case tab.lookupS key of
    Nothing -> stio (tab.insertS key value)
    Just old  -> do
        g <- getST
        let on = (toSymbol old).nice g
            qn = (toSymbol value).nice g
        case toSymbol value of
            SymbolT.V SymV{pos, name} -> E.error pos (msgdoc("duplicate function or pattern binding for `"
                            ++ name.nice g ++ "`, already bound on line "
                            ++ show (toSymbol old).pos))
            _          -> E.error (toSymbol value).pos (msgdoc("redefinition of " ++ on ++ " with " ++ qn
                                    ++ " introduced on line " ++ show (toSymbol old).pos))
        stio (tab.insertS key value)


{-- update symbol, but make sure it does already exist -}
private updateSym :: (sym -> Symbol) -> TreeMap String sym -> String -> sym -> StG (TreeMap String sym)
private updateSym toSymbol tab key value = case tab.lookupS key of
    Just _   -> stio (tab.insert key value)
    Nothing  -> do
        g <- getST
        let qn = (toSymbol value).nice g
        E.error (toSymbol value).pos (fill (break ("cannot update " ++ qn ++ "  " ++ show (keys tab))))
        stio (tab.insert key value)

{--
 - Assume a Symbol is SymV because it's name is Local
 -
 - It is caller's responsibility to ensure that.
 -}
private toSymVBecauseLocal :: Symbol -> SymV Global
private toSymVBecauseLocal (SymbolT.V symv) = symv
private toSymVBecauseLocal _ = Prelude.error "thisIsSymVBecauseLocal: not SymV"


{--
 * Enter symbol into appropriate symbol table.

 * It is an error if prerequisites like packages or namespaces are not there.

 * It is an error if the symbol is already there, except in the following cases:

 - a symbol hides a symbolic link that points in another package
 - a non native variable finds that an annotation is already there
 - an annotation finds that a non native variable is already there
 -}
enter :: Symbol -> StG ()
enter sym = case sym of
    SymbolT.L syml -> do
        g <- getST
        let asy = g.find syml.alias
        case asy of
            Nothing | g.our syml.alias -> do
                let sa  = sym.nicer g
                E.fatal syml.pos (fill (break ("can't enter " ++ sa ++ " for unknown target")))
            sonst -> enterOrUpdate
    _ -> enterOrUpdate
    where
        enterOrUpdate =
            case sym.name of
              Local{uid} -> do
                g <- getST
                uid <- if uid > 0 then return uid else uniqid
                let symv = toSymVBecauseLocal sym
                case g.find sym.name of
                    Nothing
                        | uid == symv.sid-> do
                            E.logmsg TRACE3 symv.pos (text("enterLocal: " ++
                                show symv.sid ++
                                " " ++ sym.nice g ++ " :: " ++ symv.typ.nice g ++
                                ", " ++ show symv.state))
                            changeST Global.{locals <- TreeMap.insertkvI uid symv}
                        | otherwise = E.fatal symv.pos (text ("enterLocal: uid=" ++
                            show uid ++ ", sid=" ++ show symv.sid ++ " for " ++ show sym.name))
                    Just that -> E.error symv.pos (text ("already entered: " ++ nice symv g ++ " with uid " ++ show uid))
              _ -> do
                g <- getST
                case g.find sym.name of
                    Nothing -> enterByName sym
                    Just that
                        | SymbolT.L SymL{alias=thatAlias} <- that, SymbolT.L SymL{alias=symAlias} <- sym, thatAlias == symAlias = pure ()  -- do nothing
                        | SymbolT.L SymL{alias} <- that, alias.getpack != sym.name.getpack = do
                                E.warn sym.pos (fill (break("hiding previously (line " ++ show that.pos
                                    ++ ") imported "
                                    ++ that.nice g ++ " through " ++ sym.nice g)))
                                changeSym sym
                        | otherwise = enterByName sym   -- error message follows


changeSym :: Symbol -> StG ()
changeSym = insUpdSymByName DoUpdate


private enterByName :: Symbol -> StG ()
private enterByName = insUpdSymByName DoInsert


private insUpdSymByName :: InsUpd -> Symbol -> StG ()
private insUpdSymByName insupd sym | sym.sid == 0 = do
    u <- uniqid
    insUpdSymByName insupd $ set SymbolT._sid u sym
private insUpdSymByName insupd sym = do
    g <- getST
    E.logmsg TRACE3 sym.pos $ logMessage g
    case sym.name of
        TName p b -> enterWith insupd p sym.name.key sym
        VName p b -> enterWith insupd p sym.name.key sym
        MName t b -> do
            g <- getST
            case g.findit t of
                Nothing -> do
                    let qn = t.nice g
                    E.error sym.pos $ msgdoc $ "namespace `" ++ qn ++ "` does not exist"
                Just (SymbolT.T typt) -> do
                    env <- enterSym insupd id typt.env sym.name.key sym
                    enterWith DoUpdate t.pack t.key $ SymbolT.T typt.{env}
                Just typ -> case preview SymbolT._meth typ of
                    Just typMeth -> case SymMeth.fromSymbol sym of
                        Just ameth -> do
                            meth <- enterSym insupd SymMeth.toSymbol typMeth sym.name.key ameth
                            enterWith DoUpdate t.pack t.key $ set SymbolT._meth meth typ
                        Nothing -> E.error sym.pos $ msgdoc $ sym.nice g ++ " cannot be a member of " ++ typ.nice g
                    Nothing -> E.fatal sym.pos $ msgdoc $ "no environment: " ++ t.nice g
        Local uid _ -> enterLocal insupd sym uid
  where
    logMessage g = fill $ case insupd of
        DoUpdate ->
            [ text $ "insUpdSymByName " ++ show insupd
            , lit sym.sid
            , text $ concat
                [ sym.nice g
                , " :: "
                , maybe "" (\typ -> typ.nice g) $ preview SymbolT._typ sym
                , ", "
                , maybe "" (\SymV{state} -> show state) $ preview SymbolT._V sym
                ]]
        DoInsert -> break $ unwords $
            [ "insUpdSymByName"
            , show insupd
            , sym.nice g
            , show sym.sid
            ] ++
            case sym of
                SymbolT.V SymV{typ} | not (isPSigma typ) -> ["::", typ.nicer g]
                _ -> []

    enterSym :: InsUpd -> (sym -> Symbol) -> TreeMap String sym -> String -> sym -> StG (TreeMap String sym)
    enterSym DoInsert = insertSym
    enterSym DoUpdate = updateSym


private enterLocal :: InsUpd -> Symbol -> Int -> StG ()
private enterLocal DoInsert sym _ = do
    g <- getST
    E.fatal sym.pos (text ("local passed to enterbyname " ++ nice sym g))
private enterLocal DoUpdate sym uid = do
    let symv = toSymVBecauseLocal sym
    when (symv.sid != uid) do
        E.fatal symv.pos (text("changeSym: name =" ++ show symv.name
            ++ ", sid=" ++ show symv.sid))
    changeST Global.{locals <- TreeMap.updatekvI uid symv}


{-- create a symbolic link to given qname -}
linkq :: QName -> Symbol -> StG ()
linkq from sym = linkqv from sym sym.vis


--- create a symbolic link to a given 'Symbol' with a given 'Visibility'
linkqv :: QName -> Symbol -> Visibility -> StG ()
linkqv from sym vis = linkqvp from sym vis sym.pos


-- create a symbolic link to a given 'Symbol' with a given 'Visibility' and 'Position'
linkqvp :: QName -> Symbol -> Visibility -> Position -> StG ()
linkqvp from sym vis pos = do
    g <- getST
    E.logmsg TRACE3 pos (text ("`" ++ from.nice g ++ "` link to " ++ sym.nice g))
    enter $ SymbolT.L
          (SymL {sid=0, pos=pos, vis, -- doc=Nothing,
                    name=from, alias=sym.name})

