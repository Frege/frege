--- Handling of the symbol table.
--- There are only two operations: 'enter' and 'changeSym'
module frege.compiler.common.SymbolTable where 
        -- generated by Splitter
import  frege.Prelude  hiding(error, print, println, break, <+>)
import  frege.data.TreeMap as TM(TreeMap, lookup, each, insert, union, including, contains, keys, values, fromKeys)
import  frege.lib.PP(fill, break, pretty, text, nest, msgdoc, <+>, <>, DOCUMENT)
import  frege.compiler.common.Lens (preview, set, view)
import  frege.compiler.enums.Flags
import  frege.compiler.enums.SymState
import  frege.compiler.enums.Visibility
import  frege.compiler.types.Positions
import  frege.compiler.types.Packs
import  frege.compiler.types.QNames
import  frege.compiler.types.Types
import  frege.compiler.types.Symbols
import  frege.compiler.types.Global  as  G
import  frege.compiler.classes.Nice(Nice)
import  frege.compiler.common.Annotate(lit)
import  frege.compiler.common.Errors  as  E()
import  frege.compiler.instances.Nicer

private insertGlobal p n s = enterWith (insertSym id) p n s


private updateGlobal p n s = enterWith (updateSym id) p n s


private enterWith insupd p n s = do
        g <- getST        -- give me the state
        case g.packages.lookup p of
            Just tab -> do
                    ntab <- insupd tab n s
                    changeST Global.{packages <- insert p ntab}
            Nothing  -> do
                    let sp = g.unpack p
                    E.error (view SymbolT.pos s) (fill ([text "module", text "`" <> text sp <> text "`"]
                                                 ++  break "does not exist."))


{-- insert symbol, but make sure it does not exist yet -}
private insertSym :: (sym -> Symbol) -> TreeMap String sym -> String -> sym -> StG (TreeMap String sym)
private insertSym toSymbol tab key value = case tab.lookupS key of
    Nothing -> stio (tab.insertS key value)
    Just old  -> do
        g <- getST
        let on = (toSymbol old).nice g
            qn = (toSymbol value).nice g
        case toSymbol value of
            SymbolT.V SymV{pos, name} -> E.error pos (msgdoc("duplicate function or pattern binding for `"
                            ++ name.nice g ++ "`, already bound on line "
                            ++ show (view SymbolT.pos (toSymbol old))))
            _          -> E.error (view SymbolT.pos (toSymbol value)) (msgdoc("redefinition of " ++ on ++ " with " ++ qn
                                    ++ " introduced on line " ++ show (view SymbolT.pos (toSymbol old))))
        stio (tab.insertS key value)


{-- update symbol, but make sure it does already exist -}
private updateSym :: (sym -> Symbol) -> TreeMap String sym -> String -> sym -> StG (TreeMap String sym)
private updateSym toSymbol tab key value = case tab.lookupS key of
    Just _   -> stio (tab.insert key value)
    Nothing  -> do
        g <- getST
        let qn = (toSymbol value).nice g
        E.error (view SymbolT.pos (toSymbol value)) (fill (break ("cannot update " ++ qn ++ "  " ++ show (keys tab))))
        stio (tab.insert key value)


{--
 * Enter symbol into appropriate symbol table.

 * It is an error if prerequisites like packages or namespaces are not there.

 * It is an error if the symbol is already there, except in the following cases:

 - a symbol hides a symbolic link that points in another package
 - a non native variable finds that an annotation is already there
 - an annotation finds that a non native variable is already there
 -}
enter :: Symbol -> StG ()
enter sym = case sym of
    SymbolT.L syml -> do
        g <- getST
        let asy = g.find syml.alias
        case asy of
            Nothing | g.our syml.alias -> do
                let sa  = sym.nicer g
                E.fatal syml.pos (fill (break ("can't enter " ++ sa ++ " for unknown target")))
            sonst -> enterOrUpdate
    _ -> enterOrUpdate
    where
        enterOrUpdate =
            let name = view SymbolT.name sym
            in
            case name of
              Local{uid} -> do
                g <- getST
                uid <- if uid > 0 then return uid else uniqid
                let symv = case sym of { SymbolT.V x -> x; }
                case g.find name of
                    Nothing
                        | uid == symv.sid-> do
                            E.logmsg TRACE3 symv.pos (text("enterLocal: " ++
                                show symv.sid ++
                                " " ++ sym.nice g ++ " :: " ++ symv.typ.nice g ++
                                ", " ++ show symv.state))
                            changeST Global.{locals <- TreeMap.insertkvI uid symv}
                        | otherwise = E.fatal symv.pos (text ("enterLocal: uid=" ++
                            show uid ++ ", sid=" ++ show symv.sid ++ " for " ++ show name))
                    Just that -> E.error symv.pos (text ("already entered: " ++ nice symv g ++ " with uid " ++ show uid))
              _ -> do
                g <- getST
                case g.find name of
                    Nothing -> enterByName sym
                    Just that
                        | SymbolT.L SymL{alias=thatAlias} <- that, SymbolT.L SymL{alias=symAlias} <- sym, thatAlias == symAlias = pure ()  -- do nothing
                        | SymbolT.L SymL{alias} <- that, alias.getpack != name.getpack = do
                                E.warn (view SymbolT.pos sym) (fill (break("hiding previously (line " ++ show (view SymbolT.pos that)
                                    ++ ") imported "
                                    ++ that.nice g ++ " through " ++ sym.nice g)))
                                changeSym sym
                        | otherwise = enterByName sym   -- error message follows


changeSym :: Symbol ->  StG ()
changeSym sym | view SymbolT.sid sym == 0 = do
        u <- uniqid
        changeSym $ set SymbolT.sid u sym
changeSym sym = do
        g <- getST
        E.logmsg TRACE3 (view SymbolT.pos sym) (fill [text "changeSym", lit (view SymbolT.sid sym), text (sym.nice g ++ " :: " ++
            (maybe "" (\typ -> typ.nice g) $ preview SymbolT.typ sym) ++ ", " ++
            (case sym of { SymbolT.V SymV{state} -> show state; _ -> "" }))])
        let name = view SymbolT.name sym
        case name of
            TName p b -> updateGlobal p name.key sym
            VName p b -> updateGlobal p name.key sym
            MName t b -> do
                g <- getST
                let tsy = g.findit t
                case tsy of
                    Nothing -> do
                        let qn =  t.nice g
                        E.error (view SymbolT.pos sym) (fill ([text "namespace", text "`" <> text qn <> text "`"] ++ break "does not exist"))
                    Just (SymbolT.I typi) -> case SymMeth.fromSymbol sym of
                        Just ameth -> do
                            meth <- updateSym SymMeth.toSymbol typi.meth name.key ameth
                            updateGlobal t.pack t.key $ SymbolT.I typi.{meth}
                    Just typ -> case preview SymbolT.env typ of
                        Just typEnv -> do
                            env <- updateSym id typEnv name.key sym
                            updateGlobal t.pack t.key (set SymbolT.env env typ)
                        Nothing -> E.fatal (view SymbolT.pos sym) (text "no environment:" <+> text (t.nice g))
            Local uid s -> do
                --  g <- getST
                let symv = case sym of { SymbolT.V x -> x; }
                when (symv.sid != uid) do
                    E.fatal symv.pos (text("changeSym: name =" ++ show name
                        ++ ", sid=" ++ show symv.sid))
                changeST Global.{locals <- TreeMap.updatekvI uid symv}


private enterByName :: Symbol -> StG ()
private enterByName sym | view SymbolT.sid sym == 0 = do
        u <- uniqid
        enterByName $ set SymbolT.sid u sym
private enterByName sym = do
    g <- getST
    E.logmsg TRACE3 (view SymbolT.pos sym) (fill (break ("enterByName " ++ sym.nice g ++ " " ++ show (view SymbolT.sid sym) ++ " "
        ++ (case sym of
              SymbolT.V symv | not (isPSigma symv.typ) -> " :: " ++ symv.typ.nicer g
              _ -> ""))))
    let name = view SymbolT.name sym
        pos = view SymbolT.pos sym
    case name of
        TName p b -> insertGlobal p name.key sym
        VName p b -> insertGlobal p name.key sym
        MName t b -> do
            g <- getST
            let tsy = g.findit t
            case tsy of
                Nothing -> do
                    let qn = t.nice g
                    E.error pos (msgdoc("namespace `" ++ qn ++ "` does not exist"))
                Just (SymbolT.I typi) -> case SymMeth.fromSymbol sym of
                    Just ameth -> do
                        meth <- insertSym SymMeth.toSymbol typi.meth name.key ameth
                        updateGlobal t.pack t.key $ SymbolT.I typi.{meth}
                Just typ -> case preview SymbolT.env typ of
                    Just typEnv -> do
                        env <- insertSym id typEnv name.key sym
                        updateGlobal t.pack t.key (set SymbolT.env env typ)
                    Nothing -> E.fatal pos (msgdoc ("no environment: " ++ t.nice g))
        Local {} -> do
            g <- getST
            E.fatal pos (text ("local passed to enterbyname " ++ nice sym g))


{-- create a symbolic link to given qname -}
linkq :: QName -> Symbol -> StG ()
linkq from sym = linkqv from sym (view SymbolT.vis sym)


--- create a symbolic link to a given 'Symbol' with a given 'Visibility'
linkqv :: QName -> Symbol -> Visibility -> StG ()
linkqv from sym vis = linkqvp from sym vis (view SymbolT.pos sym)


-- create a symbolic link to a given 'Symbol' with a given 'Visibility' and 'Position'
linkqvp :: QName -> Symbol -> Visibility -> Position -> StG ()
linkqvp from sym vis pos = do
    g <- getST
    E.logmsg TRACE3 pos (text ("`" ++ from.nice g ++ "` link to " ++ sym.nice g))
    enter $ SymbolT.L
          (SymL {sid=0, pos=pos, vis, -- doc=Nothing,
                    name=from, alias=view SymbolT.name sym})

