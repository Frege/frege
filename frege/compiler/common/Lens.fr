{--
   The code here is taken and modified from Haskell's "lens" packages.

   lens:
   Copyright 2012-2016 Edward Kmett
   License BSD-2-Clause
 -}
module frege.compiler.common.Lens where

import  frege.data.Monoid (First)
import  frege.data.wrapper.Boolean (All, Any)
import  frege.data.wrapper.Const (Const)
import  frege.data.wrapper.Identity (Identity)

-- note: currently the compiler fails to infer the correct kinds of @f@
-- when incrementally compiling, so you have to write type annotations without the aliases
-- see GutHub issue #383

type ASetter s t a b = (a -> Identity b) -> s -> Identity t
type ASetter' s a = ASetter s s a a
type Getting r s a = (a -> Const r a) -> s -> Const r s
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
type Lens' s a = Lens s s a a
type LensLike f s t a b = (a -> f b) -> s -> f t
type LensLike' f s a = LensLike f s s a a
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
type Traversal' s a = Traversal s s a a

-- getters

-- dealing with Lenses

view :: Getting a s a -> (s -> a)
view l = Const.get . (l Const)

views :: Getting r s a -> (a -> r) -> (s -> r)
views l f = Const.get . l (Const . f)

-- dealing with optional fields (Traversals)

-- internal note: also used in place of @is@ of @Prism@ because we don't have @Prism@.
has :: Getting Any s a -> s -> Bool
has l = Any.unwrap . views l (\_ -> Any True)

-- internal note: also used in place of @isn't@ of @Prism@ because we don't have @Prism@.
hasn't :: Getting All s a -> s -> Bool
hasn't l = All.unwrap . views l (\_ -> All False)

preview :: Getting (First a) s a -> s -> Maybe a
preview l = First.getFirst . views l (First . Just)

-- setters

over :: ASetter s t a b -> (a -> b) -> s -> t
over l f = Identity.run . l (Identity . f)

set :: ASetter s t a b -> b -> s -> t
set l b = Identity.run . l (\_ -> Identity b)

-- some concrete prisms
-- defined as @Traversal@ because we don't have @Prism@

_Left :: Traversal (Either a c) (Either b c) a b
_Left f (Left x) = Left <$> f x
_Left _ (Right x) = pure (Right x)

_Right :: Traversal (Either c a) (Either c b) a b
_Right f (Right x) = Right <$> f x
_Right _ (Left x) = pure (Left x)

_Just :: Traversal (Maybe a) (Maybe b) a b
_Just f (Just x) = Just <$> f x
_Just _ Nothing = pure Nothing

-- identical to @flip (const . pure)@ but added for consistency
_Nothing :: Traversal' (Maybe a) ()
_Nothing _ Nothing = pure Nothing
_Nothing _ (Just x) = pure (Just x)

--- warning: this function is partial
-- TODO remove this
unsafePartialViewMsg :: String -> Getting (First a) s a -> s -> a
unsafePartialViewMsg msg l = fromMaybe (error $ "unsafePartialViewMsg: " ++ msg) . preview l
