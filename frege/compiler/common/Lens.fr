--- The code here is taken and modified from Haskell's "profunctors" and "lens" packages.
---
--- profunctors:
--- Copyright 2011-2015 Edward Kmett
--- License BSD-3-Clause
---
--- lens:
--- Copyright 2012-2016 Edward Kmett
--- License BSD-2-Clause
module frege.compiler.common.Lens where

import  frege.data.Monoid (First)
import  frege.data.wrapper.Boolean (All, Any)
import  frege.data.wrapper.Const (Const)
import  frege.data.wrapper.Identity (Identity)

class Profunctor p where
    dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
    lmap :: (a -> b) -> p b c -> p a c
    rmap :: (b -> c) -> p a b -> p a c

instance Profunctor (->) where
    dimap ab cd bc = cd . bc . ab
    lmap = flip (.)
    rmap = (.)

class Profunctor p => Choice p where
    left' :: p a b -> p (Either a c) (Either b c)
    right' :: p a b -> p (Either c a) (Either c b)

instance Choice (->) where
    left' ab (Left a) = Left (ab a)
    left' _ (Right c) = Right c
    right' = fmap

-- note: currently the compiler fails to infer the correct kinds of @f@
-- when incrementally compiling, so you have to write type annotations without the aliases

type APrism s t a b = Market a b a (Identity b) -> Market a b s (Identity t)
type APrism' s a = APrism s s a a
type ASetter s t a b = (a -> Identity b) -> s -> Identity t
type ASetter' s a = ASetter s s a a
type Getting r s a = (a -> Const r a) -> s -> Const r s
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
type Lens' s a = Lens s s a a
type LensLike f s t a b = (a -> f b) -> s -> f t
type LensLike' f s a = LensLike f s s a a
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
type Prism' s a = Prism s s a a
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
type Traversal' s a = Traversal s s a a

data Market a b s t = Market (b -> t) (s -> Either t a)

instance Functor (Market a b s) where
    fmap f (Market bt seta) = Market (f . bt) (either (Left . f) Right . seta)

instance Profunctor (Market a b) where
    dimap f g (Market bt seta) = Market (g . bt) (either (Left . g) Right . seta . f)
    lmap f (Market bt seta) = Market bt (seta . f)
    rmap f (Market bt seta) = Market (f . bt) (either (Left . f) Right . seta)

instance Choice (Market a b) where
    left' (Market bt seta) = Market (Left . bt) $ \sc -> case sc of
        Left s -> case seta s of
            Left t -> Left (Left t)
            Right a -> Right a
        Right c -> Left (Right c)
    right' (Market bt seta) = Market (Right . bt) $ \cs -> case cs of
        Left c -> Left (Left c)
        Right s -> case seta s of
            Left t -> Left (Right t)
            Right a -> Right a

type Market' a = Market a a

-- getters

-- dealing with Lenses

view :: Getting a s a -> (s -> a)
view l = Const.get . (l Const)

views :: Getting r s a -> (a -> r) -> (s -> r)
views l f = Const.get . l (Const . f)

-- dealing with optional fields (Traversals)

has :: Getting Any s a -> s -> Bool
has l = Any.unwrap . views l (\_ -> Any True)

hasn't :: Getting All s a -> s -> Bool
hasn't l = All.unwrap . views l (\_ -> All False)

preview :: Getting (First a) s a -> s -> Maybe a
preview l = First.getFirst . views l (First . Just)

-- dealing with prisms

prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
prism bt seta = dimap seta (either pure (fmap bt)) . right'

prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b
prism' bs sma = prism bs (\s -> maybe (Left s) Right (sma s))

withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r
withPrism k f = case k (Market Identity Right) of
    Market bt seta -> f (Identity.run . bt) (either (Left . Identity.run) Right . seta)

is :: APrism s t a b -> s -> Bool
is k = not . isn't k

isn't :: APrism s t a b -> s -> Bool
isn't k s = either (\_ -> True) (\_ -> False) (matching k s)

matching :: APrism s t a b -> s -> Either t a
matching k = withPrism k $ \_ seta -> seta

-- setters

over :: ASetter s t a b -> (a -> b) -> s -> t
over l f = Identity.run . l (Identity . f)

set :: ASetter s t a b -> b -> s -> t
set l b = Identity.run . l (\_ -> Identity b)

--- warning: this function is partial
-- TODO eliminate the uses of these functions
unsafePartialView :: Getting (First a) s a -> s -> a
unsafePartialView l s = unJust $ preview l s
