--- Coroutine as layed out in M. Blazevic, “Coroutine pipelines,” The Monad Reader, vol. 19, pp. 29–50, 2011.

module frege.control.pipe.Coroutine where

import Control.monad.trans.MonadTrans

--- Coroutines are build for a to-be-suspended functor @suspendFun@, a monad @m@, and a result type @res@.
data Coroutine suspendFun m res = Coroutine
  { resume :: m (Either (suspendFun (Coroutine suspendFun m res)) res)
  }

--- Monad instance for the Coroutine, generic in the result type
instance (Functor suspendFun, Monad m) => Monad (Coroutine suspendFun m) where
  pure x = Coroutine $ pure $ Right x
  co >>= f =
    Coroutine( Coroutine.resume co >>= either (pure . Left . fmap (>>= f)) (Coroutine.resume . f))

--- Monad transformer instance that allows to interleave the to-be-suspended functor with effects from a monad over the result type
instance (Functor suspendFun) => MonadTrans (Coroutine suspendFun) where
  lift = Coroutine . liftM Right

suspend :: (Functor suspendFun, Monad m) => suspendFun (Coroutine suspendFun m res) -> Coroutine suspendFun m res
suspend suspendFun = Coroutine $ pure $ Left suspendFun
