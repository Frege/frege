{--
    The idea of creating Producers and Consumers as Coroutines and piping them as shown here
    was added to the Frege project by Thibault Gagnaux as part of his master thesis at the
    University of Applied Sciences and Arts, Northwestern Switzerland.
    Please find his description under https://dierk.github.io/Home/data/ip7_report_final_T.Gagnaux.pdf .

    For usage see tests.qc.ProducerConsumer and examples.ProducerConsumer
-}

module frege.control.pipe.Pipe where

import Control.pipe.Producer (produce, endWith, Producer )
import Control.pipe.Consumer (consume,  Consumer )
import Control.pipe.Coroutine ( Coroutine(resume) )
import Control.monad.trans.MonadTrans ( lift )

{--
    The pipe function hooks a producer to a consumer where the producer yields values
    of type @a@ and the consumer receives them as @Maybe a@. The consumer receives @Nothing@ if
    production failed, e.g. when the producer is exhausted.
    Both, producer and consumer work in the same "context" monad @m@.
    Type unification enforces that they "agree" on a context monad.

    A pair of (producerResult, consumerResult) is returned in the context monad.
-}
pipe :: Monad m => Producer a m x -> Consumer (Maybe a) m y -> m (x, y)
pipe producer consumer = bindM2 go (resume producer) (resume consumer) where  -- when after resume ...
    go (Left (x, prod)) (Left consume) = pipe prod (consume $ Just x)         --   .. both are suspended -> consume and proceed
    go (Right x)        (Right y)      = pure (x, y)                          --   .. both are done      -> finish
    go (Left (x, prod)) (Right y)      = pipe prod $ return y                 --   .. more to do         -> proceed
    go (Right x)        (Left consume) = pipe (return x) (consume Nothing)    --   .. consumer waits but Nothing to do

    bindM2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c
    bindM2 f ma mb = do
        a <- ma
        b <- mb
        f a b
