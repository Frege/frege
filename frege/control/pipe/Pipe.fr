module frege.control.pipe.Pipe where

import Control.pipe.Producer (produce, endWith, Producer )
import Control.pipe.Consumer (consume,  Consumer )
import Control.pipe.Coroutine ( Coroutine(resume) )
import Control.monad.trans.MonadTrans ( lift )

bindM2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c
bindM2 f ma mb = do
    a <- ma
    b <- mb
    f a b

-- todo: consider removing this "partial" function.
pipe :: Monad m => Producer a m x -> Consumer a m y -> m (x, y)
pipe producer consumer = bindM2 go (resume producer) (resume consumer) where
    go (Left (x, prod)) (Left consume) = pipe prod (consume x)
    go (Right x)        (Right y)      = pure (x, y)
    go (Left (x, prod)) (Right y)      = pipe prod $ return y
    go (Right x)        (Left consume) = error "The consumer has nothing to consume."

pipe2 :: Monad m => Producer a m x -> Consumer (Maybe a) m y -> m (x, y)
pipe2 producer consumer = bindM2 go (resume producer) (resume consumer) where  -- when after resume ...
    go (Left (x, prod)) (Left consume) = pipe2 prod (consume $ Just x)         --   .. both are suspended -> consume and proceed
    go (Right x)        (Right y)      = pure (x, y)                           --   .. both are done      -> finish
    go (Left (x, prod)) (Right y)      = pipe2 prod $ return y                 --   .. more to do         -> proceed
    go (Right x)        (Left consume) = pipe2 (return x) (consume Nothing)    --   .. consumer waits but Nothing to do


-- -- -- Usage -- -- -- todo: consider making this a test case

produceInts :: Int -> Int -> Producer Int IO ()
produceInts start end | start == end = do endWith ()
                      | otherwise    = do
                                          produce start
                                          produceInts (start + 1) end

printEachLine :: Show a => Consumer (Maybe a) IO ()
printEachLine = do
  line <- consume
  case line of
    (Just x) -> do
      lift $ println $ show x
      printEachLine
    (Nothing) -> pure ()

main :: IO ()
main =
  do
    _ <- pipe2 (produceInts 0 10) printEachLine
    pure ()
