module Main where

data IR = IR
  { getFoo :: Int, getBar :: Int, getBool :: Bool
  , add2 :: Int -> Int -> Int
  , add3 :: Int -> Int -> Int -> Int
  }

data J = pure native J where
  pure native new "extends" :: IR -> J
  pure native getFoo :: J -> Int
  pure native getBar getBarJava :: J -> Int
  pure native getBool :: J -> Bool
  pure native add2 add :: J -> Int -> Int -> Int
  pure native add3 add :: J -> Int -> Int -> Int -> Int

data CounterImpl s = CounterImpl
  { get :: ST s Int
  , increment :: ST s ()
  }

data Counter = native Counter where
  native new "extends" :: CounterImpl s -> STMutable s Counter
  native get :: Mutable s Counter -> ST s Int
  native increment :: Mutable s Counter -> ST s ()

-- an alternative way to create a new J
pure native newJ "extends" :: IR -> J

main = do
    let j = J.new $ IR
          { getFoo = 123, getBar = 5, getBool = False
          , add2 = \x y -> x + y
          , add3 = \x y z -> x + y + z
          }
    println j.getFoo
    println j.getBar
    println j.getBool
    println $ j.add2 3 4
    println $ j.add3 3 4 5
    let j = newJ $ IR
          { getFoo = 15000, getBar = 80, getBool = True
          , add2 = \x y -> x * y
          , add3 = \x y z -> x * y * z
          }
    println j.getFoo
    println j.getBar
    println j.getBool
    println $ j.add2 3 4
    println $ j.add3 3 4 5

    useCounter

useCounter = do
    counter <- do
        internal <- Ref.new 0
        Counter.new $ CounterImpl
          { get = internal.get
          , increment = internal.modify succ
          }
    println =<< counter.get
    counter.increment
    println =<< counter.get
