module Main where

data IR = IR
  { getFoo :: Int, getBar :: Int, getBool :: Bool
  , add2 :: Int -> Int -> Int
  , add3 :: Int -> Int -> Int -> Int
  }

data J = pure native J where
  pure native new "extends" :: IR -> J
  pure native getFoo :: J -> Int
  pure native getBar getBarJava :: J -> Int
  pure native getBool :: J -> Bool
  pure native add2 add :: J -> Int -> Int -> Int
  pure native add3 add :: J -> Int -> Int -> Int -> Int

-- an alternative way to create a new J
pure native newJ "extends" :: IR -> J

data HelloImpl s = HelloImpl { hello :: ST s () }

data Hello = pure native Hello where
  pure native new "extends" :: HelloImpl s -> Hello
  native hello :: Hello -> ST s ()

main = do
    let j = J.new $ IR
          { getFoo = 123, getBar = 5, getBool = False
          , add2 = \x y -> x + y
          , add3 = \x y z -> x + y + z
          }
    println j.getFoo
    println j.getBar
    println j.getBool
    println $ j.add2 3 4
    println $ j.add3 3 4 5
    let j = newJ $ IR
          { getFoo = 15000, getBar = 80, getBool = True
          , add2 = \x y -> x * y
          , add3 = \x y z -> x * y * z
          }
    println j.getFoo
    println j.getBar
    println j.getBool
    println $ j.add2 3 4
    println $ j.add3 3 4 5

    useHello

useHello = do
    let h = Hello.new $ HelloImpl { hello = println "Hello Frege!" }
    h.hello
