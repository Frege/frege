module UseJ where

data IR = IR
  { getFoo :: J -> Int, getBar :: J -> Int, getBool :: J -> Bool
  , add2 :: J -> Int -> Int -> Int
  , add3 :: J -> Int -> Int -> Int -> Int
  }

data J = pure native J where
  pure native new "extends" :: IR -> J
  pure native getFoo :: J -> Int
  pure native getBar getBarJava :: J -> Int
  pure native getBool :: J -> Bool
  pure native add2 add :: J -> Int -> Int -> Int
  pure native add3 add :: J -> Int -> Int -> Int -> Int

-- an alternative way to create a new J
pure native newJ "extends" :: IR -> J

main = do
    let j = J.new $ IR
          { getFoo = const 123, getBar = const 5, getBool = const False
          , add2 = \_ x y -> x + y
          , add3 = \_ x y z -> x + y + z
          }
    useJ j
    let j = newJ $ IR
          { getFoo = const 15000, getBar = const 80, getBool = const True
          , add2 = \_ x y -> x * y
          , add3 = \_ x y z -> x * y * z
          }
    useJ j

useJ :: J -> IO ()
useJ j = do
    println j.getFoo
    println j.getBar
    println j.getBool
    println $ j.add2 3 4
    println $ j.add3 3 4 5
