--- Test various map implementations
module examples.MapTest where

-- import frege.Prelude hiding(uniq)
import Data.TreeMap T()
import Data.HashMap(HashMap HM)
import Data.JSON(toJSON)


main ["count"] = count  0 >>= println  
main ["uniq"] = do
    t <- uniq T.Tree.empty
    println $ sumt t
    println $ size t
    
main ["words"] = 
    uniq T.Tree.empty >>= mapM_ println . _.keys

main ["hashtest"] = do
    let e = HM.empty :: HM String Int
    let hm1 = e.insert "foo" 42
    let hm2 = hm1.insert "bar" 54
    let hm3 = hm2.insert "foobar" 54
    println (HM.invariants e)
    println (toJSON e)
    println (HM.invariants hm1)
    println (toJSON hm1)
    println (HM.invariants hm2)
    println (toJSON hm2)
    println (HM.invariants hm3)
    println (toJSON hm3)
    return ()

foldTree âˆ· (c â†’ a â†’ b â†’ c) â†’ c â†’ T.Tree a b â†’ c
foldTree f !a t
    | t.null = a
    | otherwise = foldTree f (foldTree f (f a t.key t.value) t.right) t.left

size âˆ· T.Tree ğ–† ğ–‡ â†’ Int
size t = foldTree (\n\_\_ -> n+1) 0 t

sumt âˆ· T.Tree ğ–† Int â†’ Int
sumt t = foldTree (\n\_\v -> n+v) 0 t

uniq :: T.Tree String Int -> IO (T.Tree String Int)
uniq !tree = do
        more â† stdin.readLine
        case more of
            Just line â†’ uniq (fold process tree (line ~~* '\w+'))
            Nothing   â†’ return tree
    where
        process âˆ· T.Tree String Int â†’ String â†’ T.Tree String Int
        process tree s = tree.insertS  s n
            where !n = 1 + fromMaybe 0 (tree.lookupS s)

count !e = 
        fmap addwords <$> stdin.readLine 
            >>= maybe (return e) count
    where
        addwords s = e + (loop 0 (s =~ '\w+')) 
        loop âˆ· Int â†’ Maybe Matcher â†’ Int
        loop !n Nothing  = n
        loop !n (Just m) = loop (n+1) m.find

